/* soapC.cpp
   Generated by gSOAP 2.8.16 from ServerAPI.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "stdafx.h"
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.16 2014-02-28 18:41:09 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__severity:
		return soap_in_ns1__severity(soap, NULL, NULL, "ns1:severity");
	case SOAP_TYPE_ns1__classPresentationType:
		return soap_in_ns1__classPresentationType(soap, NULL, NULL, "ns1:classPresentationType");
	case SOAP_TYPE_ns1__nodeType:
		return soap_in_ns1__nodeType(soap, NULL, NULL, "ns1:nodeType");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__severity_:
		return soap_in_ns1__severity_(soap, NULL, NULL, "ns1:severity");
	case SOAP_TYPE_ns1__classPresentationType_:
		return soap_in_ns1__classPresentationType_(soap, NULL, NULL, "ns1:classPresentationType");
	case SOAP_TYPE_ns1__nodeType_:
		return soap_in_ns1__nodeType_(soap, NULL, NULL, "ns1:nodeType");
	case SOAP_TYPE_ns2__wfVariableStub:
		return soap_in_ns2__wfVariableStub(soap, NULL, NULL, "ns2:wfVariableStub");
	case SOAP_TYPE_ns1__assignTaskResponse:
		return soap_in_ns1__assignTaskResponse(soap, NULL, NULL, "ns1:assignTaskResponse");
	case SOAP_TYPE_ns1__assignTask:
		return soap_in_ns1__assignTask(soap, NULL, NULL, "ns1:assignTask");
	case SOAP_TYPE_ns1__getTasksResponse:
		return soap_in_ns1__getTasksResponse(soap, NULL, NULL, "ns1:getTasksResponse");
	case SOAP_TYPE_ns1__getTasks:
		return soap_in_ns1__getTasks(soap, NULL, NULL, "ns1:getTasks");
	case SOAP_TYPE_ns1__getProcessesResponse:
		return soap_in_ns1__getProcessesResponse(soap, NULL, NULL, "ns1:getProcessesResponse");
	case SOAP_TYPE_ns1__getProcesses:
		return soap_in_ns1__getProcesses(soap, NULL, NULL, "ns1:getProcesses");
	case SOAP_TYPE_ns1__delegation:
		return soap_in_ns1__delegation(soap, NULL, NULL, "ns1:delegation");
	case SOAP_TYPE_ns1__graphElement:
		return soap_in_ns1__graphElement(soap, NULL, NULL, "ns1:graphElement");
	case SOAP_TYPE_ns1__swimlaneDefinition:
		return soap_in_ns1__swimlaneDefinition(soap, NULL, NULL, "ns1:swimlaneDefinition");
	case SOAP_TYPE_ns1__wfSwimlane:
		return soap_in_ns1__wfSwimlane(soap, NULL, NULL, "ns1:wfSwimlane");
	case SOAP_TYPE_ns1__getSwimlanesResponse:
		return soap_in_ns1__getSwimlanesResponse(soap, NULL, NULL, "ns1:getSwimlanesResponse");
	case SOAP_TYPE_ns1__getSwimlanes:
		return soap_in_ns1__getSwimlanes(soap, NULL, NULL, "ns1:getSwimlanes");
	case SOAP_TYPE_ns1__updateVariablesWSResponse:
		return soap_in_ns1__updateVariablesWSResponse(soap, NULL, NULL, "ns1:updateVariablesWSResponse");
	case SOAP_TYPE_ns1__updateVariablesWS:
		return soap_in_ns1__updateVariablesWS(soap, NULL, NULL, "ns1:updateVariablesWS");
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		return soap_in_ns1__completeTaskWSResponse(soap, NULL, NULL, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_ns1__completeTaskWS:
		return soap_in_ns1__completeTaskWS(soap, NULL, NULL, "ns1:completeTaskWS");
	case SOAP_TYPE_ns1__startProcessWSResponse:
		return soap_in_ns1__startProcessWSResponse(soap, NULL, NULL, "ns1:startProcessWSResponse");
	case SOAP_TYPE_ns1__startProcessWS:
		return soap_in_ns1__startProcessWS(soap, NULL, NULL, "ns1:startProcessWS");
	case SOAP_TYPE_ns1__variable:
		return soap_in_ns1__variable(soap, NULL, NULL, "ns1:variable");
	case SOAP_TYPE_ns1__getVariablesWSResponse:
		return soap_in_ns1__getVariablesWSResponse(soap, NULL, NULL, "ns1:getVariablesWSResponse");
	case SOAP_TYPE_ns1__getVariablesWS:
		return soap_in_ns1__getVariablesWS(soap, NULL, NULL, "ns1:getVariablesWS");
	case SOAP_TYPE_ns1__getSystemLogsCountResponse:
		return soap_in_ns1__getSystemLogsCountResponse(soap, NULL, NULL, "ns1:getSystemLogsCountResponse");
	case SOAP_TYPE_ns1__getSystemLogsCount:
		return soap_in_ns1__getSystemLogsCount(soap, NULL, NULL, "ns1:getSystemLogsCount");
	case SOAP_TYPE_ns1__processDeleteLog:
		return soap_in_ns1__processDeleteLog(soap, NULL, NULL, "ns1:processDeleteLog");
	case SOAP_TYPE_ns1__processDefinitionDeleteLog:
		return soap_in_ns1__processDefinitionDeleteLog(soap, NULL, NULL, "ns1:processDefinitionDeleteLog");
	case SOAP_TYPE_ns1__systemLog:
		return soap_in_ns1__systemLog(soap, NULL, NULL, "ns1:systemLog");
	case SOAP_TYPE_ns1__getSystemLogsResponse:
		return soap_in_ns1__getSystemLogsResponse(soap, NULL, NULL, "ns1:getSystemLogsResponse");
	case SOAP_TYPE_ns1__getSystemLogs:
		return soap_in_ns1__getSystemLogs(soap, NULL, NULL, "ns1:getSystemLogs");
	case SOAP_TYPE_ns1__removeProcessesResponse:
		return soap_in_ns1__removeProcessesResponse(soap, NULL, NULL, "ns1:removeProcessesResponse");
	case SOAP_TYPE_ns1__removeProcesses:
		return soap_in_ns1__removeProcesses(soap, NULL, NULL, "ns1:removeProcesses");
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		return soap_in_ns1__markTaskOpenedResponse(soap, NULL, NULL, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_ns1__markTaskOpened:
		return soap_in_ns1__markTaskOpened(soap, NULL, NULL, "ns1:markTaskOpened");
	case SOAP_TYPE_ns1__getProcessLogValueResponse:
		return soap_in_ns1__getProcessLogValueResponse(soap, NULL, NULL, "ns1:getProcessLogValueResponse");
	case SOAP_TYPE_ns1__getProcessLogValue:
		return soap_in_ns1__getProcessLogValue(soap, NULL, NULL, "ns1:getProcessLogValue");
	case SOAP_TYPE_ns1__processLog:
		return soap_in_ns1__processLog(soap, NULL, NULL, "ns1:processLog");
	case SOAP_TYPE_ns1__processLogs:
		return soap_in_ns1__processLogs(soap, NULL, NULL, "ns1:processLogs");
	case SOAP_TYPE_ns1__getProcessLogsResponse:
		return soap_in_ns1__getProcessLogsResponse(soap, NULL, NULL, "ns1:getProcessLogsResponse");
	case SOAP_TYPE_ns1__processLogFilter:
		return soap_in_ns1__processLogFilter(soap, NULL, NULL, "ns1:processLogFilter");
	case SOAP_TYPE_ns1__getProcessLogs:
		return soap_in_ns1__getProcessLogs(soap, NULL, NULL, "ns1:getProcessLogs");
	case SOAP_TYPE_ns1__assignSwimlaneResponse:
		return soap_in_ns1__assignSwimlaneResponse(soap, NULL, NULL, "ns1:assignSwimlaneResponse");
	case SOAP_TYPE_ns1__assignSwimlane:
		return soap_in_ns1__assignSwimlane(soap, NULL, NULL, "ns1:assignSwimlane");
	case SOAP_TYPE_ns1__getProcessDiagramElementsResponse:
		return soap_in_ns1__getProcessDiagramElementsResponse(soap, NULL, NULL, "ns1:getProcessDiagramElementsResponse");
	case SOAP_TYPE_ns1__getProcessDiagramElements:
		return soap_in_ns1__getProcessDiagramElements(soap, NULL, NULL, "ns1:getProcessDiagramElements");
	case SOAP_TYPE_ns1__getProcessHistoryDiagramResponse:
		return soap_in_ns1__getProcessHistoryDiagramResponse(soap, NULL, NULL, "ns1:getProcessHistoryDiagramResponse");
	case SOAP_TYPE_ns1__getProcessHistoryDiagram:
		return soap_in_ns1__getProcessHistoryDiagram(soap, NULL, NULL, "ns1:getProcessHistoryDiagram");
	case SOAP_TYPE_ns1__getProcessDiagramResponse:
		return soap_in_ns1__getProcessDiagramResponse(soap, NULL, NULL, "ns1:getProcessDiagramResponse");
	case SOAP_TYPE_ns1__getProcessDiagram:
		return soap_in_ns1__getProcessDiagram(soap, NULL, NULL, "ns1:getProcessDiagram");
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		return soap_in_ns1__getProcessTasksResponse(soap, NULL, NULL, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_ns1__getProcessTasks:
		return soap_in_ns1__getProcessTasks(soap, NULL, NULL, "ns1:getProcessTasks");
	case SOAP_TYPE_ns1__cancelProcessResponse:
		return soap_in_ns1__cancelProcessResponse(soap, NULL, NULL, "ns1:cancelProcessResponse");
	case SOAP_TYPE_ns1__cancelProcess:
		return soap_in_ns1__cancelProcess(soap, NULL, NULL, "ns1:cancelProcess");
	case SOAP_TYPE_ns1__getSubprocessesResponse:
		return soap_in_ns1__getSubprocessesResponse(soap, NULL, NULL, "ns1:getSubprocessesResponse");
	case SOAP_TYPE_ns1__getSubprocesses:
		return soap_in_ns1__getSubprocesses(soap, NULL, NULL, "ns1:getSubprocesses");
	case SOAP_TYPE_ns1__getParentProcessResponse:
		return soap_in_ns1__getParentProcessResponse(soap, NULL, NULL, "ns1:getParentProcessResponse");
	case SOAP_TYPE_ns1__getParentProcess:
		return soap_in_ns1__getParentProcess(soap, NULL, NULL, "ns1:getParentProcess");
	case SOAP_TYPE_ns1__getProcessesByFilterResponse:
		return soap_in_ns1__getProcessesByFilterResponse(soap, NULL, NULL, "ns1:getProcessesByFilterResponse");
	case SOAP_TYPE_ns1__processFilter:
		return soap_in_ns1__processFilter(soap, NULL, NULL, "ns1:processFilter");
	case SOAP_TYPE_ns1__getProcessesByFilter:
		return soap_in_ns1__getProcessesByFilter(soap, NULL, NULL, "ns1:getProcessesByFilter");
	case SOAP_TYPE_ns1__getProcessesCountResponse:
		return soap_in_ns1__getProcessesCountResponse(soap, NULL, NULL, "ns1:getProcessesCountResponse");
	case SOAP_TYPE_ns1__batchPresentation:
		return soap_in_ns1__batchPresentation(soap, NULL, NULL, "ns1:batchPresentation");
	case SOAP_TYPE_ns1__getProcessesCount:
		return soap_in_ns1__getProcessesCount(soap, NULL, NULL, "ns1:getProcessesCount");
	case SOAP_TYPE_ns1__variableUserType:
		return soap_in_ns1__variableUserType(soap, NULL, NULL, "ns1:variableUserType");
	case SOAP_TYPE_ns1__variableDefinition:
		return soap_in_ns1__variableDefinition(soap, NULL, NULL, "ns1:variableDefinition");
	case SOAP_TYPE_ns1__getVariableResponse:
		return soap_in_ns1__getVariableResponse(soap, NULL, NULL, "ns1:getVariableResponse");
	case SOAP_TYPE_ns1__getVariable:
		return soap_in_ns1__getVariable(soap, NULL, NULL, "ns1:getVariable");
	case SOAP_TYPE_ns1__wfProcess:
		return soap_in_ns1__wfProcess(soap, NULL, NULL, "ns1:wfProcess");
	case SOAP_TYPE_ns1__getProcessResponse:
		return soap_in_ns1__getProcessResponse(soap, NULL, NULL, "ns1:getProcessResponse");
	case SOAP_TYPE_ns1__getProcess:
		return soap_in_ns1__getProcess(soap, NULL, NULL, "ns1:getProcess");
	case SOAP_TYPE_ns1__wfExecutor:
		return soap_in_ns1__wfExecutor(soap, NULL, NULL, "ns1:wfExecutor");
	case SOAP_TYPE_ns1__wfTask:
		return soap_in_ns1__wfTask(soap, NULL, NULL, "ns1:wfTask");
	case SOAP_TYPE_ns1__getTaskResponse:
		return soap_in_ns1__getTaskResponse(soap, NULL, NULL, "ns1:getTaskResponse");
	case SOAP_TYPE_ns1__getTask:
		return soap_in_ns1__getTask(soap, NULL, NULL, "ns1:getTask");
	case SOAP_TYPE_ns1__graphElementPresentation:
		return soap_in_ns1__graphElementPresentation(soap, NULL, NULL, "ns1:graphElementPresentation");
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse:
		return soap_in_ns1__getProcessHistoryDiagramElementsResponse(soap, NULL, NULL, "ns1:getProcessHistoryDiagramElementsResponse");
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElements:
		return soap_in_ns1__getProcessHistoryDiagramElements(soap, NULL, NULL, "ns1:getProcessHistoryDiagramElements");
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		return soap_in_ns1__authenticateByKerberosResponse(soap, NULL, NULL, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_ns1__authenticateByKerberos:
		return soap_in_ns1__authenticateByKerberos(soap, NULL, NULL, "ns1:authenticateByKerberos");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		return soap_in_ns1__authenticateByCallerPrincipalResponse(soap, NULL, NULL, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		return soap_in_ns1__authenticateByCallerPrincipal(soap, NULL, NULL, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_ns1__identifiable:
		return soap_in_ns1__identifiable(soap, NULL, NULL, "ns1:identifiable");
	case SOAP_TYPE_ns1__identifiableBase:
		return soap_in_ns1__identifiableBase(soap, NULL, NULL, "ns1:identifiableBase");
	case SOAP_TYPE_ns1__executor:
		return soap_in_ns1__executor(soap, NULL, NULL, "ns1:executor");
	case SOAP_TYPE_ns1__actor:
		return soap_in_ns1__actor(soap, NULL, NULL, "ns1:actor");
	case SOAP_TYPE_ns1__user:
		return soap_in_ns1__user(soap, NULL, NULL, "ns1:user");
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		return soap_in_ns1__authenticateByLoginPasswordResponse(soap, NULL, NULL, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		return soap_in_ns1__authenticateByLoginPassword(soap, NULL, NULL, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return soap_in_xsd__base64Binary_(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__updateVariablesWSResponse:
		return soap_in_PointerTons1__updateVariablesWSResponse(soap, NULL, NULL, "ns1:updateVariablesWSResponse");
	case SOAP_TYPE_PointerTons1__updateVariablesWS:
		return soap_in_PointerTons1__updateVariablesWS(soap, NULL, NULL, "ns1:updateVariablesWS");
	case SOAP_TYPE_PointerTons1__startProcessWSResponse:
		return soap_in_PointerTons1__startProcessWSResponse(soap, NULL, NULL, "ns1:startProcessWSResponse");
	case SOAP_TYPE_PointerTons1__startProcessWS:
		return soap_in_PointerTons1__startProcessWS(soap, NULL, NULL, "ns1:startProcessWS");
	case SOAP_TYPE_PointerTons1__removeProcessesResponse:
		return soap_in_PointerTons1__removeProcessesResponse(soap, NULL, NULL, "ns1:removeProcessesResponse");
	case SOAP_TYPE_PointerTons1__removeProcesses:
		return soap_in_PointerTons1__removeProcesses(soap, NULL, NULL, "ns1:removeProcesses");
	case SOAP_TYPE_PointerTons1__markTaskOpenedResponse:
		return soap_in_PointerTons1__markTaskOpenedResponse(soap, NULL, NULL, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_PointerTons1__markTaskOpened:
		return soap_in_PointerTons1__markTaskOpened(soap, NULL, NULL, "ns1:markTaskOpened");
	case SOAP_TYPE_PointerTons1__getVariablesWSResponse:
		return soap_in_PointerTons1__getVariablesWSResponse(soap, NULL, NULL, "ns1:getVariablesWSResponse");
	case SOAP_TYPE_PointerTons1__getVariablesWS:
		return soap_in_PointerTons1__getVariablesWS(soap, NULL, NULL, "ns1:getVariablesWS");
	case SOAP_TYPE_PointerTons1__getVariableResponse:
		return soap_in_PointerTons1__getVariableResponse(soap, NULL, NULL, "ns1:getVariableResponse");
	case SOAP_TYPE_PointerTons1__getVariable:
		return soap_in_PointerTons1__getVariable(soap, NULL, NULL, "ns1:getVariable");
	case SOAP_TYPE_PointerTons1__getTasksResponse:
		return soap_in_PointerTons1__getTasksResponse(soap, NULL, NULL, "ns1:getTasksResponse");
	case SOAP_TYPE_PointerTons1__getTasks:
		return soap_in_PointerTons1__getTasks(soap, NULL, NULL, "ns1:getTasks");
	case SOAP_TYPE_PointerTons1__getTaskResponse:
		return soap_in_PointerTons1__getTaskResponse(soap, NULL, NULL, "ns1:getTaskResponse");
	case SOAP_TYPE_PointerTons1__getTask:
		return soap_in_PointerTons1__getTask(soap, NULL, NULL, "ns1:getTask");
	case SOAP_TYPE_PointerTons1__getSystemLogsCountResponse:
		return soap_in_PointerTons1__getSystemLogsCountResponse(soap, NULL, NULL, "ns1:getSystemLogsCountResponse");
	case SOAP_TYPE_PointerTons1__getSystemLogsCount:
		return soap_in_PointerTons1__getSystemLogsCount(soap, NULL, NULL, "ns1:getSystemLogsCount");
	case SOAP_TYPE_PointerTons1__getSystemLogsResponse:
		return soap_in_PointerTons1__getSystemLogsResponse(soap, NULL, NULL, "ns1:getSystemLogsResponse");
	case SOAP_TYPE_PointerTons1__getSystemLogs:
		return soap_in_PointerTons1__getSystemLogs(soap, NULL, NULL, "ns1:getSystemLogs");
	case SOAP_TYPE_PointerTons1__getSwimlanesResponse:
		return soap_in_PointerTons1__getSwimlanesResponse(soap, NULL, NULL, "ns1:getSwimlanesResponse");
	case SOAP_TYPE_PointerTons1__getSwimlanes:
		return soap_in_PointerTons1__getSwimlanes(soap, NULL, NULL, "ns1:getSwimlanes");
	case SOAP_TYPE_PointerTons1__getSubprocessesResponse:
		return soap_in_PointerTons1__getSubprocessesResponse(soap, NULL, NULL, "ns1:getSubprocessesResponse");
	case SOAP_TYPE_PointerTons1__getSubprocesses:
		return soap_in_PointerTons1__getSubprocesses(soap, NULL, NULL, "ns1:getSubprocesses");
	case SOAP_TYPE_PointerTons1__getProcessesCountResponse:
		return soap_in_PointerTons1__getProcessesCountResponse(soap, NULL, NULL, "ns1:getProcessesCountResponse");
	case SOAP_TYPE_PointerTons1__getProcessesCount:
		return soap_in_PointerTons1__getProcessesCount(soap, NULL, NULL, "ns1:getProcessesCount");
	case SOAP_TYPE_PointerTons1__getProcessesByFilterResponse:
		return soap_in_PointerTons1__getProcessesByFilterResponse(soap, NULL, NULL, "ns1:getProcessesByFilterResponse");
	case SOAP_TYPE_PointerTons1__getProcessesByFilter:
		return soap_in_PointerTons1__getProcessesByFilter(soap, NULL, NULL, "ns1:getProcessesByFilter");
	case SOAP_TYPE_PointerTons1__getProcessesResponse:
		return soap_in_PointerTons1__getProcessesResponse(soap, NULL, NULL, "ns1:getProcessesResponse");
	case SOAP_TYPE_PointerTons1__getProcesses:
		return soap_in_PointerTons1__getProcesses(soap, NULL, NULL, "ns1:getProcesses");
	case SOAP_TYPE_PointerTons1__getProcessTasksResponse:
		return soap_in_PointerTons1__getProcessTasksResponse(soap, NULL, NULL, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_PointerTons1__getProcessTasks:
		return soap_in_PointerTons1__getProcessTasks(soap, NULL, NULL, "ns1:getProcessTasks");
	case SOAP_TYPE_PointerTons1__getProcessLogsResponse:
		return soap_in_PointerTons1__getProcessLogsResponse(soap, NULL, NULL, "ns1:getProcessLogsResponse");
	case SOAP_TYPE_PointerTons1__getProcessLogs:
		return soap_in_PointerTons1__getProcessLogs(soap, NULL, NULL, "ns1:getProcessLogs");
	case SOAP_TYPE_PointerTons1__getProcessLogValueResponse:
		return soap_in_PointerTons1__getProcessLogValueResponse(soap, NULL, NULL, "ns1:getProcessLogValueResponse");
	case SOAP_TYPE_PointerTons1__getProcessLogValue:
		return soap_in_PointerTons1__getProcessLogValue(soap, NULL, NULL, "ns1:getProcessLogValue");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElementsResponse:
		return soap_in_PointerTons1__getProcessHistoryDiagramElementsResponse(soap, NULL, NULL, "ns1:getProcessHistoryDiagramElementsResponse");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElements:
		return soap_in_PointerTons1__getProcessHistoryDiagramElements(soap, NULL, NULL, "ns1:getProcessHistoryDiagramElements");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramResponse:
		return soap_in_PointerTons1__getProcessHistoryDiagramResponse(soap, NULL, NULL, "ns1:getProcessHistoryDiagramResponse");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagram:
		return soap_in_PointerTons1__getProcessHistoryDiagram(soap, NULL, NULL, "ns1:getProcessHistoryDiagram");
	case SOAP_TYPE_PointerTons1__getProcessDiagramElementsResponse:
		return soap_in_PointerTons1__getProcessDiagramElementsResponse(soap, NULL, NULL, "ns1:getProcessDiagramElementsResponse");
	case SOAP_TYPE_PointerTons1__getProcessDiagramElements:
		return soap_in_PointerTons1__getProcessDiagramElements(soap, NULL, NULL, "ns1:getProcessDiagramElements");
	case SOAP_TYPE_PointerTons1__getProcessDiagramResponse:
		return soap_in_PointerTons1__getProcessDiagramResponse(soap, NULL, NULL, "ns1:getProcessDiagramResponse");
	case SOAP_TYPE_PointerTons1__getProcessDiagram:
		return soap_in_PointerTons1__getProcessDiagram(soap, NULL, NULL, "ns1:getProcessDiagram");
	case SOAP_TYPE_PointerTons1__getProcessResponse:
		return soap_in_PointerTons1__getProcessResponse(soap, NULL, NULL, "ns1:getProcessResponse");
	case SOAP_TYPE_PointerTons1__getProcess:
		return soap_in_PointerTons1__getProcess(soap, NULL, NULL, "ns1:getProcess");
	case SOAP_TYPE_PointerTons1__getParentProcessResponse:
		return soap_in_PointerTons1__getParentProcessResponse(soap, NULL, NULL, "ns1:getParentProcessResponse");
	case SOAP_TYPE_PointerTons1__getParentProcess:
		return soap_in_PointerTons1__getParentProcess(soap, NULL, NULL, "ns1:getParentProcess");
	case SOAP_TYPE_PointerTons1__completeTaskWSResponse:
		return soap_in_PointerTons1__completeTaskWSResponse(soap, NULL, NULL, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_PointerTons1__completeTaskWS:
		return soap_in_PointerTons1__completeTaskWS(soap, NULL, NULL, "ns1:completeTaskWS");
	case SOAP_TYPE_PointerTons1__cancelProcessResponse:
		return soap_in_PointerTons1__cancelProcessResponse(soap, NULL, NULL, "ns1:cancelProcessResponse");
	case SOAP_TYPE_PointerTons1__cancelProcess:
		return soap_in_PointerTons1__cancelProcess(soap, NULL, NULL, "ns1:cancelProcess");
	case SOAP_TYPE_PointerTons1__assignTaskResponse:
		return soap_in_PointerTons1__assignTaskResponse(soap, NULL, NULL, "ns1:assignTaskResponse");
	case SOAP_TYPE_PointerTons1__assignTask:
		return soap_in_PointerTons1__assignTask(soap, NULL, NULL, "ns1:assignTask");
	case SOAP_TYPE_PointerTons1__assignSwimlaneResponse:
		return soap_in_PointerTons1__assignSwimlaneResponse(soap, NULL, NULL, "ns1:assignSwimlaneResponse");
	case SOAP_TYPE_PointerTons1__assignSwimlane:
		return soap_in_PointerTons1__assignSwimlane(soap, NULL, NULL, "ns1:assignSwimlane");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse:
		return soap_in_PointerTons1__authenticateByLoginPasswordResponse(soap, NULL, NULL, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPassword:
		return soap_in_PointerTons1__authenticateByLoginPassword(soap, NULL, NULL, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_PointerTons1__authenticateByKerberosResponse:
		return soap_in_PointerTons1__authenticateByKerberosResponse(soap, NULL, NULL, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_PointerTons1__authenticateByKerberos:
		return soap_in_PointerTons1__authenticateByKerberos(soap, NULL, NULL, "ns1:authenticateByKerberos");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse:
		return soap_in_PointerTons1__authenticateByCallerPrincipalResponse(soap, NULL, NULL, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal:
		return soap_in_PointerTons1__authenticateByCallerPrincipal(soap, NULL, NULL, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_PointerTowstring:
		return soap_in_PointerTowstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__delegation:
		return soap_in_PointerTons1__delegation(soap, NULL, NULL, "ns1:delegation");
	case SOAP_TYPE_PointerTons1__swimlaneDefinition:
		return soap_in_PointerTons1__swimlaneDefinition(soap, NULL, NULL, "ns1:swimlaneDefinition");
	case SOAP_TYPE_PointerToPointerTons1__wfSwimlane:
		return soap_in_PointerToPointerTons1__wfSwimlane(soap, NULL, NULL, "ns1:wfSwimlane");
	case SOAP_TYPE_PointerTons1__wfSwimlane:
		return soap_in_PointerTons1__wfSwimlane(soap, NULL, NULL, "ns1:wfSwimlane");
	case SOAP_TYPE_PointerToPointerTons1__variable:
		return soap_in_PointerToPointerTons1__variable(soap, NULL, NULL, "ns1:variable");
	case SOAP_TYPE_PointerTons1__variable:
		return soap_in_PointerTons1__variable(soap, NULL, NULL, "ns1:variable");
	case SOAP_TYPE_PointerToPointerTons1__systemLog:
		return soap_in_PointerToPointerTons1__systemLog(soap, NULL, NULL, "ns1:systemLog");
	case SOAP_TYPE_PointerTons1__systemLog:
		return soap_in_PointerTons1__systemLog(soap, NULL, NULL, "ns1:systemLog");
	case SOAP_TYPE_PointerTons1__severity:
		return soap_in_PointerTons1__severity(soap, NULL, NULL, "ns1:severity");
	case SOAP_TYPE_PointerToPointerTons1__processLog:
		return soap_in_PointerToPointerTons1__processLog(soap, NULL, NULL, "ns1:processLog");
	case SOAP_TYPE_PointerTons1__processLog:
		return soap_in_PointerTons1__processLog(soap, NULL, NULL, "ns1:processLog");
	case SOAP_TYPE_PointerTons1__processLogs:
		return soap_in_PointerTons1__processLogs(soap, NULL, NULL, "ns1:processLogs");
	case SOAP_TYPE_PointerTons1__processLogFilter:
		return soap_in_PointerTons1__processLogFilter(soap, NULL, NULL, "ns1:processLogFilter");
	case SOAP_TYPE_PointerToPointerTons1__wfTask:
		return soap_in_PointerToPointerTons1__wfTask(soap, NULL, NULL, "ns1:wfTask");
	case SOAP_TYPE_PointerToPointerTons1__wfProcess:
		return soap_in_PointerToPointerTons1__wfProcess(soap, NULL, NULL, "ns1:wfProcess");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__processFilter:
		return soap_in_PointerTons1__processFilter(soap, NULL, NULL, "ns1:processFilter");
	case SOAP_TYPE_PointerTons1__classPresentationType:
		return soap_in_PointerTons1__classPresentationType(soap, NULL, NULL, "ns1:classPresentationType");
	case SOAP_TYPE_PointerTons1__batchPresentation:
		return soap_in_PointerTons1__batchPresentation(soap, NULL, NULL, "ns1:batchPresentation");
	case SOAP_TYPE_PointerToPointerTons1__variableDefinition:
		return soap_in_PointerToPointerTons1__variableDefinition(soap, NULL, NULL, "ns1:variableDefinition");
	case SOAP_TYPE_PointerTons1__variableDefinition:
		return soap_in_PointerTons1__variableDefinition(soap, NULL, NULL, "ns1:variableDefinition");
	case SOAP_TYPE_PointerTo_ns1__variableDefinition_userTypes_entry:
		return soap_in_PointerTo_ns1__variableDefinition_userTypes_entry(soap, NULL, NULL, "ns1:variableDefinition-userTypes-entry");
	case SOAP_TYPE_PointerTons1__variableUserType:
		return soap_in_PointerTons1__variableUserType(soap, NULL, NULL, "ns1:variableUserType");
	case SOAP_TYPE_PointerTons2__wfVariableStub:
		return soap_in_PointerTons2__wfVariableStub(soap, NULL, NULL, "ns2:wfVariableStub");
	case SOAP_TYPE_PointerTons1__wfProcess:
		return soap_in_PointerTons1__wfProcess(soap, NULL, NULL, "ns1:wfProcess");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__wfExecutor:
		return soap_in_PointerTons1__wfExecutor(soap, NULL, NULL, "ns1:wfExecutor");
	case SOAP_TYPE_PointerTons1__wfTask:
		return soap_in_PointerTons1__wfTask(soap, NULL, NULL, "ns1:wfTask");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__nodeType:
		return soap_in_PointerTons1__nodeType(soap, NULL, NULL, "ns1:nodeType");
	case SOAP_TYPE_PointerToPointerTons1__graphElementPresentation:
		return soap_in_PointerToPointerTons1__graphElementPresentation(soap, NULL, NULL, "ns1:graphElementPresentation");
	case SOAP_TYPE_PointerTons1__graphElementPresentation:
		return soap_in_PointerTons1__graphElementPresentation(soap, NULL, NULL, "ns1:graphElementPresentation");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__actor:
		return soap_in_PointerTons1__actor(soap, NULL, NULL, "ns1:actor");
	case SOAP_TYPE_PointerTons1__user:
		return soap_in_PointerTons1__user(soap, NULL, NULL, "ns1:user");
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:severity"))
		{	*type = SOAP_TYPE_ns1__severity_;
			return soap_in_ns1__severity_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:classPresentationType"))
		{	*type = SOAP_TYPE_ns1__classPresentationType_;
			return soap_in_ns1__classPresentationType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nodeType"))
		{	*type = SOAP_TYPE_ns1__nodeType_;
			return soap_in_ns1__nodeType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:wfVariableStub"))
		{	*type = SOAP_TYPE_ns2__wfVariableStub;
			return soap_in_ns2__wfVariableStub(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignTaskResponse"))
		{	*type = SOAP_TYPE_ns1__assignTaskResponse;
			return soap_in_ns1__assignTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignTask"))
		{	*type = SOAP_TYPE_ns1__assignTask;
			return soap_in_ns1__assignTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTasksResponse"))
		{	*type = SOAP_TYPE_ns1__getTasksResponse;
			return soap_in_ns1__getTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTasks"))
		{	*type = SOAP_TYPE_ns1__getTasks;
			return soap_in_ns1__getTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessesResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessesResponse;
			return soap_in_ns1__getProcessesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcesses"))
		{	*type = SOAP_TYPE_ns1__getProcesses;
			return soap_in_ns1__getProcesses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:delegation"))
		{	*type = SOAP_TYPE_ns1__delegation;
			return soap_in_ns1__delegation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:graphElement"))
		{	*type = SOAP_TYPE_ns1__graphElement;
			return soap_in_ns1__graphElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:swimlaneDefinition"))
		{	*type = SOAP_TYPE_ns1__swimlaneDefinition;
			return soap_in_ns1__swimlaneDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wfSwimlane"))
		{	*type = SOAP_TYPE_ns1__wfSwimlane;
			return soap_in_ns1__wfSwimlane(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSwimlanesResponse"))
		{	*type = SOAP_TYPE_ns1__getSwimlanesResponse;
			return soap_in_ns1__getSwimlanesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSwimlanes"))
		{	*type = SOAP_TYPE_ns1__getSwimlanes;
			return soap_in_ns1__getSwimlanes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateVariablesWSResponse"))
		{	*type = SOAP_TYPE_ns1__updateVariablesWSResponse;
			return soap_in_ns1__updateVariablesWSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateVariablesWS"))
		{	*type = SOAP_TYPE_ns1__updateVariablesWS;
			return soap_in_ns1__updateVariablesWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:completeTaskWSResponse"))
		{	*type = SOAP_TYPE_ns1__completeTaskWSResponse;
			return soap_in_ns1__completeTaskWSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:completeTaskWS"))
		{	*type = SOAP_TYPE_ns1__completeTaskWS;
			return soap_in_ns1__completeTaskWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:startProcessWSResponse"))
		{	*type = SOAP_TYPE_ns1__startProcessWSResponse;
			return soap_in_ns1__startProcessWSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:startProcessWS"))
		{	*type = SOAP_TYPE_ns1__startProcessWS;
			return soap_in_ns1__startProcessWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:variable"))
		{	*type = SOAP_TYPE_ns1__variable;
			return soap_in_ns1__variable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVariablesWSResponse"))
		{	*type = SOAP_TYPE_ns1__getVariablesWSResponse;
			return soap_in_ns1__getVariablesWSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVariablesWS"))
		{	*type = SOAP_TYPE_ns1__getVariablesWS;
			return soap_in_ns1__getVariablesWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSystemLogsCountResponse"))
		{	*type = SOAP_TYPE_ns1__getSystemLogsCountResponse;
			return soap_in_ns1__getSystemLogsCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSystemLogsCount"))
		{	*type = SOAP_TYPE_ns1__getSystemLogsCount;
			return soap_in_ns1__getSystemLogsCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:processDeleteLog"))
		{	*type = SOAP_TYPE_ns1__processDeleteLog;
			return soap_in_ns1__processDeleteLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:processDefinitionDeleteLog"))
		{	*type = SOAP_TYPE_ns1__processDefinitionDeleteLog;
			return soap_in_ns1__processDefinitionDeleteLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:systemLog"))
		{	*type = SOAP_TYPE_ns1__systemLog;
			return soap_in_ns1__systemLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSystemLogsResponse"))
		{	*type = SOAP_TYPE_ns1__getSystemLogsResponse;
			return soap_in_ns1__getSystemLogsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSystemLogs"))
		{	*type = SOAP_TYPE_ns1__getSystemLogs;
			return soap_in_ns1__getSystemLogs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeProcessesResponse"))
		{	*type = SOAP_TYPE_ns1__removeProcessesResponse;
			return soap_in_ns1__removeProcessesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeProcesses"))
		{	*type = SOAP_TYPE_ns1__removeProcesses;
			return soap_in_ns1__removeProcesses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markTaskOpenedResponse"))
		{	*type = SOAP_TYPE_ns1__markTaskOpenedResponse;
			return soap_in_ns1__markTaskOpenedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markTaskOpened"))
		{	*type = SOAP_TYPE_ns1__markTaskOpened;
			return soap_in_ns1__markTaskOpened(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessLogValueResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessLogValueResponse;
			return soap_in_ns1__getProcessLogValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessLogValue"))
		{	*type = SOAP_TYPE_ns1__getProcessLogValue;
			return soap_in_ns1__getProcessLogValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:processLog"))
		{	*type = SOAP_TYPE_ns1__processLog;
			return soap_in_ns1__processLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:processLogs"))
		{	*type = SOAP_TYPE_ns1__processLogs;
			return soap_in_ns1__processLogs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessLogsResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessLogsResponse;
			return soap_in_ns1__getProcessLogsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:processLogFilter"))
		{	*type = SOAP_TYPE_ns1__processLogFilter;
			return soap_in_ns1__processLogFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessLogs"))
		{	*type = SOAP_TYPE_ns1__getProcessLogs;
			return soap_in_ns1__getProcessLogs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignSwimlaneResponse"))
		{	*type = SOAP_TYPE_ns1__assignSwimlaneResponse;
			return soap_in_ns1__assignSwimlaneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignSwimlane"))
		{	*type = SOAP_TYPE_ns1__assignSwimlane;
			return soap_in_ns1__assignSwimlane(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessDiagramElementsResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessDiagramElementsResponse;
			return soap_in_ns1__getProcessDiagramElementsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessDiagramElements"))
		{	*type = SOAP_TYPE_ns1__getProcessDiagramElements;
			return soap_in_ns1__getProcessDiagramElements(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessHistoryDiagramResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessHistoryDiagramResponse;
			return soap_in_ns1__getProcessHistoryDiagramResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessHistoryDiagram"))
		{	*type = SOAP_TYPE_ns1__getProcessHistoryDiagram;
			return soap_in_ns1__getProcessHistoryDiagram(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessDiagramResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessDiagramResponse;
			return soap_in_ns1__getProcessDiagramResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessDiagram"))
		{	*type = SOAP_TYPE_ns1__getProcessDiagram;
			return soap_in_ns1__getProcessDiagram(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessTasksResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessTasksResponse;
			return soap_in_ns1__getProcessTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessTasks"))
		{	*type = SOAP_TYPE_ns1__getProcessTasks;
			return soap_in_ns1__getProcessTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelProcessResponse"))
		{	*type = SOAP_TYPE_ns1__cancelProcessResponse;
			return soap_in_ns1__cancelProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelProcess"))
		{	*type = SOAP_TYPE_ns1__cancelProcess;
			return soap_in_ns1__cancelProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSubprocessesResponse"))
		{	*type = SOAP_TYPE_ns1__getSubprocessesResponse;
			return soap_in_ns1__getSubprocessesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSubprocesses"))
		{	*type = SOAP_TYPE_ns1__getSubprocesses;
			return soap_in_ns1__getSubprocesses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getParentProcessResponse"))
		{	*type = SOAP_TYPE_ns1__getParentProcessResponse;
			return soap_in_ns1__getParentProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getParentProcess"))
		{	*type = SOAP_TYPE_ns1__getParentProcess;
			return soap_in_ns1__getParentProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessesByFilterResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessesByFilterResponse;
			return soap_in_ns1__getProcessesByFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:processFilter"))
		{	*type = SOAP_TYPE_ns1__processFilter;
			return soap_in_ns1__processFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessesByFilter"))
		{	*type = SOAP_TYPE_ns1__getProcessesByFilter;
			return soap_in_ns1__getProcessesByFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessesCountResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessesCountResponse;
			return soap_in_ns1__getProcessesCountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:batchPresentation"))
		{	*type = SOAP_TYPE_ns1__batchPresentation;
			return soap_in_ns1__batchPresentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessesCount"))
		{	*type = SOAP_TYPE_ns1__getProcessesCount;
			return soap_in_ns1__getProcessesCount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:variableUserType"))
		{	*type = SOAP_TYPE_ns1__variableUserType;
			return soap_in_ns1__variableUserType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:variableDefinition"))
		{	*type = SOAP_TYPE_ns1__variableDefinition;
			return soap_in_ns1__variableDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVariableResponse"))
		{	*type = SOAP_TYPE_ns1__getVariableResponse;
			return soap_in_ns1__getVariableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVariable"))
		{	*type = SOAP_TYPE_ns1__getVariable;
			return soap_in_ns1__getVariable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wfProcess"))
		{	*type = SOAP_TYPE_ns1__wfProcess;
			return soap_in_ns1__wfProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessResponse;
			return soap_in_ns1__getProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcess"))
		{	*type = SOAP_TYPE_ns1__getProcess;
			return soap_in_ns1__getProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wfExecutor"))
		{	*type = SOAP_TYPE_ns1__wfExecutor;
			return soap_in_ns1__wfExecutor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wfTask"))
		{	*type = SOAP_TYPE_ns1__wfTask;
			return soap_in_ns1__wfTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTaskResponse"))
		{	*type = SOAP_TYPE_ns1__getTaskResponse;
			return soap_in_ns1__getTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTask"))
		{	*type = SOAP_TYPE_ns1__getTask;
			return soap_in_ns1__getTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:graphElementPresentation"))
		{	*type = SOAP_TYPE_ns1__graphElementPresentation;
			return soap_in_ns1__graphElementPresentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessHistoryDiagramElementsResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse;
			return soap_in_ns1__getProcessHistoryDiagramElementsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessHistoryDiagramElements"))
		{	*type = SOAP_TYPE_ns1__getProcessHistoryDiagramElements;
			return soap_in_ns1__getProcessHistoryDiagramElements(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByKerberosResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateByKerberosResponse;
			return soap_in_ns1__authenticateByKerberosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByKerberos"))
		{	*type = SOAP_TYPE_ns1__authenticateByKerberos;
			return soap_in_ns1__authenticateByKerberos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByCallerPrincipalResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse;
			return soap_in_ns1__authenticateByCallerPrincipalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByCallerPrincipal"))
		{	*type = SOAP_TYPE_ns1__authenticateByCallerPrincipal;
			return soap_in_ns1__authenticateByCallerPrincipal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:identifiable"))
		{	*type = SOAP_TYPE_ns1__identifiable;
			return soap_in_ns1__identifiable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:identifiableBase"))
		{	*type = SOAP_TYPE_ns1__identifiableBase;
			return soap_in_ns1__identifiableBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:executor"))
		{	*type = SOAP_TYPE_ns1__executor;
			return soap_in_ns1__executor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:actor"))
		{	*type = SOAP_TYPE_ns1__actor;
			return soap_in_ns1__actor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:user"))
		{	*type = SOAP_TYPE_ns1__user;
			return soap_in_ns1__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByLoginPasswordResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateByLoginPasswordResponse;
			return soap_in_ns1__authenticateByLoginPasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByLoginPassword"))
		{	*type = SOAP_TYPE_ns1__authenticateByLoginPassword;
			return soap_in_ns1__authenticateByLoginPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary_;
			return soap_in_xsd__base64Binary_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:severity"))
		{	*type = SOAP_TYPE_ns1__severity;
			return soap_in_ns1__severity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:classPresentationType"))
		{	*type = SOAP_TYPE_ns1__classPresentationType;
			return soap_in_ns1__classPresentationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nodeType"))
		{	*type = SOAP_TYPE_ns1__nodeType;
			return soap_in_ns1__nodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	wchar_t **s;
			*type = SOAP_TYPE_wstring;
			s = soap_in_wstring(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:variableDefinition-userTypes-entry"))
		{	*type = SOAP_TYPE__ns1__variableDefinition_userTypes_entry;
			return soap_in__ns1__variableDefinition_userTypes_entry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:variableDefinition-userTypes"))
		{	*type = SOAP_TYPE__ns1__variableDefinition_userTypes;
			return soap_in__ns1__variableDefinition_userTypes(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__severity:
		return soap_out_ns1__severity(soap, tag, id, (const enum ns1__severity *)ptr, "ns1:severity");
	case SOAP_TYPE_ns1__classPresentationType:
		return soap_out_ns1__classPresentationType(soap, tag, id, (const enum ns1__classPresentationType *)ptr, "ns1:classPresentationType");
	case SOAP_TYPE_ns1__nodeType:
		return soap_out_ns1__nodeType(soap, tag, id, (const enum ns1__nodeType *)ptr, "ns1:nodeType");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__variableDefinition_userTypes_entry:
		return ((_ns1__variableDefinition_userTypes_entry *)ptr)->soap_out(soap, "ns1:variableDefinition-userTypes-entry", id, NULL);
	case SOAP_TYPE__ns1__variableDefinition_userTypes:
		return ((_ns1__variableDefinition_userTypes *)ptr)->soap_out(soap, "ns1:variableDefinition-userTypes", id, NULL);
	case SOAP_TYPE_ns1__severity_:
		return ((ns1__severity_ *)ptr)->soap_out(soap, tag, id, "ns1:severity");
	case SOAP_TYPE_ns1__classPresentationType_:
		return ((ns1__classPresentationType_ *)ptr)->soap_out(soap, tag, id, "ns1:classPresentationType");
	case SOAP_TYPE_ns1__nodeType_:
		return ((ns1__nodeType_ *)ptr)->soap_out(soap, tag, id, "ns1:nodeType");
	case SOAP_TYPE_ns2__wfVariableStub:
		return ((ns2__wfVariableStub *)ptr)->soap_out(soap, tag, id, "ns2:wfVariableStub");
	case SOAP_TYPE_ns1__assignTaskResponse:
		return ((ns1__assignTaskResponse *)ptr)->soap_out(soap, tag, id, "ns1:assignTaskResponse");
	case SOAP_TYPE_ns1__assignTask:
		return ((ns1__assignTask *)ptr)->soap_out(soap, tag, id, "ns1:assignTask");
	case SOAP_TYPE_ns1__getTasksResponse:
		return ((ns1__getTasksResponse *)ptr)->soap_out(soap, tag, id, "ns1:getTasksResponse");
	case SOAP_TYPE_ns1__getTasks:
		return ((ns1__getTasks *)ptr)->soap_out(soap, tag, id, "ns1:getTasks");
	case SOAP_TYPE_ns1__getProcessesResponse:
		return ((ns1__getProcessesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessesResponse");
	case SOAP_TYPE_ns1__getProcesses:
		return ((ns1__getProcesses *)ptr)->soap_out(soap, tag, id, "ns1:getProcesses");
	case SOAP_TYPE_ns1__delegation:
		return ((ns1__delegation *)ptr)->soap_out(soap, tag, id, "ns1:delegation");
	case SOAP_TYPE_ns1__graphElement:
		return ((ns1__graphElement *)ptr)->soap_out(soap, tag, id, "ns1:graphElement");
	case SOAP_TYPE_ns1__swimlaneDefinition:
		return ((ns1__swimlaneDefinition *)ptr)->soap_out(soap, tag, id, "ns1:swimlaneDefinition");
	case SOAP_TYPE_ns1__wfSwimlane:
		return ((ns1__wfSwimlane *)ptr)->soap_out(soap, tag, id, "ns1:wfSwimlane");
	case SOAP_TYPE_ns1__getSwimlanesResponse:
		return ((ns1__getSwimlanesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getSwimlanesResponse");
	case SOAP_TYPE_ns1__getSwimlanes:
		return ((ns1__getSwimlanes *)ptr)->soap_out(soap, tag, id, "ns1:getSwimlanes");
	case SOAP_TYPE_ns1__updateVariablesWSResponse:
		return ((ns1__updateVariablesWSResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateVariablesWSResponse");
	case SOAP_TYPE_ns1__updateVariablesWS:
		return ((ns1__updateVariablesWS *)ptr)->soap_out(soap, tag, id, "ns1:updateVariablesWS");
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		return ((ns1__completeTaskWSResponse *)ptr)->soap_out(soap, tag, id, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_ns1__completeTaskWS:
		return ((ns1__completeTaskWS *)ptr)->soap_out(soap, tag, id, "ns1:completeTaskWS");
	case SOAP_TYPE_ns1__startProcessWSResponse:
		return ((ns1__startProcessWSResponse *)ptr)->soap_out(soap, tag, id, "ns1:startProcessWSResponse");
	case SOAP_TYPE_ns1__startProcessWS:
		return ((ns1__startProcessWS *)ptr)->soap_out(soap, tag, id, "ns1:startProcessWS");
	case SOAP_TYPE_ns1__variable:
		return ((ns1__variable *)ptr)->soap_out(soap, tag, id, "ns1:variable");
	case SOAP_TYPE_ns1__getVariablesWSResponse:
		return ((ns1__getVariablesWSResponse *)ptr)->soap_out(soap, tag, id, "ns1:getVariablesWSResponse");
	case SOAP_TYPE_ns1__getVariablesWS:
		return ((ns1__getVariablesWS *)ptr)->soap_out(soap, tag, id, "ns1:getVariablesWS");
	case SOAP_TYPE_ns1__getSystemLogsCountResponse:
		return ((ns1__getSystemLogsCountResponse *)ptr)->soap_out(soap, tag, id, "ns1:getSystemLogsCountResponse");
	case SOAP_TYPE_ns1__getSystemLogsCount:
		return ((ns1__getSystemLogsCount *)ptr)->soap_out(soap, tag, id, "ns1:getSystemLogsCount");
	case SOAP_TYPE_ns1__processDeleteLog:
		return ((ns1__processDeleteLog *)ptr)->soap_out(soap, tag, id, "ns1:processDeleteLog");
	case SOAP_TYPE_ns1__processDefinitionDeleteLog:
		return ((ns1__processDefinitionDeleteLog *)ptr)->soap_out(soap, tag, id, "ns1:processDefinitionDeleteLog");
	case SOAP_TYPE_ns1__systemLog:
		return ((ns1__systemLog *)ptr)->soap_out(soap, tag, id, "ns1:systemLog");
	case SOAP_TYPE_ns1__getSystemLogsResponse:
		return ((ns1__getSystemLogsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getSystemLogsResponse");
	case SOAP_TYPE_ns1__getSystemLogs:
		return ((ns1__getSystemLogs *)ptr)->soap_out(soap, tag, id, "ns1:getSystemLogs");
	case SOAP_TYPE_ns1__removeProcessesResponse:
		return ((ns1__removeProcessesResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeProcessesResponse");
	case SOAP_TYPE_ns1__removeProcesses:
		return ((ns1__removeProcesses *)ptr)->soap_out(soap, tag, id, "ns1:removeProcesses");
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		return ((ns1__markTaskOpenedResponse *)ptr)->soap_out(soap, tag, id, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_ns1__markTaskOpened:
		return ((ns1__markTaskOpened *)ptr)->soap_out(soap, tag, id, "ns1:markTaskOpened");
	case SOAP_TYPE_ns1__getProcessLogValueResponse:
		return ((ns1__getProcessLogValueResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessLogValueResponse");
	case SOAP_TYPE_ns1__getProcessLogValue:
		return ((ns1__getProcessLogValue *)ptr)->soap_out(soap, tag, id, "ns1:getProcessLogValue");
	case SOAP_TYPE_ns1__processLog:
		return ((ns1__processLog *)ptr)->soap_out(soap, tag, id, "ns1:processLog");
	case SOAP_TYPE_ns1__processLogs:
		return ((ns1__processLogs *)ptr)->soap_out(soap, tag, id, "ns1:processLogs");
	case SOAP_TYPE_ns1__getProcessLogsResponse:
		return ((ns1__getProcessLogsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessLogsResponse");
	case SOAP_TYPE_ns1__processLogFilter:
		return ((ns1__processLogFilter *)ptr)->soap_out(soap, tag, id, "ns1:processLogFilter");
	case SOAP_TYPE_ns1__getProcessLogs:
		return ((ns1__getProcessLogs *)ptr)->soap_out(soap, tag, id, "ns1:getProcessLogs");
	case SOAP_TYPE_ns1__assignSwimlaneResponse:
		return ((ns1__assignSwimlaneResponse *)ptr)->soap_out(soap, tag, id, "ns1:assignSwimlaneResponse");
	case SOAP_TYPE_ns1__assignSwimlane:
		return ((ns1__assignSwimlane *)ptr)->soap_out(soap, tag, id, "ns1:assignSwimlane");
	case SOAP_TYPE_ns1__getProcessDiagramElementsResponse:
		return ((ns1__getProcessDiagramElementsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessDiagramElementsResponse");
	case SOAP_TYPE_ns1__getProcessDiagramElements:
		return ((ns1__getProcessDiagramElements *)ptr)->soap_out(soap, tag, id, "ns1:getProcessDiagramElements");
	case SOAP_TYPE_ns1__getProcessHistoryDiagramResponse:
		return ((ns1__getProcessHistoryDiagramResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessHistoryDiagramResponse");
	case SOAP_TYPE_ns1__getProcessHistoryDiagram:
		return ((ns1__getProcessHistoryDiagram *)ptr)->soap_out(soap, tag, id, "ns1:getProcessHistoryDiagram");
	case SOAP_TYPE_ns1__getProcessDiagramResponse:
		return ((ns1__getProcessDiagramResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessDiagramResponse");
	case SOAP_TYPE_ns1__getProcessDiagram:
		return ((ns1__getProcessDiagram *)ptr)->soap_out(soap, tag, id, "ns1:getProcessDiagram");
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		return ((ns1__getProcessTasksResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_ns1__getProcessTasks:
		return ((ns1__getProcessTasks *)ptr)->soap_out(soap, tag, id, "ns1:getProcessTasks");
	case SOAP_TYPE_ns1__cancelProcessResponse:
		return ((ns1__cancelProcessResponse *)ptr)->soap_out(soap, tag, id, "ns1:cancelProcessResponse");
	case SOAP_TYPE_ns1__cancelProcess:
		return ((ns1__cancelProcess *)ptr)->soap_out(soap, tag, id, "ns1:cancelProcess");
	case SOAP_TYPE_ns1__getSubprocessesResponse:
		return ((ns1__getSubprocessesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getSubprocessesResponse");
	case SOAP_TYPE_ns1__getSubprocesses:
		return ((ns1__getSubprocesses *)ptr)->soap_out(soap, tag, id, "ns1:getSubprocesses");
	case SOAP_TYPE_ns1__getParentProcessResponse:
		return ((ns1__getParentProcessResponse *)ptr)->soap_out(soap, tag, id, "ns1:getParentProcessResponse");
	case SOAP_TYPE_ns1__getParentProcess:
		return ((ns1__getParentProcess *)ptr)->soap_out(soap, tag, id, "ns1:getParentProcess");
	case SOAP_TYPE_ns1__getProcessesByFilterResponse:
		return ((ns1__getProcessesByFilterResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessesByFilterResponse");
	case SOAP_TYPE_ns1__processFilter:
		return ((ns1__processFilter *)ptr)->soap_out(soap, tag, id, "ns1:processFilter");
	case SOAP_TYPE_ns1__getProcessesByFilter:
		return ((ns1__getProcessesByFilter *)ptr)->soap_out(soap, tag, id, "ns1:getProcessesByFilter");
	case SOAP_TYPE_ns1__getProcessesCountResponse:
		return ((ns1__getProcessesCountResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessesCountResponse");
	case SOAP_TYPE_ns1__batchPresentation:
		return ((ns1__batchPresentation *)ptr)->soap_out(soap, tag, id, "ns1:batchPresentation");
	case SOAP_TYPE_ns1__getProcessesCount:
		return ((ns1__getProcessesCount *)ptr)->soap_out(soap, tag, id, "ns1:getProcessesCount");
	case SOAP_TYPE_ns1__variableUserType:
		return ((ns1__variableUserType *)ptr)->soap_out(soap, tag, id, "ns1:variableUserType");
	case SOAP_TYPE_ns1__variableDefinition:
		return ((ns1__variableDefinition *)ptr)->soap_out(soap, tag, id, "ns1:variableDefinition");
	case SOAP_TYPE_ns1__getVariableResponse:
		return ((ns1__getVariableResponse *)ptr)->soap_out(soap, tag, id, "ns1:getVariableResponse");
	case SOAP_TYPE_ns1__getVariable:
		return ((ns1__getVariable *)ptr)->soap_out(soap, tag, id, "ns1:getVariable");
	case SOAP_TYPE_ns1__wfProcess:
		return ((ns1__wfProcess *)ptr)->soap_out(soap, tag, id, "ns1:wfProcess");
	case SOAP_TYPE_ns1__getProcessResponse:
		return ((ns1__getProcessResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessResponse");
	case SOAP_TYPE_ns1__getProcess:
		return ((ns1__getProcess *)ptr)->soap_out(soap, tag, id, "ns1:getProcess");
	case SOAP_TYPE_ns1__wfExecutor:
		return ((ns1__wfExecutor *)ptr)->soap_out(soap, tag, id, "ns1:wfExecutor");
	case SOAP_TYPE_ns1__wfTask:
		return ((ns1__wfTask *)ptr)->soap_out(soap, tag, id, "ns1:wfTask");
	case SOAP_TYPE_ns1__getTaskResponse:
		return ((ns1__getTaskResponse *)ptr)->soap_out(soap, tag, id, "ns1:getTaskResponse");
	case SOAP_TYPE_ns1__getTask:
		return ((ns1__getTask *)ptr)->soap_out(soap, tag, id, "ns1:getTask");
	case SOAP_TYPE_ns1__graphElementPresentation:
		return ((ns1__graphElementPresentation *)ptr)->soap_out(soap, tag, id, "ns1:graphElementPresentation");
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse:
		return ((ns1__getProcessHistoryDiagramElementsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessHistoryDiagramElementsResponse");
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElements:
		return ((ns1__getProcessHistoryDiagramElements *)ptr)->soap_out(soap, tag, id, "ns1:getProcessHistoryDiagramElements");
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		return ((ns1__authenticateByKerberosResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_ns1__authenticateByKerberos:
		return ((ns1__authenticateByKerberos *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByKerberos");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		return ((ns1__authenticateByCallerPrincipalResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		return ((ns1__authenticateByCallerPrincipal *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_ns1__identifiable:
		return ((ns1__identifiable *)ptr)->soap_out(soap, tag, id, "ns1:identifiable");
	case SOAP_TYPE_ns1__identifiableBase:
		return ((ns1__identifiableBase *)ptr)->soap_out(soap, tag, id, "ns1:identifiableBase");
	case SOAP_TYPE_ns1__executor:
		return ((ns1__executor *)ptr)->soap_out(soap, tag, id, "ns1:executor");
	case SOAP_TYPE_ns1__actor:
		return ((ns1__actor *)ptr)->soap_out(soap, tag, id, "ns1:actor");
	case SOAP_TYPE_ns1__user:
		return ((ns1__user *)ptr)->soap_out(soap, tag, id, "ns1:user");
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		return ((ns1__authenticateByLoginPasswordResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		return ((ns1__authenticateByLoginPassword *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return ((xsd__base64Binary_ *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__updateVariablesWSResponse:
		return soap_out_PointerTons1__updateVariablesWSResponse(soap, tag, id, (ns1__updateVariablesWSResponse *const*)ptr, "ns1:updateVariablesWSResponse");
	case SOAP_TYPE_PointerTons1__updateVariablesWS:
		return soap_out_PointerTons1__updateVariablesWS(soap, tag, id, (ns1__updateVariablesWS *const*)ptr, "ns1:updateVariablesWS");
	case SOAP_TYPE_PointerTons1__startProcessWSResponse:
		return soap_out_PointerTons1__startProcessWSResponse(soap, tag, id, (ns1__startProcessWSResponse *const*)ptr, "ns1:startProcessWSResponse");
	case SOAP_TYPE_PointerTons1__startProcessWS:
		return soap_out_PointerTons1__startProcessWS(soap, tag, id, (ns1__startProcessWS *const*)ptr, "ns1:startProcessWS");
	case SOAP_TYPE_PointerTons1__removeProcessesResponse:
		return soap_out_PointerTons1__removeProcessesResponse(soap, tag, id, (ns1__removeProcessesResponse *const*)ptr, "ns1:removeProcessesResponse");
	case SOAP_TYPE_PointerTons1__removeProcesses:
		return soap_out_PointerTons1__removeProcesses(soap, tag, id, (ns1__removeProcesses *const*)ptr, "ns1:removeProcesses");
	case SOAP_TYPE_PointerTons1__markTaskOpenedResponse:
		return soap_out_PointerTons1__markTaskOpenedResponse(soap, tag, id, (ns1__markTaskOpenedResponse *const*)ptr, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_PointerTons1__markTaskOpened:
		return soap_out_PointerTons1__markTaskOpened(soap, tag, id, (ns1__markTaskOpened *const*)ptr, "ns1:markTaskOpened");
	case SOAP_TYPE_PointerTons1__getVariablesWSResponse:
		return soap_out_PointerTons1__getVariablesWSResponse(soap, tag, id, (ns1__getVariablesWSResponse *const*)ptr, "ns1:getVariablesWSResponse");
	case SOAP_TYPE_PointerTons1__getVariablesWS:
		return soap_out_PointerTons1__getVariablesWS(soap, tag, id, (ns1__getVariablesWS *const*)ptr, "ns1:getVariablesWS");
	case SOAP_TYPE_PointerTons1__getVariableResponse:
		return soap_out_PointerTons1__getVariableResponse(soap, tag, id, (ns1__getVariableResponse *const*)ptr, "ns1:getVariableResponse");
	case SOAP_TYPE_PointerTons1__getVariable:
		return soap_out_PointerTons1__getVariable(soap, tag, id, (ns1__getVariable *const*)ptr, "ns1:getVariable");
	case SOAP_TYPE_PointerTons1__getTasksResponse:
		return soap_out_PointerTons1__getTasksResponse(soap, tag, id, (ns1__getTasksResponse *const*)ptr, "ns1:getTasksResponse");
	case SOAP_TYPE_PointerTons1__getTasks:
		return soap_out_PointerTons1__getTasks(soap, tag, id, (ns1__getTasks *const*)ptr, "ns1:getTasks");
	case SOAP_TYPE_PointerTons1__getTaskResponse:
		return soap_out_PointerTons1__getTaskResponse(soap, tag, id, (ns1__getTaskResponse *const*)ptr, "ns1:getTaskResponse");
	case SOAP_TYPE_PointerTons1__getTask:
		return soap_out_PointerTons1__getTask(soap, tag, id, (ns1__getTask *const*)ptr, "ns1:getTask");
	case SOAP_TYPE_PointerTons1__getSystemLogsCountResponse:
		return soap_out_PointerTons1__getSystemLogsCountResponse(soap, tag, id, (ns1__getSystemLogsCountResponse *const*)ptr, "ns1:getSystemLogsCountResponse");
	case SOAP_TYPE_PointerTons1__getSystemLogsCount:
		return soap_out_PointerTons1__getSystemLogsCount(soap, tag, id, (ns1__getSystemLogsCount *const*)ptr, "ns1:getSystemLogsCount");
	case SOAP_TYPE_PointerTons1__getSystemLogsResponse:
		return soap_out_PointerTons1__getSystemLogsResponse(soap, tag, id, (ns1__getSystemLogsResponse *const*)ptr, "ns1:getSystemLogsResponse");
	case SOAP_TYPE_PointerTons1__getSystemLogs:
		return soap_out_PointerTons1__getSystemLogs(soap, tag, id, (ns1__getSystemLogs *const*)ptr, "ns1:getSystemLogs");
	case SOAP_TYPE_PointerTons1__getSwimlanesResponse:
		return soap_out_PointerTons1__getSwimlanesResponse(soap, tag, id, (ns1__getSwimlanesResponse *const*)ptr, "ns1:getSwimlanesResponse");
	case SOAP_TYPE_PointerTons1__getSwimlanes:
		return soap_out_PointerTons1__getSwimlanes(soap, tag, id, (ns1__getSwimlanes *const*)ptr, "ns1:getSwimlanes");
	case SOAP_TYPE_PointerTons1__getSubprocessesResponse:
		return soap_out_PointerTons1__getSubprocessesResponse(soap, tag, id, (ns1__getSubprocessesResponse *const*)ptr, "ns1:getSubprocessesResponse");
	case SOAP_TYPE_PointerTons1__getSubprocesses:
		return soap_out_PointerTons1__getSubprocesses(soap, tag, id, (ns1__getSubprocesses *const*)ptr, "ns1:getSubprocesses");
	case SOAP_TYPE_PointerTons1__getProcessesCountResponse:
		return soap_out_PointerTons1__getProcessesCountResponse(soap, tag, id, (ns1__getProcessesCountResponse *const*)ptr, "ns1:getProcessesCountResponse");
	case SOAP_TYPE_PointerTons1__getProcessesCount:
		return soap_out_PointerTons1__getProcessesCount(soap, tag, id, (ns1__getProcessesCount *const*)ptr, "ns1:getProcessesCount");
	case SOAP_TYPE_PointerTons1__getProcessesByFilterResponse:
		return soap_out_PointerTons1__getProcessesByFilterResponse(soap, tag, id, (ns1__getProcessesByFilterResponse *const*)ptr, "ns1:getProcessesByFilterResponse");
	case SOAP_TYPE_PointerTons1__getProcessesByFilter:
		return soap_out_PointerTons1__getProcessesByFilter(soap, tag, id, (ns1__getProcessesByFilter *const*)ptr, "ns1:getProcessesByFilter");
	case SOAP_TYPE_PointerTons1__getProcessesResponse:
		return soap_out_PointerTons1__getProcessesResponse(soap, tag, id, (ns1__getProcessesResponse *const*)ptr, "ns1:getProcessesResponse");
	case SOAP_TYPE_PointerTons1__getProcesses:
		return soap_out_PointerTons1__getProcesses(soap, tag, id, (ns1__getProcesses *const*)ptr, "ns1:getProcesses");
	case SOAP_TYPE_PointerTons1__getProcessTasksResponse:
		return soap_out_PointerTons1__getProcessTasksResponse(soap, tag, id, (ns1__getProcessTasksResponse *const*)ptr, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_PointerTons1__getProcessTasks:
		return soap_out_PointerTons1__getProcessTasks(soap, tag, id, (ns1__getProcessTasks *const*)ptr, "ns1:getProcessTasks");
	case SOAP_TYPE_PointerTons1__getProcessLogsResponse:
		return soap_out_PointerTons1__getProcessLogsResponse(soap, tag, id, (ns1__getProcessLogsResponse *const*)ptr, "ns1:getProcessLogsResponse");
	case SOAP_TYPE_PointerTons1__getProcessLogs:
		return soap_out_PointerTons1__getProcessLogs(soap, tag, id, (ns1__getProcessLogs *const*)ptr, "ns1:getProcessLogs");
	case SOAP_TYPE_PointerTons1__getProcessLogValueResponse:
		return soap_out_PointerTons1__getProcessLogValueResponse(soap, tag, id, (ns1__getProcessLogValueResponse *const*)ptr, "ns1:getProcessLogValueResponse");
	case SOAP_TYPE_PointerTons1__getProcessLogValue:
		return soap_out_PointerTons1__getProcessLogValue(soap, tag, id, (ns1__getProcessLogValue *const*)ptr, "ns1:getProcessLogValue");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElementsResponse:
		return soap_out_PointerTons1__getProcessHistoryDiagramElementsResponse(soap, tag, id, (ns1__getProcessHistoryDiagramElementsResponse *const*)ptr, "ns1:getProcessHistoryDiagramElementsResponse");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElements:
		return soap_out_PointerTons1__getProcessHistoryDiagramElements(soap, tag, id, (ns1__getProcessHistoryDiagramElements *const*)ptr, "ns1:getProcessHistoryDiagramElements");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramResponse:
		return soap_out_PointerTons1__getProcessHistoryDiagramResponse(soap, tag, id, (ns1__getProcessHistoryDiagramResponse *const*)ptr, "ns1:getProcessHistoryDiagramResponse");
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagram:
		return soap_out_PointerTons1__getProcessHistoryDiagram(soap, tag, id, (ns1__getProcessHistoryDiagram *const*)ptr, "ns1:getProcessHistoryDiagram");
	case SOAP_TYPE_PointerTons1__getProcessDiagramElementsResponse:
		return soap_out_PointerTons1__getProcessDiagramElementsResponse(soap, tag, id, (ns1__getProcessDiagramElementsResponse *const*)ptr, "ns1:getProcessDiagramElementsResponse");
	case SOAP_TYPE_PointerTons1__getProcessDiagramElements:
		return soap_out_PointerTons1__getProcessDiagramElements(soap, tag, id, (ns1__getProcessDiagramElements *const*)ptr, "ns1:getProcessDiagramElements");
	case SOAP_TYPE_PointerTons1__getProcessDiagramResponse:
		return soap_out_PointerTons1__getProcessDiagramResponse(soap, tag, id, (ns1__getProcessDiagramResponse *const*)ptr, "ns1:getProcessDiagramResponse");
	case SOAP_TYPE_PointerTons1__getProcessDiagram:
		return soap_out_PointerTons1__getProcessDiagram(soap, tag, id, (ns1__getProcessDiagram *const*)ptr, "ns1:getProcessDiagram");
	case SOAP_TYPE_PointerTons1__getProcessResponse:
		return soap_out_PointerTons1__getProcessResponse(soap, tag, id, (ns1__getProcessResponse *const*)ptr, "ns1:getProcessResponse");
	case SOAP_TYPE_PointerTons1__getProcess:
		return soap_out_PointerTons1__getProcess(soap, tag, id, (ns1__getProcess *const*)ptr, "ns1:getProcess");
	case SOAP_TYPE_PointerTons1__getParentProcessResponse:
		return soap_out_PointerTons1__getParentProcessResponse(soap, tag, id, (ns1__getParentProcessResponse *const*)ptr, "ns1:getParentProcessResponse");
	case SOAP_TYPE_PointerTons1__getParentProcess:
		return soap_out_PointerTons1__getParentProcess(soap, tag, id, (ns1__getParentProcess *const*)ptr, "ns1:getParentProcess");
	case SOAP_TYPE_PointerTons1__completeTaskWSResponse:
		return soap_out_PointerTons1__completeTaskWSResponse(soap, tag, id, (ns1__completeTaskWSResponse *const*)ptr, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_PointerTons1__completeTaskWS:
		return soap_out_PointerTons1__completeTaskWS(soap, tag, id, (ns1__completeTaskWS *const*)ptr, "ns1:completeTaskWS");
	case SOAP_TYPE_PointerTons1__cancelProcessResponse:
		return soap_out_PointerTons1__cancelProcessResponse(soap, tag, id, (ns1__cancelProcessResponse *const*)ptr, "ns1:cancelProcessResponse");
	case SOAP_TYPE_PointerTons1__cancelProcess:
		return soap_out_PointerTons1__cancelProcess(soap, tag, id, (ns1__cancelProcess *const*)ptr, "ns1:cancelProcess");
	case SOAP_TYPE_PointerTons1__assignTaskResponse:
		return soap_out_PointerTons1__assignTaskResponse(soap, tag, id, (ns1__assignTaskResponse *const*)ptr, "ns1:assignTaskResponse");
	case SOAP_TYPE_PointerTons1__assignTask:
		return soap_out_PointerTons1__assignTask(soap, tag, id, (ns1__assignTask *const*)ptr, "ns1:assignTask");
	case SOAP_TYPE_PointerTons1__assignSwimlaneResponse:
		return soap_out_PointerTons1__assignSwimlaneResponse(soap, tag, id, (ns1__assignSwimlaneResponse *const*)ptr, "ns1:assignSwimlaneResponse");
	case SOAP_TYPE_PointerTons1__assignSwimlane:
		return soap_out_PointerTons1__assignSwimlane(soap, tag, id, (ns1__assignSwimlane *const*)ptr, "ns1:assignSwimlane");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse:
		return soap_out_PointerTons1__authenticateByLoginPasswordResponse(soap, tag, id, (ns1__authenticateByLoginPasswordResponse *const*)ptr, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPassword:
		return soap_out_PointerTons1__authenticateByLoginPassword(soap, tag, id, (ns1__authenticateByLoginPassword *const*)ptr, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_PointerTons1__authenticateByKerberosResponse:
		return soap_out_PointerTons1__authenticateByKerberosResponse(soap, tag, id, (ns1__authenticateByKerberosResponse *const*)ptr, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_PointerTons1__authenticateByKerberos:
		return soap_out_PointerTons1__authenticateByKerberos(soap, tag, id, (ns1__authenticateByKerberos *const*)ptr, "ns1:authenticateByKerberos");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse:
		return soap_out_PointerTons1__authenticateByCallerPrincipalResponse(soap, tag, id, (ns1__authenticateByCallerPrincipalResponse *const*)ptr, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal:
		return soap_out_PointerTons1__authenticateByCallerPrincipal(soap, tag, id, (ns1__authenticateByCallerPrincipal *const*)ptr, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_PointerTowstring:
		return soap_out_PointerTowstring(soap, tag, id, (wchar_t **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__delegation:
		return soap_out_PointerTons1__delegation(soap, tag, id, (ns1__delegation *const*)ptr, "ns1:delegation");
	case SOAP_TYPE_PointerTons1__swimlaneDefinition:
		return soap_out_PointerTons1__swimlaneDefinition(soap, tag, id, (ns1__swimlaneDefinition *const*)ptr, "ns1:swimlaneDefinition");
	case SOAP_TYPE_PointerToPointerTons1__wfSwimlane:
		return soap_out_PointerToPointerTons1__wfSwimlane(soap, tag, id, (ns1__wfSwimlane **const*)ptr, "ns1:wfSwimlane");
	case SOAP_TYPE_PointerTons1__wfSwimlane:
		return soap_out_PointerTons1__wfSwimlane(soap, tag, id, (ns1__wfSwimlane *const*)ptr, "ns1:wfSwimlane");
	case SOAP_TYPE_PointerToPointerTons1__variable:
		return soap_out_PointerToPointerTons1__variable(soap, tag, id, (ns1__variable **const*)ptr, "ns1:variable");
	case SOAP_TYPE_PointerTons1__variable:
		return soap_out_PointerTons1__variable(soap, tag, id, (ns1__variable *const*)ptr, "ns1:variable");
	case SOAP_TYPE_PointerToPointerTons1__systemLog:
		return soap_out_PointerToPointerTons1__systemLog(soap, tag, id, (ns1__systemLog **const*)ptr, "ns1:systemLog");
	case SOAP_TYPE_PointerTons1__systemLog:
		return soap_out_PointerTons1__systemLog(soap, tag, id, (ns1__systemLog *const*)ptr, "ns1:systemLog");
	case SOAP_TYPE_PointerTons1__severity:
		return soap_out_PointerTons1__severity(soap, tag, id, (enum ns1__severity *const*)ptr, "ns1:severity");
	case SOAP_TYPE_PointerToPointerTons1__processLog:
		return soap_out_PointerToPointerTons1__processLog(soap, tag, id, (ns1__processLog **const*)ptr, "ns1:processLog");
	case SOAP_TYPE_PointerTons1__processLog:
		return soap_out_PointerTons1__processLog(soap, tag, id, (ns1__processLog *const*)ptr, "ns1:processLog");
	case SOAP_TYPE_PointerTons1__processLogs:
		return soap_out_PointerTons1__processLogs(soap, tag, id, (ns1__processLogs *const*)ptr, "ns1:processLogs");
	case SOAP_TYPE_PointerTons1__processLogFilter:
		return soap_out_PointerTons1__processLogFilter(soap, tag, id, (ns1__processLogFilter *const*)ptr, "ns1:processLogFilter");
	case SOAP_TYPE_PointerToPointerTons1__wfTask:
		return soap_out_PointerToPointerTons1__wfTask(soap, tag, id, (ns1__wfTask **const*)ptr, "ns1:wfTask");
	case SOAP_TYPE_PointerToPointerTons1__wfProcess:
		return soap_out_PointerToPointerTons1__wfProcess(soap, tag, id, (ns1__wfProcess **const*)ptr, "ns1:wfProcess");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__processFilter:
		return soap_out_PointerTons1__processFilter(soap, tag, id, (ns1__processFilter *const*)ptr, "ns1:processFilter");
	case SOAP_TYPE_PointerTons1__classPresentationType:
		return soap_out_PointerTons1__classPresentationType(soap, tag, id, (enum ns1__classPresentationType *const*)ptr, "ns1:classPresentationType");
	case SOAP_TYPE_PointerTons1__batchPresentation:
		return soap_out_PointerTons1__batchPresentation(soap, tag, id, (ns1__batchPresentation *const*)ptr, "ns1:batchPresentation");
	case SOAP_TYPE_PointerToPointerTons1__variableDefinition:
		return soap_out_PointerToPointerTons1__variableDefinition(soap, tag, id, (ns1__variableDefinition **const*)ptr, "ns1:variableDefinition");
	case SOAP_TYPE_PointerTons1__variableDefinition:
		return soap_out_PointerTons1__variableDefinition(soap, tag, id, (ns1__variableDefinition *const*)ptr, "ns1:variableDefinition");
	case SOAP_TYPE_PointerTo_ns1__variableDefinition_userTypes_entry:
		return soap_out_PointerTo_ns1__variableDefinition_userTypes_entry(soap, tag, id, (_ns1__variableDefinition_userTypes_entry *const*)ptr, "ns1:variableDefinition-userTypes-entry");
	case SOAP_TYPE_PointerTons1__variableUserType:
		return soap_out_PointerTons1__variableUserType(soap, tag, id, (ns1__variableUserType *const*)ptr, "ns1:variableUserType");
	case SOAP_TYPE_PointerTons2__wfVariableStub:
		return soap_out_PointerTons2__wfVariableStub(soap, tag, id, (ns2__wfVariableStub *const*)ptr, "ns2:wfVariableStub");
	case SOAP_TYPE_PointerTons1__wfProcess:
		return soap_out_PointerTons1__wfProcess(soap, tag, id, (ns1__wfProcess *const*)ptr, "ns1:wfProcess");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__wfExecutor:
		return soap_out_PointerTons1__wfExecutor(soap, tag, id, (ns1__wfExecutor *const*)ptr, "ns1:wfExecutor");
	case SOAP_TYPE_PointerTons1__wfTask:
		return soap_out_PointerTons1__wfTask(soap, tag, id, (ns1__wfTask *const*)ptr, "ns1:wfTask");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__nodeType:
		return soap_out_PointerTons1__nodeType(soap, tag, id, (enum ns1__nodeType *const*)ptr, "ns1:nodeType");
	case SOAP_TYPE_PointerToPointerTons1__graphElementPresentation:
		return soap_out_PointerToPointerTons1__graphElementPresentation(soap, tag, id, (ns1__graphElementPresentation **const*)ptr, "ns1:graphElementPresentation");
	case SOAP_TYPE_PointerTons1__graphElementPresentation:
		return soap_out_PointerTons1__graphElementPresentation(soap, tag, id, (ns1__graphElementPresentation *const*)ptr, "ns1:graphElementPresentation");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__actor:
		return soap_out_PointerTons1__actor(soap, tag, id, (ns1__actor *const*)ptr, "ns1:actor");
	case SOAP_TYPE_PointerTons1__user:
		return soap_out_PointerTons1__user(soap, tag, id, (ns1__user *const*)ptr, "ns1:user");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__variableDefinition_userTypes_entry:
		((_ns1__variableDefinition_userTypes_entry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__variableDefinition_userTypes:
		((_ns1__variableDefinition_userTypes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__severity_:
		((ns1__severity_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__classPresentationType_:
		((ns1__classPresentationType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__nodeType_:
		((ns1__nodeType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__wfVariableStub:
		((ns2__wfVariableStub *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignTaskResponse:
		((ns1__assignTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignTask:
		((ns1__assignTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTasksResponse:
		((ns1__getTasksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTasks:
		((ns1__getTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessesResponse:
		((ns1__getProcessesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcesses:
		((ns1__getProcesses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__delegation:
		((ns1__delegation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__graphElement:
		((ns1__graphElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__swimlaneDefinition:
		((ns1__swimlaneDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wfSwimlane:
		((ns1__wfSwimlane *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSwimlanesResponse:
		((ns1__getSwimlanesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSwimlanes:
		((ns1__getSwimlanes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateVariablesWSResponse:
		((ns1__updateVariablesWSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateVariablesWS:
		((ns1__updateVariablesWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		((ns1__completeTaskWSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__completeTaskWS:
		((ns1__completeTaskWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__startProcessWSResponse:
		((ns1__startProcessWSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__startProcessWS:
		((ns1__startProcessWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__variable:
		((ns1__variable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getVariablesWSResponse:
		((ns1__getVariablesWSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getVariablesWS:
		((ns1__getVariablesWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSystemLogsCountResponse:
		((ns1__getSystemLogsCountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSystemLogsCount:
		((ns1__getSystemLogsCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__processDeleteLog:
		((ns1__processDeleteLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__processDefinitionDeleteLog:
		((ns1__processDefinitionDeleteLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__systemLog:
		((ns1__systemLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSystemLogsResponse:
		((ns1__getSystemLogsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSystemLogs:
		((ns1__getSystemLogs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeProcessesResponse:
		((ns1__removeProcessesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeProcesses:
		((ns1__removeProcesses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		((ns1__markTaskOpenedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__markTaskOpened:
		((ns1__markTaskOpened *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessLogValueResponse:
		((ns1__getProcessLogValueResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessLogValue:
		((ns1__getProcessLogValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__processLog:
		((ns1__processLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__processLogs:
		((ns1__processLogs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessLogsResponse:
		((ns1__getProcessLogsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__processLogFilter:
		((ns1__processLogFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessLogs:
		((ns1__getProcessLogs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignSwimlaneResponse:
		((ns1__assignSwimlaneResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignSwimlane:
		((ns1__assignSwimlane *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessDiagramElementsResponse:
		((ns1__getProcessDiagramElementsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessDiagramElements:
		((ns1__getProcessDiagramElements *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagramResponse:
		((ns1__getProcessHistoryDiagramResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagram:
		((ns1__getProcessHistoryDiagram *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessDiagramResponse:
		((ns1__getProcessDiagramResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessDiagram:
		((ns1__getProcessDiagram *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		((ns1__getProcessTasksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessTasks:
		((ns1__getProcessTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cancelProcessResponse:
		((ns1__cancelProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cancelProcess:
		((ns1__cancelProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSubprocessesResponse:
		((ns1__getSubprocessesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getSubprocesses:
		((ns1__getSubprocesses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getParentProcessResponse:
		((ns1__getParentProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getParentProcess:
		((ns1__getParentProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessesByFilterResponse:
		((ns1__getProcessesByFilterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__processFilter:
		((ns1__processFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessesByFilter:
		((ns1__getProcessesByFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessesCountResponse:
		((ns1__getProcessesCountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__batchPresentation:
		((ns1__batchPresentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessesCount:
		((ns1__getProcessesCount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__variableUserType:
		((ns1__variableUserType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__variableDefinition:
		((ns1__variableDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getVariableResponse:
		((ns1__getVariableResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getVariable:
		((ns1__getVariable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wfProcess:
		((ns1__wfProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessResponse:
		((ns1__getProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcess:
		((ns1__getProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wfExecutor:
		((ns1__wfExecutor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wfTask:
		((ns1__wfTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTaskResponse:
		((ns1__getTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTask:
		((ns1__getTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__graphElementPresentation:
		((ns1__graphElementPresentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse:
		((ns1__getProcessHistoryDiagramElementsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElements:
		((ns1__getProcessHistoryDiagramElements *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		((ns1__authenticateByKerberosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberos:
		((ns1__authenticateByKerberos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		((ns1__authenticateByCallerPrincipalResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		((ns1__authenticateByCallerPrincipal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__identifiable:
		((ns1__identifiable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__identifiableBase:
		((ns1__identifiableBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__executor:
		((ns1__executor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__actor:
		((ns1__actor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__user:
		((ns1__user *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		((ns1__authenticateByLoginPasswordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		((ns1__authenticateByLoginPassword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		((xsd__base64Binary_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__updateVariablesWS:
		soap_serialize___ns1__updateVariablesWS(soap, (const struct __ns1__updateVariablesWS *)ptr);
		break;
	case SOAP_TYPE___ns1__updateVariablesWSResponse:
		soap_serialize___ns1__updateVariablesWSResponse(soap, (const struct __ns1__updateVariablesWSResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__startProcessWS:
		soap_serialize___ns1__startProcessWS(soap, (const struct __ns1__startProcessWS *)ptr);
		break;
	case SOAP_TYPE___ns1__removeProcesses:
		soap_serialize___ns1__removeProcesses(soap, (const struct __ns1__removeProcesses *)ptr);
		break;
	case SOAP_TYPE___ns1__removeProcessesResponse:
		soap_serialize___ns1__removeProcessesResponse(soap, (const struct __ns1__removeProcessesResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpened:
		soap_serialize___ns1__markTaskOpened(soap, (const struct __ns1__markTaskOpened *)ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpenedResponse:
		soap_serialize___ns1__markTaskOpenedResponse(soap, (const struct __ns1__markTaskOpenedResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__getVariablesWS:
		soap_serialize___ns1__getVariablesWS(soap, (const struct __ns1__getVariablesWS *)ptr);
		break;
	case SOAP_TYPE___ns1__getVariable:
		soap_serialize___ns1__getVariable(soap, (const struct __ns1__getVariable *)ptr);
		break;
	case SOAP_TYPE___ns1__getTasks:
		soap_serialize___ns1__getTasks(soap, (const struct __ns1__getTasks *)ptr);
		break;
	case SOAP_TYPE___ns1__getTask:
		soap_serialize___ns1__getTask(soap, (const struct __ns1__getTask *)ptr);
		break;
	case SOAP_TYPE___ns1__getSystemLogsCount:
		soap_serialize___ns1__getSystemLogsCount(soap, (const struct __ns1__getSystemLogsCount *)ptr);
		break;
	case SOAP_TYPE___ns1__getSystemLogs:
		soap_serialize___ns1__getSystemLogs(soap, (const struct __ns1__getSystemLogs *)ptr);
		break;
	case SOAP_TYPE___ns1__getSwimlanes:
		soap_serialize___ns1__getSwimlanes(soap, (const struct __ns1__getSwimlanes *)ptr);
		break;
	case SOAP_TYPE___ns1__getSubprocesses:
		soap_serialize___ns1__getSubprocesses(soap, (const struct __ns1__getSubprocesses *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessesCount:
		soap_serialize___ns1__getProcessesCount(soap, (const struct __ns1__getProcessesCount *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessesByFilter:
		soap_serialize___ns1__getProcessesByFilter(soap, (const struct __ns1__getProcessesByFilter *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcesses:
		soap_serialize___ns1__getProcesses(soap, (const struct __ns1__getProcesses *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessTasks:
		soap_serialize___ns1__getProcessTasks(soap, (const struct __ns1__getProcessTasks *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessLogs:
		soap_serialize___ns1__getProcessLogs(soap, (const struct __ns1__getProcessLogs *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessLogValue:
		soap_serialize___ns1__getProcessLogValue(soap, (const struct __ns1__getProcessLogValue *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessHistoryDiagramElements:
		soap_serialize___ns1__getProcessHistoryDiagramElements(soap, (const struct __ns1__getProcessHistoryDiagramElements *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessHistoryDiagram:
		soap_serialize___ns1__getProcessHistoryDiagram(soap, (const struct __ns1__getProcessHistoryDiagram *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessDiagramElements:
		soap_serialize___ns1__getProcessDiagramElements(soap, (const struct __ns1__getProcessDiagramElements *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessDiagram:
		soap_serialize___ns1__getProcessDiagram(soap, (const struct __ns1__getProcessDiagram *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcess:
		soap_serialize___ns1__getProcess(soap, (const struct __ns1__getProcess *)ptr);
		break;
	case SOAP_TYPE___ns1__getParentProcess:
		soap_serialize___ns1__getParentProcess(soap, (const struct __ns1__getParentProcess *)ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWS:
		soap_serialize___ns1__completeTaskWS(soap, (const struct __ns1__completeTaskWS *)ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWSResponse:
		soap_serialize___ns1__completeTaskWSResponse(soap, (const struct __ns1__completeTaskWSResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__cancelProcess:
		soap_serialize___ns1__cancelProcess(soap, (const struct __ns1__cancelProcess *)ptr);
		break;
	case SOAP_TYPE___ns1__cancelProcessResponse:
		soap_serialize___ns1__cancelProcessResponse(soap, (const struct __ns1__cancelProcessResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__assignTask:
		soap_serialize___ns1__assignTask(soap, (const struct __ns1__assignTask *)ptr);
		break;
	case SOAP_TYPE___ns1__assignTaskResponse:
		soap_serialize___ns1__assignTaskResponse(soap, (const struct __ns1__assignTaskResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__assignSwimlane:
		soap_serialize___ns1__assignSwimlane(soap, (const struct __ns1__assignSwimlane *)ptr);
		break;
	case SOAP_TYPE___ns1__assignSwimlaneResponse:
		soap_serialize___ns1__assignSwimlaneResponse(soap, (const struct __ns1__assignSwimlaneResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByLoginPassword:
		soap_serialize___ns1__authenticateByLoginPassword(soap, (const struct __ns1__authenticateByLoginPassword *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByKerberos:
		soap_serialize___ns1__authenticateByKerberos(soap, (const struct __ns1__authenticateByKerberos *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByCallerPrincipal:
		soap_serialize___ns1__authenticateByCallerPrincipal(soap, (const struct __ns1__authenticateByCallerPrincipal *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateVariablesWSResponse:
		soap_serialize_PointerTons1__updateVariablesWSResponse(soap, (ns1__updateVariablesWSResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateVariablesWS:
		soap_serialize_PointerTons1__updateVariablesWS(soap, (ns1__updateVariablesWS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__startProcessWSResponse:
		soap_serialize_PointerTons1__startProcessWSResponse(soap, (ns1__startProcessWSResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__startProcessWS:
		soap_serialize_PointerTons1__startProcessWS(soap, (ns1__startProcessWS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeProcessesResponse:
		soap_serialize_PointerTons1__removeProcessesResponse(soap, (ns1__removeProcessesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeProcesses:
		soap_serialize_PointerTons1__removeProcesses(soap, (ns1__removeProcesses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__markTaskOpenedResponse:
		soap_serialize_PointerTons1__markTaskOpenedResponse(soap, (ns1__markTaskOpenedResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__markTaskOpened:
		soap_serialize_PointerTons1__markTaskOpened(soap, (ns1__markTaskOpened *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getVariablesWSResponse:
		soap_serialize_PointerTons1__getVariablesWSResponse(soap, (ns1__getVariablesWSResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getVariablesWS:
		soap_serialize_PointerTons1__getVariablesWS(soap, (ns1__getVariablesWS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getVariableResponse:
		soap_serialize_PointerTons1__getVariableResponse(soap, (ns1__getVariableResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getVariable:
		soap_serialize_PointerTons1__getVariable(soap, (ns1__getVariable *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTasksResponse:
		soap_serialize_PointerTons1__getTasksResponse(soap, (ns1__getTasksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTasks:
		soap_serialize_PointerTons1__getTasks(soap, (ns1__getTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTaskResponse:
		soap_serialize_PointerTons1__getTaskResponse(soap, (ns1__getTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTask:
		soap_serialize_PointerTons1__getTask(soap, (ns1__getTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSystemLogsCountResponse:
		soap_serialize_PointerTons1__getSystemLogsCountResponse(soap, (ns1__getSystemLogsCountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSystemLogsCount:
		soap_serialize_PointerTons1__getSystemLogsCount(soap, (ns1__getSystemLogsCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSystemLogsResponse:
		soap_serialize_PointerTons1__getSystemLogsResponse(soap, (ns1__getSystemLogsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSystemLogs:
		soap_serialize_PointerTons1__getSystemLogs(soap, (ns1__getSystemLogs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSwimlanesResponse:
		soap_serialize_PointerTons1__getSwimlanesResponse(soap, (ns1__getSwimlanesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSwimlanes:
		soap_serialize_PointerTons1__getSwimlanes(soap, (ns1__getSwimlanes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSubprocessesResponse:
		soap_serialize_PointerTons1__getSubprocessesResponse(soap, (ns1__getSubprocessesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getSubprocesses:
		soap_serialize_PointerTons1__getSubprocesses(soap, (ns1__getSubprocesses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessesCountResponse:
		soap_serialize_PointerTons1__getProcessesCountResponse(soap, (ns1__getProcessesCountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessesCount:
		soap_serialize_PointerTons1__getProcessesCount(soap, (ns1__getProcessesCount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessesByFilterResponse:
		soap_serialize_PointerTons1__getProcessesByFilterResponse(soap, (ns1__getProcessesByFilterResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessesByFilter:
		soap_serialize_PointerTons1__getProcessesByFilter(soap, (ns1__getProcessesByFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessesResponse:
		soap_serialize_PointerTons1__getProcessesResponse(soap, (ns1__getProcessesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcesses:
		soap_serialize_PointerTons1__getProcesses(soap, (ns1__getProcesses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessTasksResponse:
		soap_serialize_PointerTons1__getProcessTasksResponse(soap, (ns1__getProcessTasksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessTasks:
		soap_serialize_PointerTons1__getProcessTasks(soap, (ns1__getProcessTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessLogsResponse:
		soap_serialize_PointerTons1__getProcessLogsResponse(soap, (ns1__getProcessLogsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessLogs:
		soap_serialize_PointerTons1__getProcessLogs(soap, (ns1__getProcessLogs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessLogValueResponse:
		soap_serialize_PointerTons1__getProcessLogValueResponse(soap, (ns1__getProcessLogValueResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessLogValue:
		soap_serialize_PointerTons1__getProcessLogValue(soap, (ns1__getProcessLogValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElementsResponse:
		soap_serialize_PointerTons1__getProcessHistoryDiagramElementsResponse(soap, (ns1__getProcessHistoryDiagramElementsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElements:
		soap_serialize_PointerTons1__getProcessHistoryDiagramElements(soap, (ns1__getProcessHistoryDiagramElements *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagramResponse:
		soap_serialize_PointerTons1__getProcessHistoryDiagramResponse(soap, (ns1__getProcessHistoryDiagramResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessHistoryDiagram:
		soap_serialize_PointerTons1__getProcessHistoryDiagram(soap, (ns1__getProcessHistoryDiagram *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessDiagramElementsResponse:
		soap_serialize_PointerTons1__getProcessDiagramElementsResponse(soap, (ns1__getProcessDiagramElementsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessDiagramElements:
		soap_serialize_PointerTons1__getProcessDiagramElements(soap, (ns1__getProcessDiagramElements *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessDiagramResponse:
		soap_serialize_PointerTons1__getProcessDiagramResponse(soap, (ns1__getProcessDiagramResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessDiagram:
		soap_serialize_PointerTons1__getProcessDiagram(soap, (ns1__getProcessDiagram *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessResponse:
		soap_serialize_PointerTons1__getProcessResponse(soap, (ns1__getProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcess:
		soap_serialize_PointerTons1__getProcess(soap, (ns1__getProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getParentProcessResponse:
		soap_serialize_PointerTons1__getParentProcessResponse(soap, (ns1__getParentProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getParentProcess:
		soap_serialize_PointerTons1__getParentProcess(soap, (ns1__getParentProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__completeTaskWSResponse:
		soap_serialize_PointerTons1__completeTaskWSResponse(soap, (ns1__completeTaskWSResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__completeTaskWS:
		soap_serialize_PointerTons1__completeTaskWS(soap, (ns1__completeTaskWS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cancelProcessResponse:
		soap_serialize_PointerTons1__cancelProcessResponse(soap, (ns1__cancelProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cancelProcess:
		soap_serialize_PointerTons1__cancelProcess(soap, (ns1__cancelProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignTaskResponse:
		soap_serialize_PointerTons1__assignTaskResponse(soap, (ns1__assignTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignTask:
		soap_serialize_PointerTons1__assignTask(soap, (ns1__assignTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignSwimlaneResponse:
		soap_serialize_PointerTons1__assignSwimlaneResponse(soap, (ns1__assignSwimlaneResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignSwimlane:
		soap_serialize_PointerTons1__assignSwimlane(soap, (ns1__assignSwimlane *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse:
		soap_serialize_PointerTons1__authenticateByLoginPasswordResponse(soap, (ns1__authenticateByLoginPasswordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByLoginPassword:
		soap_serialize_PointerTons1__authenticateByLoginPassword(soap, (ns1__authenticateByLoginPassword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByKerberosResponse:
		soap_serialize_PointerTons1__authenticateByKerberosResponse(soap, (ns1__authenticateByKerberosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByKerberos:
		soap_serialize_PointerTons1__authenticateByKerberos(soap, (ns1__authenticateByKerberos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse:
		soap_serialize_PointerTons1__authenticateByCallerPrincipalResponse(soap, (ns1__authenticateByCallerPrincipalResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal:
		soap_serialize_PointerTons1__authenticateByCallerPrincipal(soap, (ns1__authenticateByCallerPrincipal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowstring:
		soap_serialize_PointerTowstring(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__delegation:
		soap_serialize_PointerTons1__delegation(soap, (ns1__delegation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__swimlaneDefinition:
		soap_serialize_PointerTons1__swimlaneDefinition(soap, (ns1__swimlaneDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__wfSwimlane:
		soap_serialize_PointerToPointerTons1__wfSwimlane(soap, (ns1__wfSwimlane **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wfSwimlane:
		soap_serialize_PointerTons1__wfSwimlane(soap, (ns1__wfSwimlane *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__variable:
		soap_serialize_PointerToPointerTons1__variable(soap, (ns1__variable **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__variable:
		soap_serialize_PointerTons1__variable(soap, (ns1__variable *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__systemLog:
		soap_serialize_PointerToPointerTons1__systemLog(soap, (ns1__systemLog **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__systemLog:
		soap_serialize_PointerTons1__systemLog(soap, (ns1__systemLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__severity:
		soap_serialize_PointerTons1__severity(soap, (enum ns1__severity *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__processLog:
		soap_serialize_PointerToPointerTons1__processLog(soap, (ns1__processLog **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__processLog:
		soap_serialize_PointerTons1__processLog(soap, (ns1__processLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__processLogs:
		soap_serialize_PointerTons1__processLogs(soap, (ns1__processLogs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__processLogFilter:
		soap_serialize_PointerTons1__processLogFilter(soap, (ns1__processLogFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__wfTask:
		soap_serialize_PointerToPointerTons1__wfTask(soap, (ns1__wfTask **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__wfProcess:
		soap_serialize_PointerToPointerTons1__wfProcess(soap, (ns1__wfProcess **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__processFilter:
		soap_serialize_PointerTons1__processFilter(soap, (ns1__processFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__classPresentationType:
		soap_serialize_PointerTons1__classPresentationType(soap, (enum ns1__classPresentationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__batchPresentation:
		soap_serialize_PointerTons1__batchPresentation(soap, (ns1__batchPresentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__variableDefinition:
		soap_serialize_PointerToPointerTons1__variableDefinition(soap, (ns1__variableDefinition **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__variableDefinition:
		soap_serialize_PointerTons1__variableDefinition(soap, (ns1__variableDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__variableDefinition_userTypes_entry:
		soap_serialize_PointerTo_ns1__variableDefinition_userTypes_entry(soap, (_ns1__variableDefinition_userTypes_entry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__variableUserType:
		soap_serialize_PointerTons1__variableUserType(soap, (ns1__variableUserType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__wfVariableStub:
		soap_serialize_PointerTons2__wfVariableStub(soap, (ns2__wfVariableStub *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wfProcess:
		soap_serialize_PointerTons1__wfProcess(soap, (ns1__wfProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wfExecutor:
		soap_serialize_PointerTons1__wfExecutor(soap, (ns1__wfExecutor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wfTask:
		soap_serialize_PointerTons1__wfTask(soap, (ns1__wfTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__nodeType:
		soap_serialize_PointerTons1__nodeType(soap, (enum ns1__nodeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__graphElementPresentation:
		soap_serialize_PointerToPointerTons1__graphElementPresentation(soap, (ns1__graphElementPresentation **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__graphElementPresentation:
		soap_serialize_PointerTons1__graphElementPresentation(soap, (ns1__graphElementPresentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__actor:
		soap_serialize_PointerTons1__actor(soap, (ns1__actor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__user:
		soap_serialize_PointerTons1__user(soap, (ns1__user *const*)ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary_:
		return (void*)soap_instantiate_xsd__base64Binary_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__nodeType_:
		return (void*)soap_instantiate_ns1__nodeType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__classPresentationType_:
		return (void*)soap_instantiate_ns1__classPresentationType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__severity_:
		return (void*)soap_instantiate_ns1__severity_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		return (void*)soap_instantiate_ns1__authenticateByLoginPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		return (void*)soap_instantiate_ns1__authenticateByLoginPasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__user:
		return (void*)soap_instantiate_ns1__user(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__identifiable:
		return (void*)soap_instantiate_ns1__identifiable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		return (void*)soap_instantiate_ns1__authenticateByCallerPrincipal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		return (void*)soap_instantiate_ns1__authenticateByCallerPrincipalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByKerberos:
		return (void*)soap_instantiate_ns1__authenticateByKerberos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		return (void*)soap_instantiate_ns1__authenticateByKerberosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElements:
		return (void*)soap_instantiate_ns1__getProcessHistoryDiagramElements(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse:
		return (void*)soap_instantiate_ns1__getProcessHistoryDiagramElementsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__graphElementPresentation:
		return (void*)soap_instantiate_ns1__graphElementPresentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTask:
		return (void*)soap_instantiate_ns1__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTaskResponse:
		return (void*)soap_instantiate_ns1__getTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wfTask:
		return (void*)soap_instantiate_ns1__wfTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcess:
		return (void*)soap_instantiate_ns1__getProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessResponse:
		return (void*)soap_instantiate_ns1__getProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVariable:
		return (void*)soap_instantiate_ns1__getVariable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVariableResponse:
		return (void*)soap_instantiate_ns1__getVariableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__variableDefinition_userTypes_entry:
		return (void*)soap_instantiate__ns1__variableDefinition_userTypes_entry(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__variableDefinition_userTypes:
		return (void*)soap_instantiate__ns1__variableDefinition_userTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__variableDefinition:
		return (void*)soap_instantiate_ns1__variableDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__variableUserType:
		return (void*)soap_instantiate_ns1__variableUserType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessesCount:
		return (void*)soap_instantiate_ns1__getProcessesCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__batchPresentation:
		return (void*)soap_instantiate_ns1__batchPresentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessesCountResponse:
		return (void*)soap_instantiate_ns1__getProcessesCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessesByFilter:
		return (void*)soap_instantiate_ns1__getProcessesByFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__processFilter:
		return (void*)soap_instantiate_ns1__processFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessesByFilterResponse:
		return (void*)soap_instantiate_ns1__getProcessesByFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getParentProcess:
		return (void*)soap_instantiate_ns1__getParentProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getParentProcessResponse:
		return (void*)soap_instantiate_ns1__getParentProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSubprocesses:
		return (void*)soap_instantiate_ns1__getSubprocesses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSubprocessesResponse:
		return (void*)soap_instantiate_ns1__getSubprocessesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelProcess:
		return (void*)soap_instantiate_ns1__cancelProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelProcessResponse:
		return (void*)soap_instantiate_ns1__cancelProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessTasks:
		return (void*)soap_instantiate_ns1__getProcessTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		return (void*)soap_instantiate_ns1__getProcessTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessDiagram:
		return (void*)soap_instantiate_ns1__getProcessDiagram(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessDiagramResponse:
		return (void*)soap_instantiate_ns1__getProcessDiagramResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessHistoryDiagram:
		return (void*)soap_instantiate_ns1__getProcessHistoryDiagram(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessHistoryDiagramResponse:
		return (void*)soap_instantiate_ns1__getProcessHistoryDiagramResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessDiagramElements:
		return (void*)soap_instantiate_ns1__getProcessDiagramElements(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessDiagramElementsResponse:
		return (void*)soap_instantiate_ns1__getProcessDiagramElementsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignSwimlane:
		return (void*)soap_instantiate_ns1__assignSwimlane(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignSwimlaneResponse:
		return (void*)soap_instantiate_ns1__assignSwimlaneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessLogs:
		return (void*)soap_instantiate_ns1__getProcessLogs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__processLogFilter:
		return (void*)soap_instantiate_ns1__processLogFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessLogsResponse:
		return (void*)soap_instantiate_ns1__getProcessLogsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__processLogs:
		return (void*)soap_instantiate_ns1__processLogs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__processLog:
		return (void*)soap_instantiate_ns1__processLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessLogValue:
		return (void*)soap_instantiate_ns1__getProcessLogValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessLogValueResponse:
		return (void*)soap_instantiate_ns1__getProcessLogValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__markTaskOpened:
		return (void*)soap_instantiate_ns1__markTaskOpened(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		return (void*)soap_instantiate_ns1__markTaskOpenedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeProcesses:
		return (void*)soap_instantiate_ns1__removeProcesses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeProcessesResponse:
		return (void*)soap_instantiate_ns1__removeProcessesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSystemLogs:
		return (void*)soap_instantiate_ns1__getSystemLogs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSystemLogsResponse:
		return (void*)soap_instantiate_ns1__getSystemLogsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__systemLog:
		return (void*)soap_instantiate_ns1__systemLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSystemLogsCount:
		return (void*)soap_instantiate_ns1__getSystemLogsCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSystemLogsCountResponse:
		return (void*)soap_instantiate_ns1__getSystemLogsCountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVariablesWS:
		return (void*)soap_instantiate_ns1__getVariablesWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVariablesWSResponse:
		return (void*)soap_instantiate_ns1__getVariablesWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__variable:
		return (void*)soap_instantiate_ns1__variable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__startProcessWS:
		return (void*)soap_instantiate_ns1__startProcessWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__startProcessWSResponse:
		return (void*)soap_instantiate_ns1__startProcessWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__completeTaskWS:
		return (void*)soap_instantiate_ns1__completeTaskWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		return (void*)soap_instantiate_ns1__completeTaskWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateVariablesWS:
		return (void*)soap_instantiate_ns1__updateVariablesWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateVariablesWSResponse:
		return (void*)soap_instantiate_ns1__updateVariablesWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSwimlanes:
		return (void*)soap_instantiate_ns1__getSwimlanes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSwimlanesResponse:
		return (void*)soap_instantiate_ns1__getSwimlanesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wfSwimlane:
		return (void*)soap_instantiate_ns1__wfSwimlane(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__graphElement:
		return (void*)soap_instantiate_ns1__graphElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__delegation:
		return (void*)soap_instantiate_ns1__delegation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcesses:
		return (void*)soap_instantiate_ns1__getProcesses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessesResponse:
		return (void*)soap_instantiate_ns1__getProcessesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTasks:
		return (void*)soap_instantiate_ns1__getTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTasksResponse:
		return (void*)soap_instantiate_ns1__getTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignTask:
		return (void*)soap_instantiate_ns1__assignTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignTaskResponse:
		return (void*)soap_instantiate_ns1__assignTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__wfVariableStub:
		return (void*)soap_instantiate_ns2__wfVariableStub(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__identifiableBase:
		return (void*)soap_instantiate_ns1__identifiableBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__processDefinitionDeleteLog:
		return (void*)soap_instantiate_ns1__processDefinitionDeleteLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__processDeleteLog:
		return (void*)soap_instantiate_ns1__processDeleteLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__swimlaneDefinition:
		return (void*)soap_instantiate_ns1__swimlaneDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__executor:
		return (void*)soap_instantiate_ns1__executor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wfProcess:
		return (void*)soap_instantiate_ns1__wfProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__actor:
		return (void*)soap_instantiate_ns1__actor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wfExecutor:
		return (void*)soap_instantiate_ns1__wfExecutor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateByCallerPrincipal:
		return (void*)soap_instantiate___ns1__authenticateByCallerPrincipal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateByKerberos:
		return (void*)soap_instantiate___ns1__authenticateByKerberos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateByLoginPassword:
		return (void*)soap_instantiate___ns1__authenticateByLoginPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__assignSwimlaneResponse:
		return (void*)soap_instantiate___ns1__assignSwimlaneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__assignSwimlane:
		return (void*)soap_instantiate___ns1__assignSwimlane(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__assignTaskResponse:
		return (void*)soap_instantiate___ns1__assignTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__assignTask:
		return (void*)soap_instantiate___ns1__assignTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cancelProcessResponse:
		return (void*)soap_instantiate___ns1__cancelProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cancelProcess:
		return (void*)soap_instantiate___ns1__cancelProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__completeTaskWSResponse:
		return (void*)soap_instantiate___ns1__completeTaskWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__completeTaskWS:
		return (void*)soap_instantiate___ns1__completeTaskWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getParentProcess:
		return (void*)soap_instantiate___ns1__getParentProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcess:
		return (void*)soap_instantiate___ns1__getProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessDiagram:
		return (void*)soap_instantiate___ns1__getProcessDiagram(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessDiagramElements:
		return (void*)soap_instantiate___ns1__getProcessDiagramElements(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessHistoryDiagram:
		return (void*)soap_instantiate___ns1__getProcessHistoryDiagram(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessHistoryDiagramElements:
		return (void*)soap_instantiate___ns1__getProcessHistoryDiagramElements(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessLogValue:
		return (void*)soap_instantiate___ns1__getProcessLogValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessLogs:
		return (void*)soap_instantiate___ns1__getProcessLogs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessTasks:
		return (void*)soap_instantiate___ns1__getProcessTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcesses:
		return (void*)soap_instantiate___ns1__getProcesses(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessesByFilter:
		return (void*)soap_instantiate___ns1__getProcessesByFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessesCount:
		return (void*)soap_instantiate___ns1__getProcessesCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSubprocesses:
		return (void*)soap_instantiate___ns1__getSubprocesses(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSwimlanes:
		return (void*)soap_instantiate___ns1__getSwimlanes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSystemLogs:
		return (void*)soap_instantiate___ns1__getSystemLogs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getSystemLogsCount:
		return (void*)soap_instantiate___ns1__getSystemLogsCount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTask:
		return (void*)soap_instantiate___ns1__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTasks:
		return (void*)soap_instantiate___ns1__getTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getVariable:
		return (void*)soap_instantiate___ns1__getVariable(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getVariablesWS:
		return (void*)soap_instantiate___ns1__getVariablesWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__markTaskOpenedResponse:
		return (void*)soap_instantiate___ns1__markTaskOpenedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__markTaskOpened:
		return (void*)soap_instantiate___ns1__markTaskOpened(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeProcessesResponse:
		return (void*)soap_instantiate___ns1__removeProcessesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeProcesses:
		return (void*)soap_instantiate___ns1__removeProcesses(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__startProcessWS:
		return (void*)soap_instantiate___ns1__startProcessWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateVariablesWSResponse:
		return (void*)soap_instantiate___ns1__updateVariablesWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateVariablesWS:
		return (void*)soap_instantiate___ns1__updateVariablesWS(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((xsd__anyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__anyType*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			SOAP_DELETE((xsd__boolean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__boolean*)p->ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			SOAP_DELETE((xsd__dateTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__dateTime*)p->ptr);
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			SOAP_DELETE((xsd__int*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__int*)p->ptr);
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			SOAP_DELETE((xsd__long*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__long*)p->ptr);
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE((xsd__string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__nodeType_:
		if (p->size < 0)
			SOAP_DELETE((ns1__nodeType_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__nodeType_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__classPresentationType_:
		if (p->size < 0)
			SOAP_DELETE((ns1__classPresentationType_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__classPresentationType_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__severity_:
		if (p->size < 0)
			SOAP_DELETE((ns1__severity_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__severity_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByLoginPassword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByLoginPassword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByLoginPasswordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByLoginPasswordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__user:
		if (p->size < 0)
			SOAP_DELETE((ns1__user*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__user*)p->ptr);
		break;
	case SOAP_TYPE_ns1__identifiable:
		if (p->size < 0)
			SOAP_DELETE((ns1__identifiable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__identifiable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByCallerPrincipal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByCallerPrincipal*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByCallerPrincipalResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByCallerPrincipalResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberos:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByKerberos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByKerberos*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByKerberosResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByKerberosResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElements:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessHistoryDiagramElements*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessHistoryDiagramElements*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessHistoryDiagramElementsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessHistoryDiagramElementsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__graphElementPresentation:
		if (p->size < 0)
			SOAP_DELETE((ns1__graphElementPresentation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__graphElementPresentation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wfTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__wfTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wfTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcess:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcess*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getVariable:
		if (p->size < 0)
			SOAP_DELETE((ns1__getVariable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getVariable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getVariableResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getVariableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getVariableResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__variableDefinition_userTypes_entry:
		if (p->size < 0)
			SOAP_DELETE((_ns1__variableDefinition_userTypes_entry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__variableDefinition_userTypes_entry*)p->ptr);
		break;
	case SOAP_TYPE__ns1__variableDefinition_userTypes:
		if (p->size < 0)
			SOAP_DELETE((_ns1__variableDefinition_userTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__variableDefinition_userTypes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__variableDefinition:
		if (p->size < 0)
			SOAP_DELETE((ns1__variableDefinition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__variableDefinition*)p->ptr);
		break;
	case SOAP_TYPE_ns1__variableUserType:
		if (p->size < 0)
			SOAP_DELETE((ns1__variableUserType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__variableUserType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessesCount:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessesCount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessesCount*)p->ptr);
		break;
	case SOAP_TYPE_ns1__batchPresentation:
		if (p->size < 0)
			SOAP_DELETE((ns1__batchPresentation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__batchPresentation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessesCountResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessesCountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessesCountResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessesByFilter:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessesByFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessesByFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__processFilter:
		if (p->size < 0)
			SOAP_DELETE((ns1__processFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__processFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessesByFilterResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessesByFilterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessesByFilterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getParentProcess:
		if (p->size < 0)
			SOAP_DELETE((ns1__getParentProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getParentProcess*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getParentProcessResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getParentProcessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getParentProcessResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSubprocesses:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSubprocesses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSubprocesses*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSubprocessesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSubprocessesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSubprocessesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelProcess:
		if (p->size < 0)
			SOAP_DELETE((ns1__cancelProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cancelProcess*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelProcessResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__cancelProcessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cancelProcessResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessTasks:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessTasks*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessTasksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessTasksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessDiagram:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessDiagram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessDiagram*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessDiagramResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessDiagramResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessDiagramResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagram:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessHistoryDiagram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessHistoryDiagram*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessHistoryDiagramResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessHistoryDiagramResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessHistoryDiagramResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessDiagramElements:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessDiagramElements*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessDiagramElements*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessDiagramElementsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessDiagramElementsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessDiagramElementsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__assignSwimlane:
		if (p->size < 0)
			SOAP_DELETE((ns1__assignSwimlane*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__assignSwimlane*)p->ptr);
		break;
	case SOAP_TYPE_ns1__assignSwimlaneResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__assignSwimlaneResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__assignSwimlaneResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessLogs:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessLogs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessLogs*)p->ptr);
		break;
	case SOAP_TYPE_ns1__processLogFilter:
		if (p->size < 0)
			SOAP_DELETE((ns1__processLogFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__processLogFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessLogsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessLogsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessLogsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__processLogs:
		if (p->size < 0)
			SOAP_DELETE((ns1__processLogs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__processLogs*)p->ptr);
		break;
	case SOAP_TYPE_ns1__processLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__processLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__processLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessLogValue:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessLogValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessLogValue*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessLogValueResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessLogValueResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessLogValueResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__markTaskOpened:
		if (p->size < 0)
			SOAP_DELETE((ns1__markTaskOpened*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__markTaskOpened*)p->ptr);
		break;
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__markTaskOpenedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__markTaskOpenedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeProcesses:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeProcesses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeProcesses*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeProcessesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__removeProcessesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__removeProcessesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSystemLogs:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSystemLogs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSystemLogs*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSystemLogsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSystemLogsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSystemLogsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__systemLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__systemLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__systemLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSystemLogsCount:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSystemLogsCount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSystemLogsCount*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSystemLogsCountResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSystemLogsCountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSystemLogsCountResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getVariablesWS:
		if (p->size < 0)
			SOAP_DELETE((ns1__getVariablesWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getVariablesWS*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getVariablesWSResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getVariablesWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getVariablesWSResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__variable:
		if (p->size < 0)
			SOAP_DELETE((ns1__variable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__variable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__startProcessWS:
		if (p->size < 0)
			SOAP_DELETE((ns1__startProcessWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__startProcessWS*)p->ptr);
		break;
	case SOAP_TYPE_ns1__startProcessWSResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__startProcessWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__startProcessWSResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__completeTaskWS:
		if (p->size < 0)
			SOAP_DELETE((ns1__completeTaskWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__completeTaskWS*)p->ptr);
		break;
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__completeTaskWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__completeTaskWSResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateVariablesWS:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateVariablesWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateVariablesWS*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateVariablesWSResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateVariablesWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateVariablesWSResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSwimlanes:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSwimlanes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSwimlanes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSwimlanesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getSwimlanesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getSwimlanesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wfSwimlane:
		if (p->size < 0)
			SOAP_DELETE((ns1__wfSwimlane*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wfSwimlane*)p->ptr);
		break;
	case SOAP_TYPE_ns1__graphElement:
		if (p->size < 0)
			SOAP_DELETE((ns1__graphElement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__graphElement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__delegation:
		if (p->size < 0)
			SOAP_DELETE((ns1__delegation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__delegation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcesses:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcesses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcesses*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTasks:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTasks*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTasksResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTasksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTasksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__assignTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__assignTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__assignTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__assignTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__assignTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__assignTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__wfVariableStub:
		if (p->size < 0)
			SOAP_DELETE((ns2__wfVariableStub*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__wfVariableStub*)p->ptr);
		break;
	case SOAP_TYPE_ns1__identifiableBase:
		if (p->size < 0)
			SOAP_DELETE((ns1__identifiableBase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__identifiableBase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__processDefinitionDeleteLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__processDefinitionDeleteLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__processDefinitionDeleteLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__processDeleteLog:
		if (p->size < 0)
			SOAP_DELETE((ns1__processDeleteLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__processDeleteLog*)p->ptr);
		break;
	case SOAP_TYPE_ns1__swimlaneDefinition:
		if (p->size < 0)
			SOAP_DELETE((ns1__swimlaneDefinition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__swimlaneDefinition*)p->ptr);
		break;
	case SOAP_TYPE_ns1__executor:
		if (p->size < 0)
			SOAP_DELETE((ns1__executor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__executor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wfProcess:
		if (p->size < 0)
			SOAP_DELETE((ns1__wfProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wfProcess*)p->ptr);
		break;
	case SOAP_TYPE_ns1__actor:
		if (p->size < 0)
			SOAP_DELETE((ns1__actor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__actor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wfExecutor:
		if (p->size < 0)
			SOAP_DELETE((ns1__wfExecutor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wfExecutor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByCallerPrincipal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateByCallerPrincipal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateByCallerPrincipal*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByKerberos:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateByKerberos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateByKerberos*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByLoginPassword:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateByLoginPassword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateByLoginPassword*)p->ptr);
		break;
	case SOAP_TYPE___ns1__assignSwimlaneResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__assignSwimlaneResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__assignSwimlaneResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__assignSwimlane:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__assignSwimlane*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__assignSwimlane*)p->ptr);
		break;
	case SOAP_TYPE___ns1__assignTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__assignTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__assignTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__assignTask:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__assignTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__assignTask*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cancelProcessResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cancelProcessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cancelProcessResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__cancelProcess:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__cancelProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__cancelProcess*)p->ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWSResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__completeTaskWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__completeTaskWSResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWS:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__completeTaskWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__completeTaskWS*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getParentProcess:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getParentProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getParentProcess*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcess:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcess*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessDiagram:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessDiagram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessDiagram*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessDiagramElements:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessDiagramElements*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessDiagramElements*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessHistoryDiagram:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessHistoryDiagram*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessHistoryDiagram*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessHistoryDiagramElements:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessHistoryDiagramElements*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessHistoryDiagramElements*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessLogValue:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessLogValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessLogValue*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessLogs:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessLogs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessLogs*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessTasks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessTasks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcesses:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcesses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcesses*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessesByFilter:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessesByFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessesByFilter*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessesCount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessesCount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessesCount*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSubprocesses:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSubprocesses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSubprocesses*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSwimlanes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSwimlanes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSwimlanes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSystemLogs:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSystemLogs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSystemLogs*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getSystemLogsCount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getSystemLogsCount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getSystemLogsCount*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTask:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTask*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTasks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTasks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getVariable:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getVariable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getVariable*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getVariablesWS:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getVariablesWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getVariablesWS*)p->ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpenedResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__markTaskOpenedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__markTaskOpenedResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpened:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__markTaskOpened*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__markTaskOpened*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeProcessesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeProcessesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeProcessesResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__removeProcesses:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__removeProcesses*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__removeProcesses*)p->ptr);
		break;
	case SOAP_TYPE___ns1__startProcessWS:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__startProcessWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__startProcessWS*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateVariablesWSResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateVariablesWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateVariablesWSResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateVariablesWS:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateVariablesWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateVariablesWS*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__severity(struct soap *soap, enum ns1__severity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__severity
	*a = SOAP_DEFAULT_ns1__severity;
#else
	*a = (enum ns1__severity)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__severity[] =
{	{ (long)ns1__severity__DEBUG, "DEBUG" },
	{ (long)ns1__severity__ERROR, "ERROR" },
	{ (long)ns1__severity__INFO, "INFO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__severity2s(struct soap *soap, enum ns1__severity n)
{	const char *s = soap_code_str(soap_codes_ns1__severity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__severity(struct soap *soap, const char *tag, int id, const enum ns1__severity *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__severity), type) || soap_send(soap, soap_ns1__severity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__severity(struct soap *soap, const char *s, enum ns1__severity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__severity, s);
	if (map)
		*a = (enum ns1__severity)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__severity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__severity * SOAP_FMAC4 soap_in_ns1__severity(struct soap *soap, const char *tag, enum ns1__severity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__severity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__severity, sizeof(enum ns1__severity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__severity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__severity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__severity, 0, sizeof(enum ns1__severity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__severity(struct soap *soap, const enum ns1__severity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__severity);
	if (soap_out_ns1__severity(soap, tag?tag:"ns1:severity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__severity * SOAP_FMAC4 soap_get_ns1__severity(struct soap *soap, enum ns1__severity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__severity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__classPresentationType
	*a = SOAP_DEFAULT_ns1__classPresentationType;
#else
	*a = (enum ns1__classPresentationType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__classPresentationType[] =
{	{ (long)ns1__classPresentationType__NONE, "NONE" },
	{ (long)ns1__classPresentationType__SYSTEM_USCORELOG, "SYSTEM_LOG" },
	{ (long)ns1__classPresentationType__EXECUTOR, "EXECUTOR" },
	{ (long)ns1__classPresentationType__ACTOR, "ACTOR" },
	{ (long)ns1__classPresentationType__GROUP, "GROUP" },
	{ (long)ns1__classPresentationType__RELATION, "RELATION" },
	{ (long)ns1__classPresentationType__RELATIONPAIR, "RELATIONPAIR" },
	{ (long)ns1__classPresentationType__DEFINITION, "DEFINITION" },
	{ (long)ns1__classPresentationType__PROCESS, "PROCESS" },
	{ (long)ns1__classPresentationType__TASK, "TASK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__classPresentationType2s(struct soap *soap, enum ns1__classPresentationType n)
{	const char *s = soap_code_str(soap_codes_ns1__classPresentationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__classPresentationType(struct soap *soap, const char *tag, int id, const enum ns1__classPresentationType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__classPresentationType), type) || soap_send(soap, soap_ns1__classPresentationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__classPresentationType(struct soap *soap, const char *s, enum ns1__classPresentationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__classPresentationType, s);
	if (map)
		*a = (enum ns1__classPresentationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__classPresentationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__classPresentationType * SOAP_FMAC4 soap_in_ns1__classPresentationType(struct soap *soap, const char *tag, enum ns1__classPresentationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__classPresentationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__classPresentationType, sizeof(enum ns1__classPresentationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__classPresentationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__classPresentationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__classPresentationType, 0, sizeof(enum ns1__classPresentationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__classPresentationType(struct soap *soap, const enum ns1__classPresentationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__classPresentationType);
	if (soap_out_ns1__classPresentationType(soap, tag?tag:"ns1:classPresentationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__classPresentationType * SOAP_FMAC4 soap_get_ns1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__classPresentationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__nodeType(struct soap *soap, enum ns1__nodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__nodeType
	*a = SOAP_DEFAULT_ns1__nodeType;
#else
	*a = (enum ns1__nodeType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__nodeType[] =
{	{ (long)ns1__nodeType__START_USCOREEVENT, "START_EVENT" },
	{ (long)ns1__nodeType__ACTION_USCORENODE, "ACTION_NODE" },
	{ (long)ns1__nodeType__END_USCOREPROCESS, "END_PROCESS" },
	{ (long)ns1__nodeType__WAIT_USCORESTATE, "WAIT_STATE" },
	{ (long)ns1__nodeType__TASK_USCORESTATE, "TASK_STATE" },
	{ (long)ns1__nodeType__FORK, "FORK" },
	{ (long)ns1__nodeType__JOIN, "JOIN" },
	{ (long)ns1__nodeType__DECISION, "DECISION" },
	{ (long)ns1__nodeType__SUBPROCESS, "SUBPROCESS" },
	{ (long)ns1__nodeType__MULTI_USCORESUBPROCESS, "MULTI_SUBPROCESS" },
	{ (long)ns1__nodeType__SEND_USCOREMESSAGE, "SEND_MESSAGE" },
	{ (long)ns1__nodeType__RECEIVE_USCOREMESSAGE, "RECEIVE_MESSAGE" },
	{ (long)ns1__nodeType__END_USCORETOKEN, "END_TOKEN" },
	{ (long)ns1__nodeType__MULTI_USCORETASK_USCORESTATE, "MULTI_TASK_STATE" },
	{ (long)ns1__nodeType__MERGE, "MERGE" },
	{ (long)ns1__nodeType__EXCLUSIVE_USCOREGATEWAY, "EXCLUSIVE_GATEWAY" },
	{ (long)ns1__nodeType__PARALLEL_USCOREGATEWAY, "PARALLEL_GATEWAY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__nodeType2s(struct soap *soap, enum ns1__nodeType n)
{	const char *s = soap_code_str(soap_codes_ns1__nodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__nodeType(struct soap *soap, const char *tag, int id, const enum ns1__nodeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__nodeType), type) || soap_send(soap, soap_ns1__nodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__nodeType(struct soap *soap, const char *s, enum ns1__nodeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__nodeType, s);
	if (map)
		*a = (enum ns1__nodeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__nodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__nodeType * SOAP_FMAC4 soap_in_ns1__nodeType(struct soap *soap, const char *tag, enum ns1__nodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__nodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__nodeType, sizeof(enum ns1__nodeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__nodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__nodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__nodeType, 0, sizeof(enum ns1__nodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__nodeType(struct soap *soap, const enum ns1__nodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__nodeType);
	if (soap_out_ns1__nodeType(soap, tag?tag:"ns1:nodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__nodeType * SOAP_FMAC4 soap_get_ns1__nodeType(struct soap *soap, enum ns1__nodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__nodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__variableDefinition_userTypes_entry::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__variableDefinition_userTypes_entry::key = NULL;
	this->_ns1__variableDefinition_userTypes_entry::value = NULL;
}

void _ns1__variableDefinition_userTypes_entry::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->_ns1__variableDefinition_userTypes_entry::key);
	soap_serialize_PointerTons1__variableUserType(soap, &this->_ns1__variableDefinition_userTypes_entry::value);
#endif
}

int _ns1__variableDefinition_userTypes_entry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__variableDefinition_userTypes_entry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__variableDefinition_userTypes_entry(struct soap *soap, const char *tag, int id, const _ns1__variableDefinition_userTypes_entry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__variableDefinition_userTypes_entry), type))
		return soap->error;
	if (soap_out_wstring(soap, "key", -1, &(a->_ns1__variableDefinition_userTypes_entry::key), ""))
		return soap->error;
	if (soap_out_PointerTons1__variableUserType(soap, "value", -1, &(a->_ns1__variableDefinition_userTypes_entry::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__variableDefinition_userTypes_entry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__variableDefinition_userTypes_entry(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__variableDefinition_userTypes_entry * SOAP_FMAC4 soap_in__ns1__variableDefinition_userTypes_entry(struct soap *soap, const char *tag, _ns1__variableDefinition_userTypes_entry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__variableDefinition_userTypes_entry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__variableDefinition_userTypes_entry, sizeof(_ns1__variableDefinition_userTypes_entry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__variableDefinition_userTypes_entry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__variableDefinition_userTypes_entry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_key1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "key", &(a->_ns1__variableDefinition_userTypes_entry::key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__variableUserType(soap, "value", &(a->_ns1__variableDefinition_userTypes_entry::value), "ns1:variableUserType"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__variableDefinition_userTypes_entry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__variableDefinition_userTypes_entry, 0, sizeof(_ns1__variableDefinition_userTypes_entry), 0, soap_copy__ns1__variableDefinition_userTypes_entry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__variableDefinition_userTypes_entry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__variableDefinition_userTypes_entry);
	if (this->soap_out(soap, tag?tag:"ns1:variableDefinition-userTypes-entry", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__variableDefinition_userTypes_entry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__variableDefinition_userTypes_entry(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__variableDefinition_userTypes_entry * SOAP_FMAC4 soap_get__ns1__variableDefinition_userTypes_entry(struct soap *soap, _ns1__variableDefinition_userTypes_entry *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__variableDefinition_userTypes_entry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__variableDefinition_userTypes_entry * SOAP_FMAC2 soap_instantiate__ns1__variableDefinition_userTypes_entry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__variableDefinition_userTypes_entry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__variableDefinition_userTypes_entry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__variableDefinition_userTypes_entry);
		if (size)
			*size = sizeof(_ns1__variableDefinition_userTypes_entry);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__variableDefinition_userTypes_entry, n);
		if (size)
			*size = n * sizeof(_ns1__variableDefinition_userTypes_entry);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__variableDefinition_userTypes_entry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__variableDefinition_userTypes_entry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__variableDefinition_userTypes_entry %p -> %p\n", q, p));
	*(_ns1__variableDefinition_userTypes_entry*)p = *(_ns1__variableDefinition_userTypes_entry*)q;
}

void _ns1__variableDefinition_userTypes::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__variableDefinition_userTypes::__sizeentry = 0;
	this->_ns1__variableDefinition_userTypes::entry = NULL;
}

void _ns1__variableDefinition_userTypes::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__variableDefinition_userTypes::entry)
	{	int i;
		for (i = 0; i < this->_ns1__variableDefinition_userTypes::__sizeentry; i++)
		{
			soap_embedded(soap, this->_ns1__variableDefinition_userTypes::entry + i, SOAP_TYPE__ns1__variableDefinition_userTypes_entry);
			this->_ns1__variableDefinition_userTypes::entry[i].soap_serialize(soap);
		}
	}
#endif
}

int _ns1__variableDefinition_userTypes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__variableDefinition_userTypes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__variableDefinition_userTypes(struct soap *soap, const char *tag, int id, const _ns1__variableDefinition_userTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__variableDefinition_userTypes), type))
		return soap->error;
	if (a->_ns1__variableDefinition_userTypes::entry)
	{	int i;
		for (i = 0; i < a->_ns1__variableDefinition_userTypes::__sizeentry; i++)
			if (a->_ns1__variableDefinition_userTypes::entry[i].soap_out(soap, "entry", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__variableDefinition_userTypes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__variableDefinition_userTypes(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__variableDefinition_userTypes * SOAP_FMAC4 soap_in__ns1__variableDefinition_userTypes(struct soap *soap, const char *tag, _ns1__variableDefinition_userTypes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__variableDefinition_userTypes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__variableDefinition_userTypes, sizeof(_ns1__variableDefinition_userTypes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__variableDefinition_userTypes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__variableDefinition_userTypes *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_entry1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "entry", 1, NULL))
			{	if (a->_ns1__variableDefinition_userTypes::entry == NULL)
				{	if (soap_blist_entry1 == NULL)
						soap_blist_entry1 = soap_new_block(soap);
					a->_ns1__variableDefinition_userTypes::entry = (_ns1__variableDefinition_userTypes_entry *)soap_push_block(soap, soap_blist_entry1, sizeof(_ns1__variableDefinition_userTypes_entry));
					if (a->_ns1__variableDefinition_userTypes::entry == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->_ns1__variableDefinition_userTypes::entry, _ns1__variableDefinition_userTypes_entry);
					a->_ns1__variableDefinition_userTypes::entry->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__ns1__variableDefinition_userTypes_entry(soap, "entry", a->_ns1__variableDefinition_userTypes::entry, ""))
				{	a->_ns1__variableDefinition_userTypes::__sizeentry++;
					a->_ns1__variableDefinition_userTypes::entry = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__variableDefinition_userTypes::entry)
			soap_pop_block(soap, soap_blist_entry1);
		if (a->_ns1__variableDefinition_userTypes::__sizeentry)
			a->_ns1__variableDefinition_userTypes::entry = (_ns1__variableDefinition_userTypes_entry *)soap_save_block(soap, soap_blist_entry1, NULL, 1);
		else
		{	a->_ns1__variableDefinition_userTypes::entry = NULL;
			if (soap_blist_entry1)
				soap_end_block(soap, soap_blist_entry1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__variableDefinition_userTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__variableDefinition_userTypes, 0, sizeof(_ns1__variableDefinition_userTypes), 0, soap_copy__ns1__variableDefinition_userTypes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__variableDefinition_userTypes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__variableDefinition_userTypes);
	if (this->soap_out(soap, tag?tag:"ns1:variableDefinition-userTypes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__variableDefinition_userTypes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__variableDefinition_userTypes(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__variableDefinition_userTypes * SOAP_FMAC4 soap_get__ns1__variableDefinition_userTypes(struct soap *soap, _ns1__variableDefinition_userTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__variableDefinition_userTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__variableDefinition_userTypes * SOAP_FMAC2 soap_instantiate__ns1__variableDefinition_userTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__variableDefinition_userTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__variableDefinition_userTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__variableDefinition_userTypes);
		if (size)
			*size = sizeof(_ns1__variableDefinition_userTypes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__variableDefinition_userTypes, n);
		if (size)
			*size = n * sizeof(_ns1__variableDefinition_userTypes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__variableDefinition_userTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__variableDefinition_userTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__variableDefinition_userTypes %p -> %p\n", q, p));
	*(_ns1__variableDefinition_userTypes*)p = *(_ns1__variableDefinition_userTypes*)q;
}

void ns1__severity_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns1__severity(soap, &this->ns1__severity_::__item);
}

void ns1__severity_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__severity_::__item, SOAP_TYPE_ns1__severity);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__severity_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__severity_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__severity_(struct soap *soap, const char *tag, int id, const ns1__severity_ *a, const char *type)
{
	return soap_out_ns1__severity(soap, tag, id, &(a->ns1__severity_::__item), "ns1:severity");
}

void *ns1__severity_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__severity_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__severity_ * SOAP_FMAC4 soap_in_ns1__severity_(struct soap *soap, const char *tag, ns1__severity_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__severity_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__severity_, sizeof(ns1__severity_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__severity_)
			return (ns1__severity_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__severity(soap, tag, &(a->ns1__severity_::__item), "ns1:severity"))
		return NULL;
	return a;
}

int ns1__severity_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__severity_);
	if (this->soap_out(soap, tag?tag:"ns1:severity", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__severity_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__severity_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__severity_ * SOAP_FMAC4 soap_get_ns1__severity_(struct soap *soap, ns1__severity_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__severity_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__severity_ * SOAP_FMAC2 soap_instantiate_ns1__severity_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__severity_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__severity_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__severity_);
		if (size)
			*size = sizeof(ns1__severity_);
		((ns1__severity_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__severity_, n);
		if (size)
			*size = n * sizeof(ns1__severity_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__severity_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__severity_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__severity_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__severity_ %p -> %p\n", q, p));
	*(ns1__severity_*)p = *(ns1__severity_*)q;
}

void ns1__classPresentationType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns1__classPresentationType(soap, &this->ns1__classPresentationType_::__item);
}

void ns1__classPresentationType_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__classPresentationType_::__item, SOAP_TYPE_ns1__classPresentationType);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__classPresentationType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__classPresentationType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__classPresentationType_(struct soap *soap, const char *tag, int id, const ns1__classPresentationType_ *a, const char *type)
{
	return soap_out_ns1__classPresentationType(soap, tag, id, &(a->ns1__classPresentationType_::__item), "ns1:classPresentationType");
}

void *ns1__classPresentationType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__classPresentationType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__classPresentationType_ * SOAP_FMAC4 soap_in_ns1__classPresentationType_(struct soap *soap, const char *tag, ns1__classPresentationType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__classPresentationType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__classPresentationType_, sizeof(ns1__classPresentationType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__classPresentationType_)
			return (ns1__classPresentationType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__classPresentationType(soap, tag, &(a->ns1__classPresentationType_::__item), "ns1:classPresentationType"))
		return NULL;
	return a;
}

int ns1__classPresentationType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__classPresentationType_);
	if (this->soap_out(soap, tag?tag:"ns1:classPresentationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__classPresentationType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__classPresentationType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__classPresentationType_ * SOAP_FMAC4 soap_get_ns1__classPresentationType_(struct soap *soap, ns1__classPresentationType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__classPresentationType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__classPresentationType_ * SOAP_FMAC2 soap_instantiate_ns1__classPresentationType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__classPresentationType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__classPresentationType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__classPresentationType_);
		if (size)
			*size = sizeof(ns1__classPresentationType_);
		((ns1__classPresentationType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__classPresentationType_, n);
		if (size)
			*size = n * sizeof(ns1__classPresentationType_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__classPresentationType_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__classPresentationType_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__classPresentationType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__classPresentationType_ %p -> %p\n", q, p));
	*(ns1__classPresentationType_*)p = *(ns1__classPresentationType_*)q;
}

void ns1__nodeType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns1__nodeType(soap, &this->ns1__nodeType_::__item);
}

void ns1__nodeType_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__nodeType_::__item, SOAP_TYPE_ns1__nodeType);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__nodeType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__nodeType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__nodeType_(struct soap *soap, const char *tag, int id, const ns1__nodeType_ *a, const char *type)
{
	return soap_out_ns1__nodeType(soap, tag, id, &(a->ns1__nodeType_::__item), "ns1:nodeType");
}

void *ns1__nodeType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__nodeType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__nodeType_ * SOAP_FMAC4 soap_in_ns1__nodeType_(struct soap *soap, const char *tag, ns1__nodeType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__nodeType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__nodeType_, sizeof(ns1__nodeType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__nodeType_)
			return (ns1__nodeType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__nodeType(soap, tag, &(a->ns1__nodeType_::__item), "ns1:nodeType"))
		return NULL;
	return a;
}

int ns1__nodeType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__nodeType_);
	if (this->soap_out(soap, tag?tag:"ns1:nodeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__nodeType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__nodeType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__nodeType_ * SOAP_FMAC4 soap_get_ns1__nodeType_(struct soap *soap, ns1__nodeType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__nodeType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__nodeType_ * SOAP_FMAC2 soap_instantiate_ns1__nodeType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__nodeType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__nodeType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__nodeType_);
		if (size)
			*size = sizeof(ns1__nodeType_);
		((ns1__nodeType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__nodeType_, n);
		if (size)
			*size = n * sizeof(ns1__nodeType_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__nodeType_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__nodeType_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__nodeType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__nodeType_ %p -> %p\n", q, p));
	*(ns1__nodeType_*)p = *(ns1__nodeType_*)q;
}

void ns2__wfVariableStub::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__wfVariableStub::definition = NULL;
	this->ns2__wfVariableStub::value = NULL;
}

void ns2__wfVariableStub::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__variableDefinition(soap, &this->ns2__wfVariableStub::definition);
	soap_serialize_PointerToxsd__anyType(soap, &this->ns2__wfVariableStub::value);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__wfVariableStub::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__wfVariableStub(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__wfVariableStub(struct soap *soap, const char *tag, int id, const ns2__wfVariableStub *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__wfVariableStub), "ns2:wfVariableStub"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__variableDefinition(soap, "definition", -1, &(a->ns2__wfVariableStub::definition), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "value", -1, &(a->ns2__wfVariableStub::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__wfVariableStub::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__wfVariableStub(soap, tag, this, type);
}

SOAP_FMAC3 ns2__wfVariableStub * SOAP_FMAC4 soap_in_ns2__wfVariableStub(struct soap *soap, const char *tag, ns2__wfVariableStub *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__wfVariableStub *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__wfVariableStub, sizeof(ns2__wfVariableStub), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__wfVariableStub)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__wfVariableStub *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_definition1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_definition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__variableDefinition(soap, "definition", &(a->ns2__wfVariableStub::definition), "ns1:variableDefinition"))
				{	soap_flag_definition1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "value", &(a->ns2__wfVariableStub::value), "xsd:anyType"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__wfVariableStub *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__wfVariableStub, 0, sizeof(ns2__wfVariableStub), 0, soap_copy_ns2__wfVariableStub);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__wfVariableStub::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__wfVariableStub);
	if (this->soap_out(soap, tag?tag:"ns2:wfVariableStub", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__wfVariableStub::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__wfVariableStub(soap, this, tag, type);
}

SOAP_FMAC3 ns2__wfVariableStub * SOAP_FMAC4 soap_get_ns2__wfVariableStub(struct soap *soap, ns2__wfVariableStub *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__wfVariableStub(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__wfVariableStub * SOAP_FMAC2 soap_instantiate_ns2__wfVariableStub(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__wfVariableStub(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__wfVariableStub, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__wfVariableStub);
		if (size)
			*size = sizeof(ns2__wfVariableStub);
		((ns2__wfVariableStub*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__wfVariableStub, n);
		if (size)
			*size = n * sizeof(ns2__wfVariableStub);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__wfVariableStub*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__wfVariableStub*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__wfVariableStub(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__wfVariableStub %p -> %p\n", q, p));
	*(ns2__wfVariableStub*)p = *(ns2__wfVariableStub*)q;
}

void ns1__assignTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__assignTaskResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__assignTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignTaskResponse(struct soap *soap, const char *tag, int id, const ns1__assignTaskResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:assignTaskResponse");
}

void *ns1__assignTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignTaskResponse * SOAP_FMAC4 soap_in_ns1__assignTaskResponse(struct soap *soap, const char *tag, ns1__assignTaskResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__assignTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignTaskResponse, sizeof(ns1__assignTaskResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignTaskResponse)
			return (ns1__assignTaskResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__assignTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignTaskResponse);
	if (this->soap_out(soap, tag?tag:"ns1:assignTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__assignTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignTaskResponse * SOAP_FMAC4 soap_get_ns1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__assignTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__assignTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__assignTaskResponse);
		if (size)
			*size = sizeof(ns1__assignTaskResponse);
		((ns1__assignTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTaskResponse, n);
		if (size)
			*size = n * sizeof(ns1__assignTaskResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__assignTaskResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__assignTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignTaskResponse %p -> %p\n", q, p));
	*(ns1__assignTaskResponse*)p = *(ns1__assignTaskResponse*)q;
}

void ns1__assignTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__assignTask::user = NULL;
	this->ns1__assignTask::taskId = NULL;
	this->ns1__assignTask::previousOwner = NULL;
	this->ns1__assignTask::newExecutor = NULL;
}

void ns1__assignTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__assignTask::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__assignTask::taskId);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__assignTask::previousOwner);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__assignTask::newExecutor);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__assignTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignTask(struct soap *soap, const char *tag, int id, const ns1__assignTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__assignTask), "ns1:assignTask"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__assignTask::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__assignTask::taskId), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "previousOwner", -1, &(a->ns1__assignTask::previousOwner), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "newExecutor", -1, &(a->ns1__assignTask::newExecutor), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__assignTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignTask * SOAP_FMAC4 soap_in_ns1__assignTask(struct soap *soap, const char *tag, ns1__assignTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__assignTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignTask, sizeof(ns1__assignTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__assignTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	size_t soap_flag_previousOwner1 = 1;
	size_t soap_flag_newExecutor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__assignTask::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__assignTask::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag_previousOwner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "previousOwner", &(a->ns1__assignTask::previousOwner), "ns1:wfExecutor"))
				{	soap_flag_previousOwner1--;
					continue;
				}
			if (soap_flag_newExecutor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "newExecutor", &(a->ns1__assignTask::newExecutor), "ns1:wfExecutor"))
				{	soap_flag_newExecutor1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__assignTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__assignTask, 0, sizeof(ns1__assignTask), 0, soap_copy_ns1__assignTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__assignTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignTask);
	if (this->soap_out(soap, tag?tag:"ns1:assignTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__assignTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignTask * SOAP_FMAC4 soap_get_ns1__assignTask(struct soap *soap, ns1__assignTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__assignTask * SOAP_FMAC2 soap_instantiate_ns1__assignTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__assignTask);
		if (size)
			*size = sizeof(ns1__assignTask);
		((ns1__assignTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTask, n);
		if (size)
			*size = n * sizeof(ns1__assignTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__assignTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__assignTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignTask %p -> %p\n", q, p));
	*(ns1__assignTask*)p = *(ns1__assignTask*)q;
}

void ns1__getTasksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTasksResponse::__sizeresult = 0;
	this->ns1__getTasksResponse::result = NULL;
}

void ns1__getTasksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getTasksResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getTasksResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfTask(soap, this->ns1__getTasksResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTasksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTasksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTasksResponse(struct soap *soap, const char *tag, int id, const ns1__getTasksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTasksResponse), "ns1:getTasksResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getTasksResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getTasksResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfTask(soap, "result", -1, a->ns1__getTasksResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getTasksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTasksResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTasksResponse * SOAP_FMAC4 soap_in_ns1__getTasksResponse(struct soap *soap, const char *tag, ns1__getTasksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTasksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTasksResponse, sizeof(ns1__getTasksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTasksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTasksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getTasksResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getTasksResponse::result = (ns1__wfTask **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfTask *));
					if (a->ns1__getTasksResponse::result == NULL)
						return NULL;
					*a->ns1__getTasksResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfTask(soap, "result", a->ns1__getTasksResponse::result, "ns1:wfTask"))
				{	a->ns1__getTasksResponse::__sizeresult++;
					a->ns1__getTasksResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getTasksResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getTasksResponse::__sizeresult)
			a->ns1__getTasksResponse::result = (ns1__wfTask **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getTasksResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTasksResponse, 0, sizeof(ns1__getTasksResponse), 0, soap_copy_ns1__getTasksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTasksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTasksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTasksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTasksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTasksResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTasksResponse * SOAP_FMAC4 soap_get_ns1__getTasksResponse(struct soap *soap, ns1__getTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTasksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTasksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTasksResponse);
		if (size)
			*size = sizeof(ns1__getTasksResponse);
		((ns1__getTasksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasksResponse, n);
		if (size)
			*size = n * sizeof(ns1__getTasksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTasksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTasksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTasksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTasksResponse %p -> %p\n", q, p));
	*(ns1__getTasksResponse*)p = *(ns1__getTasksResponse*)q;
}

void ns1__getTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTasks::user = NULL;
	this->ns1__getTasks::batchPresentation = NULL;
}

void ns1__getTasks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getTasks::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__getTasks::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTasks(struct soap *soap, const char *tag, int id, const ns1__getTasks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTasks), "ns1:getTasks"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getTasks::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__getTasks::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTasks * SOAP_FMAC4 soap_in_ns1__getTasks(struct soap *soap, const char *tag, ns1__getTasks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTasks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTasks, sizeof(ns1__getTasks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTasks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTasks *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getTasks::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__getTasks::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTasks, 0, sizeof(ns1__getTasks), 0, soap_copy_ns1__getTasks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTasks);
	if (this->soap_out(soap, tag?tag:"ns1:getTasks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTasks * SOAP_FMAC4 soap_get_ns1__getTasks(struct soap *soap, ns1__getTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTasks * SOAP_FMAC2 soap_instantiate_ns1__getTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTasks);
		if (size)
			*size = sizeof(ns1__getTasks);
		((ns1__getTasks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasks, n);
		if (size)
			*size = n * sizeof(ns1__getTasks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTasks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTasks %p -> %p\n", q, p));
	*(ns1__getTasks*)p = *(ns1__getTasks*)q;
}

void ns1__getProcessesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessesResponse::__sizeresult = 0;
	this->ns1__getProcessesResponse::result = NULL;
}

void ns1__getProcessesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getProcessesResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getProcessesResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfProcess(soap, this->ns1__getProcessesResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessesResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessesResponse), "ns1:getProcessesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getProcessesResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getProcessesResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfProcess(soap, "result", -1, a->ns1__getProcessesResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessesResponse * SOAP_FMAC4 soap_in_ns1__getProcessesResponse(struct soap *soap, const char *tag, ns1__getProcessesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessesResponse, sizeof(ns1__getProcessesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getProcessesResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getProcessesResponse::result = (ns1__wfProcess **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfProcess *));
					if (a->ns1__getProcessesResponse::result == NULL)
						return NULL;
					*a->ns1__getProcessesResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfProcess(soap, "result", a->ns1__getProcessesResponse::result, "ns1:wfProcess"))
				{	a->ns1__getProcessesResponse::__sizeresult++;
					a->ns1__getProcessesResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getProcessesResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getProcessesResponse::__sizeresult)
			a->ns1__getProcessesResponse::result = (ns1__wfProcess **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getProcessesResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessesResponse, 0, sizeof(ns1__getProcessesResponse), 0, soap_copy_ns1__getProcessesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessesResponse * SOAP_FMAC4 soap_get_ns1__getProcessesResponse(struct soap *soap, ns1__getProcessesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessesResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesResponse);
		if (size)
			*size = sizeof(ns1__getProcessesResponse);
		((ns1__getProcessesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessesResponse %p -> %p\n", q, p));
	*(ns1__getProcessesResponse*)p = *(ns1__getProcessesResponse*)q;
}

void ns1__getProcesses::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcesses::user = NULL;
	this->ns1__getProcesses::batchPresentation = NULL;
}

void ns1__getProcesses::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcesses::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__getProcesses::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcesses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcesses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcesses(struct soap *soap, const char *tag, int id, const ns1__getProcesses *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcesses), "ns1:getProcesses"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcesses::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__getProcesses::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcesses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcesses(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcesses * SOAP_FMAC4 soap_in_ns1__getProcesses(struct soap *soap, const char *tag, ns1__getProcesses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcesses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcesses, sizeof(ns1__getProcesses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcesses)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcesses *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcesses::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__getProcesses::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcesses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcesses, 0, sizeof(ns1__getProcesses), 0, soap_copy_ns1__getProcesses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcesses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcesses);
	if (this->soap_out(soap, tag?tag:"ns1:getProcesses", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcesses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcesses(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcesses * SOAP_FMAC4 soap_get_ns1__getProcesses(struct soap *soap, ns1__getProcesses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcesses * SOAP_FMAC2 soap_instantiate_ns1__getProcesses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcesses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcesses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcesses);
		if (size)
			*size = sizeof(ns1__getProcesses);
		((ns1__getProcesses*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcesses, n);
		if (size)
			*size = n * sizeof(ns1__getProcesses);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcesses*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcesses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcesses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcesses %p -> %p\n", q, p));
	*(ns1__getProcesses*)p = *(ns1__getProcesses*)q;
}

void ns1__delegation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__delegation::className = NULL;
	this->ns1__delegation::configuration = NULL;
}

void ns1__delegation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__delegation::className);
	soap_serialize_wstring(soap, &this->ns1__delegation::configuration);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__delegation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__delegation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__delegation(struct soap *soap, const char *tag, int id, const ns1__delegation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__delegation), "ns1:delegation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "className", -1, &(a->ns1__delegation::className), ""))
		return soap->error;
	if (soap_out_wstring(soap, "configuration", -1, &(a->ns1__delegation::configuration), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__delegation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__delegation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__delegation * SOAP_FMAC4 soap_in_ns1__delegation(struct soap *soap, const char *tag, ns1__delegation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__delegation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__delegation, sizeof(ns1__delegation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__delegation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__delegation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_className1 = 1;
	size_t soap_flag_configuration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_className1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "className", &(a->ns1__delegation::className), "xsd:string"))
				{	soap_flag_className1--;
					continue;
				}
			if (soap_flag_configuration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "configuration", &(a->ns1__delegation::configuration), "xsd:string"))
				{	soap_flag_configuration1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__delegation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__delegation, 0, sizeof(ns1__delegation), 0, soap_copy_ns1__delegation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__delegation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__delegation);
	if (this->soap_out(soap, tag?tag:"ns1:delegation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__delegation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__delegation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__delegation * SOAP_FMAC4 soap_get_ns1__delegation(struct soap *soap, ns1__delegation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__delegation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__delegation * SOAP_FMAC2 soap_instantiate_ns1__delegation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__delegation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__delegation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__delegation);
		if (size)
			*size = sizeof(ns1__delegation);
		((ns1__delegation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__delegation, n);
		if (size)
			*size = n * sizeof(ns1__delegation);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__delegation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__delegation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__delegation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__delegation %p -> %p\n", q, p));
	*(ns1__delegation*)p = *(ns1__delegation*)q;
}

void ns1__graphElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__graphElement::nodeId = NULL;
	this->ns1__graphElement::name = NULL;
	this->ns1__graphElement::description = NULL;
	this->ns1__graphElement::__sizegraphConstraints = 0;
	this->ns1__graphElement::graphConstraints = NULL;
}

void ns1__graphElement::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__graphElement::nodeId);
	soap_serialize_wstring(soap, &this->ns1__graphElement::name);
	soap_serialize_wstring(soap, &this->ns1__graphElement::description);
	if (this->ns1__graphElement::graphConstraints)
	{	int i;
		for (i = 0; i < this->ns1__graphElement::__sizegraphConstraints; i++)
		{
			soap_embedded(soap, this->ns1__graphElement::graphConstraints + i, SOAP_TYPE_int);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__graphElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__graphElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__graphElement(struct soap *soap, const char *tag, int id, const ns1__graphElement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__graphElement), "ns1:graphElement"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "nodeId", -1, &(a->ns1__graphElement::nodeId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__graphElement::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__graphElement::description), ""))
		return soap->error;
	if (a->ns1__graphElement::graphConstraints)
	{	int i;
		for (i = 0; i < a->ns1__graphElement::__sizegraphConstraints; i++)
			if (soap_out_int(soap, "graphConstraints", -1, a->ns1__graphElement::graphConstraints + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__graphElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__graphElement(soap, tag, this, type);
}

SOAP_FMAC3 ns1__graphElement * SOAP_FMAC4 soap_in_ns1__graphElement(struct soap *soap, const char *tag, ns1__graphElement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__graphElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__graphElement, sizeof(ns1__graphElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__graphElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__graphElement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_nodeId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	struct soap_blist *soap_blist_graphConstraints1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_nodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "nodeId", &(a->ns1__graphElement::nodeId), "xsd:string"))
				{	soap_flag_nodeId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__graphElement::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__graphElement::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "graphConstraints", 1, NULL))
			{	if (a->ns1__graphElement::graphConstraints == NULL)
				{	if (soap_blist_graphConstraints1 == NULL)
						soap_blist_graphConstraints1 = soap_new_block(soap);
					a->ns1__graphElement::graphConstraints = (int *)soap_push_block(soap, soap_blist_graphConstraints1, sizeof(int));
					if (a->ns1__graphElement::graphConstraints == NULL)
						return NULL;
					soap_default_int(soap, a->ns1__graphElement::graphConstraints);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "graphConstraints", a->ns1__graphElement::graphConstraints, "xsd:int"))
				{	a->ns1__graphElement::__sizegraphConstraints++;
					a->ns1__graphElement::graphConstraints = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__graphElement::graphConstraints)
			soap_pop_block(soap, soap_blist_graphConstraints1);
		if (a->ns1__graphElement::__sizegraphConstraints)
			a->ns1__graphElement::graphConstraints = (int *)soap_save_block(soap, soap_blist_graphConstraints1, NULL, 1);
		else
		{	a->ns1__graphElement::graphConstraints = NULL;
			if (soap_blist_graphConstraints1)
				soap_end_block(soap, soap_blist_graphConstraints1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__graphElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__graphElement, 0, sizeof(ns1__graphElement), 0, soap_copy_ns1__graphElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__graphElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__graphElement);
	if (this->soap_out(soap, tag?tag:"ns1:graphElement", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__graphElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__graphElement(soap, this, tag, type);
}

SOAP_FMAC3 ns1__graphElement * SOAP_FMAC4 soap_get_ns1__graphElement(struct soap *soap, ns1__graphElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__graphElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__graphElement * SOAP_FMAC2 soap_instantiate_ns1__graphElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__graphElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__graphElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:swimlaneDefinition"))
	{	cp->type = SOAP_TYPE_ns1__swimlaneDefinition;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__swimlaneDefinition);
			if (size)
				*size = sizeof(ns1__swimlaneDefinition);
			((ns1__swimlaneDefinition*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__swimlaneDefinition, n);
			if (size)
				*size = n * sizeof(ns1__swimlaneDefinition);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__swimlaneDefinition*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__swimlaneDefinition*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__graphElement);
		if (size)
			*size = sizeof(ns1__graphElement);
		((ns1__graphElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__graphElement, n);
		if (size)
			*size = n * sizeof(ns1__graphElement);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__graphElement*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__graphElement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__graphElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__graphElement %p -> %p\n", q, p));
	*(ns1__graphElement*)p = *(ns1__graphElement*)q;
}

void ns1__swimlaneDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__graphElement::soap_default(soap);
	this->ns1__swimlaneDefinition::delegation = NULL;
	this->ns1__swimlaneDefinition::orgFunctionLabel = NULL;
	this->ns1__swimlaneDefinition::__sizeflowNodeIds = 0;
	this->ns1__swimlaneDefinition::flowNodeIds = NULL;
	this->ns1__swimlaneDefinition::scriptingName = NULL;
}

void ns1__swimlaneDefinition::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__delegation(soap, &this->ns1__swimlaneDefinition::delegation);
	soap_serialize_wstring(soap, &this->ns1__swimlaneDefinition::orgFunctionLabel);
	if (this->ns1__swimlaneDefinition::flowNodeIds)
	{	int i;
		for (i = 0; i < this->ns1__swimlaneDefinition::__sizeflowNodeIds; i++)
		{
			soap_serialize_wstring(soap, this->ns1__swimlaneDefinition::flowNodeIds + i);
		}
	}
	soap_serialize_wstring(soap, &this->ns1__swimlaneDefinition::scriptingName);
	this->ns1__graphElement::soap_serialize(soap);
#endif
}

int ns1__swimlaneDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__swimlaneDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__swimlaneDefinition(struct soap *soap, const char *tag, int id, const ns1__swimlaneDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__swimlaneDefinition), "ns1:swimlaneDefinition"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "nodeId", -1, &(a->ns1__graphElement::nodeId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__graphElement::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__graphElement::description), ""))
		return soap->error;
	if (a->ns1__graphElement::graphConstraints)
	{	int i;
		for (i = 0; i < a->ns1__graphElement::__sizegraphConstraints; i++)
			if (soap_out_int(soap, "graphConstraints", -1, a->ns1__graphElement::graphConstraints + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons1__delegation(soap, "delegation", -1, &(a->ns1__swimlaneDefinition::delegation), ""))
		return soap->error;
	if (soap_out_wstring(soap, "orgFunctionLabel", -1, &(a->ns1__swimlaneDefinition::orgFunctionLabel), ""))
		return soap->error;
	if (a->ns1__swimlaneDefinition::flowNodeIds)
	{	int i;
		for (i = 0; i < a->ns1__swimlaneDefinition::__sizeflowNodeIds; i++)
			if (soap_out_wstring(soap, "flowNodeIds", -1, a->ns1__swimlaneDefinition::flowNodeIds + i, ""))
				return soap->error;
	}
	if (soap_out_wstring(soap, "scriptingName", -1, &(a->ns1__swimlaneDefinition::scriptingName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__swimlaneDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__swimlaneDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ns1__swimlaneDefinition * SOAP_FMAC4 soap_in_ns1__swimlaneDefinition(struct soap *soap, const char *tag, ns1__swimlaneDefinition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__swimlaneDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__swimlaneDefinition, sizeof(ns1__swimlaneDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__swimlaneDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__swimlaneDefinition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_nodeId2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_description2 = 1;
	struct soap_blist *soap_blist_graphConstraints2 = NULL;
	size_t soap_flag_delegation1 = 1;
	size_t soap_flag_orgFunctionLabel1 = 1;
	struct soap_blist *soap_blist_flowNodeIds1 = NULL;
	size_t soap_flag_scriptingName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_nodeId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "nodeId", &(a->ns1__graphElement::nodeId), "xsd:string"))
				{	soap_flag_nodeId2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__graphElement::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__graphElement::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "graphConstraints", 1, NULL))
			{	if (a->ns1__graphElement::graphConstraints == NULL)
				{	if (soap_blist_graphConstraints2 == NULL)
						soap_blist_graphConstraints2 = soap_new_block(soap);
					a->ns1__graphElement::graphConstraints = (int *)soap_push_block(soap, soap_blist_graphConstraints2, sizeof(int));
					if (a->ns1__graphElement::graphConstraints == NULL)
						return NULL;
					soap_default_int(soap, a->ns1__graphElement::graphConstraints);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "graphConstraints", a->ns1__graphElement::graphConstraints, "xsd:int"))
				{	a->ns1__graphElement::__sizegraphConstraints++;
					a->ns1__graphElement::graphConstraints = NULL;
					continue;
				}
			}
			if (soap_flag_delegation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__delegation(soap, "delegation", &(a->ns1__swimlaneDefinition::delegation), "ns1:delegation"))
				{	soap_flag_delegation1--;
					continue;
				}
			if (soap_flag_orgFunctionLabel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "orgFunctionLabel", &(a->ns1__swimlaneDefinition::orgFunctionLabel), "xsd:string"))
				{	soap_flag_orgFunctionLabel1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "flowNodeIds", 1, NULL))
			{	if (a->ns1__swimlaneDefinition::flowNodeIds == NULL)
				{	if (soap_blist_flowNodeIds1 == NULL)
						soap_blist_flowNodeIds1 = soap_new_block(soap);
					a->ns1__swimlaneDefinition::flowNodeIds = (wchar_t **)soap_push_block(soap, soap_blist_flowNodeIds1, sizeof(wchar_t *));
					if (a->ns1__swimlaneDefinition::flowNodeIds == NULL)
						return NULL;
					*a->ns1__swimlaneDefinition::flowNodeIds = NULL;
				}
				soap_revert(soap);
				if (soap_in_wstring(soap, "flowNodeIds", a->ns1__swimlaneDefinition::flowNodeIds, "xsd:string"))
				{	a->ns1__swimlaneDefinition::__sizeflowNodeIds++;
					a->ns1__swimlaneDefinition::flowNodeIds = NULL;
					continue;
				}
			}
			if (soap_flag_scriptingName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "scriptingName", &(a->ns1__swimlaneDefinition::scriptingName), "xsd:string"))
				{	soap_flag_scriptingName1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__graphElement::graphConstraints)
			soap_pop_block(soap, soap_blist_graphConstraints2);
		if (a->ns1__graphElement::__sizegraphConstraints)
			a->ns1__graphElement::graphConstraints = (int *)soap_save_block(soap, soap_blist_graphConstraints2, NULL, 1);
		else
		{	a->ns1__graphElement::graphConstraints = NULL;
			if (soap_blist_graphConstraints2)
				soap_end_block(soap, soap_blist_graphConstraints2);
		}
		if (a->ns1__swimlaneDefinition::flowNodeIds)
			soap_pop_block(soap, soap_blist_flowNodeIds1);
		if (a->ns1__swimlaneDefinition::__sizeflowNodeIds)
			a->ns1__swimlaneDefinition::flowNodeIds = (wchar_t **)soap_save_block(soap, soap_blist_flowNodeIds1, NULL, 1);
		else
		{	a->ns1__swimlaneDefinition::flowNodeIds = NULL;
			if (soap_blist_flowNodeIds1)
				soap_end_block(soap, soap_blist_flowNodeIds1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__swimlaneDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__swimlaneDefinition, 0, sizeof(ns1__swimlaneDefinition), 0, soap_copy_ns1__swimlaneDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__swimlaneDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__swimlaneDefinition);
	if (this->soap_out(soap, tag?tag:"ns1:swimlaneDefinition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__swimlaneDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__swimlaneDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ns1__swimlaneDefinition * SOAP_FMAC4 soap_get_ns1__swimlaneDefinition(struct soap *soap, ns1__swimlaneDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__swimlaneDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__swimlaneDefinition * SOAP_FMAC2 soap_instantiate_ns1__swimlaneDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__swimlaneDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__swimlaneDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__swimlaneDefinition);
		if (size)
			*size = sizeof(ns1__swimlaneDefinition);
		((ns1__swimlaneDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__swimlaneDefinition, n);
		if (size)
			*size = n * sizeof(ns1__swimlaneDefinition);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__swimlaneDefinition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__swimlaneDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__swimlaneDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__swimlaneDefinition %p -> %p\n", q, p));
	*(ns1__swimlaneDefinition*)p = *(ns1__swimlaneDefinition*)q;
}

void ns1__wfSwimlane::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__wfSwimlane::definition = NULL;
	this->ns1__wfSwimlane::executor = NULL;
}

void ns1__wfSwimlane::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__swimlaneDefinition(soap, &this->ns1__wfSwimlane::definition);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__wfSwimlane::executor);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__wfSwimlane::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wfSwimlane(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wfSwimlane(struct soap *soap, const char *tag, int id, const ns1__wfSwimlane *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wfSwimlane), "ns1:wfSwimlane"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__swimlaneDefinition(soap, "definition", -1, &(a->ns1__wfSwimlane::definition), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "executor", -1, &(a->ns1__wfSwimlane::executor), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__wfSwimlane::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wfSwimlane(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wfSwimlane * SOAP_FMAC4 soap_in_ns1__wfSwimlane(struct soap *soap, const char *tag, ns1__wfSwimlane *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wfSwimlane *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wfSwimlane, sizeof(ns1__wfSwimlane), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wfSwimlane)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wfSwimlane *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_definition1 = 1;
	size_t soap_flag_executor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_definition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__swimlaneDefinition(soap, "definition", &(a->ns1__wfSwimlane::definition), "ns1:swimlaneDefinition"))
				{	soap_flag_definition1--;
					continue;
				}
			if (soap_flag_executor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "executor", &(a->ns1__wfSwimlane::executor), "ns1:wfExecutor"))
				{	soap_flag_executor1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wfSwimlane *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wfSwimlane, 0, sizeof(ns1__wfSwimlane), 0, soap_copy_ns1__wfSwimlane);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wfSwimlane::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__wfSwimlane);
	if (this->soap_out(soap, tag?tag:"ns1:wfSwimlane", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wfSwimlane::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wfSwimlane(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wfSwimlane * SOAP_FMAC4 soap_get_ns1__wfSwimlane(struct soap *soap, ns1__wfSwimlane *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wfSwimlane(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wfSwimlane * SOAP_FMAC2 soap_instantiate_ns1__wfSwimlane(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wfSwimlane(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wfSwimlane, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wfSwimlane);
		if (size)
			*size = sizeof(ns1__wfSwimlane);
		((ns1__wfSwimlane*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfSwimlane, n);
		if (size)
			*size = n * sizeof(ns1__wfSwimlane);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wfSwimlane*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wfSwimlane*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wfSwimlane(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wfSwimlane %p -> %p\n", q, p));
	*(ns1__wfSwimlane*)p = *(ns1__wfSwimlane*)q;
}

void ns1__getSwimlanesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getSwimlanesResponse::__sizeresult = 0;
	this->ns1__getSwimlanesResponse::result = NULL;
}

void ns1__getSwimlanesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getSwimlanesResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getSwimlanesResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfSwimlane(soap, this->ns1__getSwimlanesResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSwimlanesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSwimlanesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSwimlanesResponse(struct soap *soap, const char *tag, int id, const ns1__getSwimlanesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSwimlanesResponse), "ns1:getSwimlanesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getSwimlanesResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getSwimlanesResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfSwimlane(soap, "result", -1, a->ns1__getSwimlanesResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getSwimlanesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSwimlanesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSwimlanesResponse * SOAP_FMAC4 soap_in_ns1__getSwimlanesResponse(struct soap *soap, const char *tag, ns1__getSwimlanesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSwimlanesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSwimlanesResponse, sizeof(ns1__getSwimlanesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSwimlanesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSwimlanesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getSwimlanesResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getSwimlanesResponse::result = (ns1__wfSwimlane **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfSwimlane *));
					if (a->ns1__getSwimlanesResponse::result == NULL)
						return NULL;
					*a->ns1__getSwimlanesResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfSwimlane(soap, "result", a->ns1__getSwimlanesResponse::result, "ns1:wfSwimlane"))
				{	a->ns1__getSwimlanesResponse::__sizeresult++;
					a->ns1__getSwimlanesResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getSwimlanesResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getSwimlanesResponse::__sizeresult)
			a->ns1__getSwimlanesResponse::result = (ns1__wfSwimlane **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getSwimlanesResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSwimlanesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSwimlanesResponse, 0, sizeof(ns1__getSwimlanesResponse), 0, soap_copy_ns1__getSwimlanesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSwimlanesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSwimlanesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSwimlanesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSwimlanesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSwimlanesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSwimlanesResponse * SOAP_FMAC4 soap_get_ns1__getSwimlanesResponse(struct soap *soap, ns1__getSwimlanesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSwimlanesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSwimlanesResponse * SOAP_FMAC2 soap_instantiate_ns1__getSwimlanesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSwimlanesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSwimlanesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSwimlanesResponse);
		if (size)
			*size = sizeof(ns1__getSwimlanesResponse);
		((ns1__getSwimlanesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSwimlanesResponse, n);
		if (size)
			*size = n * sizeof(ns1__getSwimlanesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSwimlanesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSwimlanesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSwimlanesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSwimlanesResponse %p -> %p\n", q, p));
	*(ns1__getSwimlanesResponse*)p = *(ns1__getSwimlanesResponse*)q;
}

void ns1__getSwimlanes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getSwimlanes::user = NULL;
	this->ns1__getSwimlanes::processId = NULL;
}

void ns1__getSwimlanes::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getSwimlanes::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getSwimlanes::processId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSwimlanes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSwimlanes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSwimlanes(struct soap *soap, const char *tag, int id, const ns1__getSwimlanes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSwimlanes), "ns1:getSwimlanes"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getSwimlanes::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getSwimlanes::processId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getSwimlanes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSwimlanes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSwimlanes * SOAP_FMAC4 soap_in_ns1__getSwimlanes(struct soap *soap, const char *tag, ns1__getSwimlanes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSwimlanes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSwimlanes, sizeof(ns1__getSwimlanes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSwimlanes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSwimlanes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getSwimlanes::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getSwimlanes::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSwimlanes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSwimlanes, 0, sizeof(ns1__getSwimlanes), 0, soap_copy_ns1__getSwimlanes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSwimlanes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSwimlanes);
	if (this->soap_out(soap, tag?tag:"ns1:getSwimlanes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSwimlanes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSwimlanes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSwimlanes * SOAP_FMAC4 soap_get_ns1__getSwimlanes(struct soap *soap, ns1__getSwimlanes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSwimlanes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSwimlanes * SOAP_FMAC2 soap_instantiate_ns1__getSwimlanes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSwimlanes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSwimlanes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSwimlanes);
		if (size)
			*size = sizeof(ns1__getSwimlanes);
		((ns1__getSwimlanes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSwimlanes, n);
		if (size)
			*size = n * sizeof(ns1__getSwimlanes);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSwimlanes*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSwimlanes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSwimlanes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSwimlanes %p -> %p\n", q, p));
	*(ns1__getSwimlanes*)p = *(ns1__getSwimlanes*)q;
}

void ns1__updateVariablesWSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__updateVariablesWSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__updateVariablesWSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateVariablesWSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateVariablesWSResponse(struct soap *soap, const char *tag, int id, const ns1__updateVariablesWSResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:updateVariablesWSResponse");
}

void *ns1__updateVariablesWSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateVariablesWSResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateVariablesWSResponse * SOAP_FMAC4 soap_in_ns1__updateVariablesWSResponse(struct soap *soap, const char *tag, ns1__updateVariablesWSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__updateVariablesWSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateVariablesWSResponse, sizeof(ns1__updateVariablesWSResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateVariablesWSResponse)
			return (ns1__updateVariablesWSResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__updateVariablesWSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateVariablesWSResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateVariablesWSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateVariablesWSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateVariablesWSResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateVariablesWSResponse * SOAP_FMAC4 soap_get_ns1__updateVariablesWSResponse(struct soap *soap, ns1__updateVariablesWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateVariablesWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateVariablesWSResponse * SOAP_FMAC2 soap_instantiate_ns1__updateVariablesWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateVariablesWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateVariablesWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateVariablesWSResponse);
		if (size)
			*size = sizeof(ns1__updateVariablesWSResponse);
		((ns1__updateVariablesWSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__updateVariablesWSResponse, n);
		if (size)
			*size = n * sizeof(ns1__updateVariablesWSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__updateVariablesWSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__updateVariablesWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateVariablesWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateVariablesWSResponse %p -> %p\n", q, p));
	*(ns1__updateVariablesWSResponse*)p = *(ns1__updateVariablesWSResponse*)q;
}

void ns1__updateVariablesWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__updateVariablesWS::user = NULL;
	this->ns1__updateVariablesWS::processId = NULL;
	this->ns1__updateVariablesWS::__sizevariables = 0;
	this->ns1__updateVariablesWS::variables = NULL;
}

void ns1__updateVariablesWS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__updateVariablesWS::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__updateVariablesWS::processId);
	if (this->ns1__updateVariablesWS::variables)
	{	int i;
		for (i = 0; i < this->ns1__updateVariablesWS::__sizevariables; i++)
		{
			soap_serialize_PointerTons1__variable(soap, this->ns1__updateVariablesWS::variables + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__updateVariablesWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateVariablesWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateVariablesWS(struct soap *soap, const char *tag, int id, const ns1__updateVariablesWS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateVariablesWS), "ns1:updateVariablesWS"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__updateVariablesWS::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__updateVariablesWS::processId), ""))
		return soap->error;
	if (a->ns1__updateVariablesWS::variables)
	{	int i;
		for (i = 0; i < a->ns1__updateVariablesWS::__sizevariables; i++)
			if (soap_out_PointerTons1__variable(soap, "variables", -1, a->ns1__updateVariablesWS::variables + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__updateVariablesWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateVariablesWS(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateVariablesWS * SOAP_FMAC4 soap_in_ns1__updateVariablesWS(struct soap *soap, const char *tag, ns1__updateVariablesWS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateVariablesWS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateVariablesWS, sizeof(ns1__updateVariablesWS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateVariablesWS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateVariablesWS *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	struct soap_blist *soap_blist_variables1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__updateVariablesWS::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__updateVariablesWS::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "variables", 1, NULL))
			{	if (a->ns1__updateVariablesWS::variables == NULL)
				{	if (soap_blist_variables1 == NULL)
						soap_blist_variables1 = soap_new_block(soap);
					a->ns1__updateVariablesWS::variables = (ns1__variable **)soap_push_block(soap, soap_blist_variables1, sizeof(ns1__variable *));
					if (a->ns1__updateVariablesWS::variables == NULL)
						return NULL;
					*a->ns1__updateVariablesWS::variables = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__variable(soap, "variables", a->ns1__updateVariablesWS::variables, "ns1:variable"))
				{	a->ns1__updateVariablesWS::__sizevariables++;
					a->ns1__updateVariablesWS::variables = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__updateVariablesWS::variables)
			soap_pop_block(soap, soap_blist_variables1);
		if (a->ns1__updateVariablesWS::__sizevariables)
			a->ns1__updateVariablesWS::variables = (ns1__variable **)soap_save_block(soap, soap_blist_variables1, NULL, 1);
		else
		{	a->ns1__updateVariablesWS::variables = NULL;
			if (soap_blist_variables1)
				soap_end_block(soap, soap_blist_variables1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateVariablesWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateVariablesWS, 0, sizeof(ns1__updateVariablesWS), 0, soap_copy_ns1__updateVariablesWS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__updateVariablesWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateVariablesWS);
	if (this->soap_out(soap, tag?tag:"ns1:updateVariablesWS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateVariablesWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateVariablesWS(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateVariablesWS * SOAP_FMAC4 soap_get_ns1__updateVariablesWS(struct soap *soap, ns1__updateVariablesWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateVariablesWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateVariablesWS * SOAP_FMAC2 soap_instantiate_ns1__updateVariablesWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateVariablesWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateVariablesWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateVariablesWS);
		if (size)
			*size = sizeof(ns1__updateVariablesWS);
		((ns1__updateVariablesWS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__updateVariablesWS, n);
		if (size)
			*size = n * sizeof(ns1__updateVariablesWS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__updateVariablesWS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__updateVariablesWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateVariablesWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateVariablesWS %p -> %p\n", q, p));
	*(ns1__updateVariablesWS*)p = *(ns1__updateVariablesWS*)q;
}

void ns1__completeTaskWSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__completeTaskWSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__completeTaskWSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__completeTaskWSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__completeTaskWSResponse(struct soap *soap, const char *tag, int id, const ns1__completeTaskWSResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:completeTaskWSResponse");
}

void *ns1__completeTaskWSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__completeTaskWSResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__completeTaskWSResponse * SOAP_FMAC4 soap_in_ns1__completeTaskWSResponse(struct soap *soap, const char *tag, ns1__completeTaskWSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__completeTaskWSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__completeTaskWSResponse, sizeof(ns1__completeTaskWSResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__completeTaskWSResponse)
			return (ns1__completeTaskWSResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__completeTaskWSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__completeTaskWSResponse);
	if (this->soap_out(soap, tag?tag:"ns1:completeTaskWSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__completeTaskWSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__completeTaskWSResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__completeTaskWSResponse * SOAP_FMAC4 soap_get_ns1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__completeTaskWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__completeTaskWSResponse * SOAP_FMAC2 soap_instantiate_ns1__completeTaskWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__completeTaskWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__completeTaskWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWSResponse);
		if (size)
			*size = sizeof(ns1__completeTaskWSResponse);
		((ns1__completeTaskWSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWSResponse, n);
		if (size)
			*size = n * sizeof(ns1__completeTaskWSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__completeTaskWSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__completeTaskWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__completeTaskWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__completeTaskWSResponse %p -> %p\n", q, p));
	*(ns1__completeTaskWSResponse*)p = *(ns1__completeTaskWSResponse*)q;
}

void ns1__completeTaskWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__completeTaskWS::user = NULL;
	this->ns1__completeTaskWS::taskId = NULL;
	this->ns1__completeTaskWS::__sizevariables = 0;
	this->ns1__completeTaskWS::variables = NULL;
	this->ns1__completeTaskWS::swimlaneActorId = NULL;
}

void ns1__completeTaskWS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__completeTaskWS::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__completeTaskWS::taskId);
	if (this->ns1__completeTaskWS::variables)
	{	int i;
		for (i = 0; i < this->ns1__completeTaskWS::__sizevariables; i++)
		{
			soap_serialize_PointerTons1__variable(soap, this->ns1__completeTaskWS::variables + i);
		}
	}
	soap_serialize_PointerToLONG64(soap, &this->ns1__completeTaskWS::swimlaneActorId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__completeTaskWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__completeTaskWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__completeTaskWS(struct soap *soap, const char *tag, int id, const ns1__completeTaskWS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__completeTaskWS), "ns1:completeTaskWS"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__completeTaskWS::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__completeTaskWS::taskId), ""))
		return soap->error;
	if (a->ns1__completeTaskWS::variables)
	{	int i;
		for (i = 0; i < a->ns1__completeTaskWS::__sizevariables; i++)
			if (soap_out_PointerTons1__variable(soap, "variables", -1, a->ns1__completeTaskWS::variables + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToLONG64(soap, "swimlaneActorId", -1, &(a->ns1__completeTaskWS::swimlaneActorId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__completeTaskWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__completeTaskWS(soap, tag, this, type);
}

SOAP_FMAC3 ns1__completeTaskWS * SOAP_FMAC4 soap_in_ns1__completeTaskWS(struct soap *soap, const char *tag, ns1__completeTaskWS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__completeTaskWS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__completeTaskWS, sizeof(ns1__completeTaskWS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__completeTaskWS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__completeTaskWS *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	struct soap_blist *soap_blist_variables1 = NULL;
	size_t soap_flag_swimlaneActorId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__completeTaskWS::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__completeTaskWS::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "variables", 1, NULL))
			{	if (a->ns1__completeTaskWS::variables == NULL)
				{	if (soap_blist_variables1 == NULL)
						soap_blist_variables1 = soap_new_block(soap);
					a->ns1__completeTaskWS::variables = (ns1__variable **)soap_push_block(soap, soap_blist_variables1, sizeof(ns1__variable *));
					if (a->ns1__completeTaskWS::variables == NULL)
						return NULL;
					*a->ns1__completeTaskWS::variables = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__variable(soap, "variables", a->ns1__completeTaskWS::variables, "ns1:variable"))
				{	a->ns1__completeTaskWS::__sizevariables++;
					a->ns1__completeTaskWS::variables = NULL;
					continue;
				}
			}
			if (soap_flag_swimlaneActorId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "swimlaneActorId", &(a->ns1__completeTaskWS::swimlaneActorId), "xsd:long"))
				{	soap_flag_swimlaneActorId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__completeTaskWS::variables)
			soap_pop_block(soap, soap_blist_variables1);
		if (a->ns1__completeTaskWS::__sizevariables)
			a->ns1__completeTaskWS::variables = (ns1__variable **)soap_save_block(soap, soap_blist_variables1, NULL, 1);
		else
		{	a->ns1__completeTaskWS::variables = NULL;
			if (soap_blist_variables1)
				soap_end_block(soap, soap_blist_variables1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__completeTaskWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__completeTaskWS, 0, sizeof(ns1__completeTaskWS), 0, soap_copy_ns1__completeTaskWS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__completeTaskWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__completeTaskWS);
	if (this->soap_out(soap, tag?tag:"ns1:completeTaskWS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__completeTaskWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__completeTaskWS(soap, this, tag, type);
}

SOAP_FMAC3 ns1__completeTaskWS * SOAP_FMAC4 soap_get_ns1__completeTaskWS(struct soap *soap, ns1__completeTaskWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__completeTaskWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__completeTaskWS * SOAP_FMAC2 soap_instantiate_ns1__completeTaskWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__completeTaskWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__completeTaskWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWS);
		if (size)
			*size = sizeof(ns1__completeTaskWS);
		((ns1__completeTaskWS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWS, n);
		if (size)
			*size = n * sizeof(ns1__completeTaskWS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__completeTaskWS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__completeTaskWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__completeTaskWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__completeTaskWS %p -> %p\n", q, p));
	*(ns1__completeTaskWS*)p = *(ns1__completeTaskWS*)q;
}

void ns1__startProcessWSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__startProcessWSResponse::result = NULL;
}

void ns1__startProcessWSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__startProcessWSResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__startProcessWSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__startProcessWSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__startProcessWSResponse(struct soap *soap, const char *tag, int id, const ns1__startProcessWSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__startProcessWSResponse), "ns1:startProcessWSResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "result", -1, &(a->ns1__startProcessWSResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__startProcessWSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__startProcessWSResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__startProcessWSResponse * SOAP_FMAC4 soap_in_ns1__startProcessWSResponse(struct soap *soap, const char *tag, ns1__startProcessWSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__startProcessWSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__startProcessWSResponse, sizeof(ns1__startProcessWSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__startProcessWSResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__startProcessWSResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "result", &(a->ns1__startProcessWSResponse::result), "xsd:long"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__startProcessWSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__startProcessWSResponse, 0, sizeof(ns1__startProcessWSResponse), 0, soap_copy_ns1__startProcessWSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__startProcessWSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__startProcessWSResponse);
	if (this->soap_out(soap, tag?tag:"ns1:startProcessWSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__startProcessWSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__startProcessWSResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__startProcessWSResponse * SOAP_FMAC4 soap_get_ns1__startProcessWSResponse(struct soap *soap, ns1__startProcessWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__startProcessWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__startProcessWSResponse * SOAP_FMAC2 soap_instantiate_ns1__startProcessWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__startProcessWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__startProcessWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__startProcessWSResponse);
		if (size)
			*size = sizeof(ns1__startProcessWSResponse);
		((ns1__startProcessWSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__startProcessWSResponse, n);
		if (size)
			*size = n * sizeof(ns1__startProcessWSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__startProcessWSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__startProcessWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__startProcessWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__startProcessWSResponse %p -> %p\n", q, p));
	*(ns1__startProcessWSResponse*)p = *(ns1__startProcessWSResponse*)q;
}

void ns1__startProcessWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__startProcessWS::user = NULL;
	this->ns1__startProcessWS::definitionName = NULL;
	this->ns1__startProcessWS::__sizevariables = 0;
	this->ns1__startProcessWS::variables = NULL;
}

void ns1__startProcessWS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__startProcessWS::user);
	soap_serialize_wstring(soap, &this->ns1__startProcessWS::definitionName);
	if (this->ns1__startProcessWS::variables)
	{	int i;
		for (i = 0; i < this->ns1__startProcessWS::__sizevariables; i++)
		{
			soap_serialize_PointerTons1__variable(soap, this->ns1__startProcessWS::variables + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__startProcessWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__startProcessWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__startProcessWS(struct soap *soap, const char *tag, int id, const ns1__startProcessWS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__startProcessWS), "ns1:startProcessWS"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__startProcessWS::user), ""))
		return soap->error;
	if (soap_out_wstring(soap, "definitionName", -1, &(a->ns1__startProcessWS::definitionName), ""))
		return soap->error;
	if (a->ns1__startProcessWS::variables)
	{	int i;
		for (i = 0; i < a->ns1__startProcessWS::__sizevariables; i++)
			if (soap_out_PointerTons1__variable(soap, "variables", -1, a->ns1__startProcessWS::variables + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__startProcessWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__startProcessWS(soap, tag, this, type);
}

SOAP_FMAC3 ns1__startProcessWS * SOAP_FMAC4 soap_in_ns1__startProcessWS(struct soap *soap, const char *tag, ns1__startProcessWS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__startProcessWS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__startProcessWS, sizeof(ns1__startProcessWS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__startProcessWS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__startProcessWS *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_definitionName1 = 1;
	struct soap_blist *soap_blist_variables1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__startProcessWS::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_definitionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "definitionName", &(a->ns1__startProcessWS::definitionName), "xsd:string"))
				{	soap_flag_definitionName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "variables", 1, NULL))
			{	if (a->ns1__startProcessWS::variables == NULL)
				{	if (soap_blist_variables1 == NULL)
						soap_blist_variables1 = soap_new_block(soap);
					a->ns1__startProcessWS::variables = (ns1__variable **)soap_push_block(soap, soap_blist_variables1, sizeof(ns1__variable *));
					if (a->ns1__startProcessWS::variables == NULL)
						return NULL;
					*a->ns1__startProcessWS::variables = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__variable(soap, "variables", a->ns1__startProcessWS::variables, "ns1:variable"))
				{	a->ns1__startProcessWS::__sizevariables++;
					a->ns1__startProcessWS::variables = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__startProcessWS::variables)
			soap_pop_block(soap, soap_blist_variables1);
		if (a->ns1__startProcessWS::__sizevariables)
			a->ns1__startProcessWS::variables = (ns1__variable **)soap_save_block(soap, soap_blist_variables1, NULL, 1);
		else
		{	a->ns1__startProcessWS::variables = NULL;
			if (soap_blist_variables1)
				soap_end_block(soap, soap_blist_variables1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__startProcessWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__startProcessWS, 0, sizeof(ns1__startProcessWS), 0, soap_copy_ns1__startProcessWS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__startProcessWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__startProcessWS);
	if (this->soap_out(soap, tag?tag:"ns1:startProcessWS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__startProcessWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__startProcessWS(soap, this, tag, type);
}

SOAP_FMAC3 ns1__startProcessWS * SOAP_FMAC4 soap_get_ns1__startProcessWS(struct soap *soap, ns1__startProcessWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__startProcessWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__startProcessWS * SOAP_FMAC2 soap_instantiate_ns1__startProcessWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__startProcessWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__startProcessWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__startProcessWS);
		if (size)
			*size = sizeof(ns1__startProcessWS);
		((ns1__startProcessWS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__startProcessWS, n);
		if (size)
			*size = n * sizeof(ns1__startProcessWS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__startProcessWS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__startProcessWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__startProcessWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__startProcessWS %p -> %p\n", q, p));
	*(ns1__startProcessWS*)p = *(ns1__startProcessWS*)q;
}

void ns1__variable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__variable::name = NULL;
	this->ns1__variable::scriptingName = NULL;
	this->ns1__variable::format = NULL;
	this->ns1__variable::value = NULL;
}

void ns1__variable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__variable::name);
	soap_serialize_wstring(soap, &this->ns1__variable::scriptingName);
	soap_serialize_wstring(soap, &this->ns1__variable::format);
	soap_serialize_wstring(soap, &this->ns1__variable::value);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__variable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__variable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__variable(struct soap *soap, const char *tag, int id, const ns1__variable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__variable), "ns1:variable"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__variable::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "scriptingName", -1, &(a->ns1__variable::scriptingName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "format", -1, &(a->ns1__variable::format), ""))
		return soap->error;
	if (soap_out_wstring(soap, "value", -1, &(a->ns1__variable::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__variable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__variable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__variable * SOAP_FMAC4 soap_in_ns1__variable(struct soap *soap, const char *tag, ns1__variable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__variable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__variable, sizeof(ns1__variable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__variable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__variable *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_scriptingName1 = 1;
	size_t soap_flag_format1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__variable::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_scriptingName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "scriptingName", &(a->ns1__variable::scriptingName), "xsd:string"))
				{	soap_flag_scriptingName1--;
					continue;
				}
			if (soap_flag_format1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "format", &(a->ns1__variable::format), "xsd:string"))
				{	soap_flag_format1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "value", &(a->ns1__variable::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__variable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__variable, 0, sizeof(ns1__variable), 0, soap_copy_ns1__variable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__variable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__variable);
	if (this->soap_out(soap, tag?tag:"ns1:variable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__variable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__variable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__variable * SOAP_FMAC4 soap_get_ns1__variable(struct soap *soap, ns1__variable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__variable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__variable * SOAP_FMAC2 soap_instantiate_ns1__variable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__variable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__variable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__variable);
		if (size)
			*size = sizeof(ns1__variable);
		((ns1__variable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variable, n);
		if (size)
			*size = n * sizeof(ns1__variable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__variable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__variable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__variable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__variable %p -> %p\n", q, p));
	*(ns1__variable*)p = *(ns1__variable*)q;
}

void ns1__getVariablesWSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getVariablesWSResponse::__sizeresult = 0;
	this->ns1__getVariablesWSResponse::result = NULL;
}

void ns1__getVariablesWSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getVariablesWSResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getVariablesWSResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__variable(soap, this->ns1__getVariablesWSResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getVariablesWSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getVariablesWSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVariablesWSResponse(struct soap *soap, const char *tag, int id, const ns1__getVariablesWSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVariablesWSResponse), "ns1:getVariablesWSResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getVariablesWSResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getVariablesWSResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__variable(soap, "result", -1, a->ns1__getVariablesWSResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getVariablesWSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getVariablesWSResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getVariablesWSResponse * SOAP_FMAC4 soap_in_ns1__getVariablesWSResponse(struct soap *soap, const char *tag, ns1__getVariablesWSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getVariablesWSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVariablesWSResponse, sizeof(ns1__getVariablesWSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getVariablesWSResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getVariablesWSResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getVariablesWSResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getVariablesWSResponse::result = (ns1__variable **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__variable *));
					if (a->ns1__getVariablesWSResponse::result == NULL)
						return NULL;
					*a->ns1__getVariablesWSResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__variable(soap, "result", a->ns1__getVariablesWSResponse::result, "ns1:variable"))
				{	a->ns1__getVariablesWSResponse::__sizeresult++;
					a->ns1__getVariablesWSResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getVariablesWSResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getVariablesWSResponse::__sizeresult)
			a->ns1__getVariablesWSResponse::result = (ns1__variable **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getVariablesWSResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getVariablesWSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVariablesWSResponse, 0, sizeof(ns1__getVariablesWSResponse), 0, soap_copy_ns1__getVariablesWSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getVariablesWSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getVariablesWSResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getVariablesWSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getVariablesWSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getVariablesWSResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getVariablesWSResponse * SOAP_FMAC4 soap_get_ns1__getVariablesWSResponse(struct soap *soap, ns1__getVariablesWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVariablesWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getVariablesWSResponse * SOAP_FMAC2 soap_instantiate_ns1__getVariablesWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVariablesWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVariablesWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getVariablesWSResponse);
		if (size)
			*size = sizeof(ns1__getVariablesWSResponse);
		((ns1__getVariablesWSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariablesWSResponse, n);
		if (size)
			*size = n * sizeof(ns1__getVariablesWSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getVariablesWSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getVariablesWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVariablesWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getVariablesWSResponse %p -> %p\n", q, p));
	*(ns1__getVariablesWSResponse*)p = *(ns1__getVariablesWSResponse*)q;
}

void ns1__getVariablesWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getVariablesWS::user = NULL;
	this->ns1__getVariablesWS::processId = NULL;
}

void ns1__getVariablesWS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getVariablesWS::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getVariablesWS::processId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getVariablesWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getVariablesWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVariablesWS(struct soap *soap, const char *tag, int id, const ns1__getVariablesWS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVariablesWS), "ns1:getVariablesWS"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getVariablesWS::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getVariablesWS::processId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getVariablesWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getVariablesWS(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getVariablesWS * SOAP_FMAC4 soap_in_ns1__getVariablesWS(struct soap *soap, const char *tag, ns1__getVariablesWS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getVariablesWS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVariablesWS, sizeof(ns1__getVariablesWS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getVariablesWS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getVariablesWS *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getVariablesWS::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getVariablesWS::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getVariablesWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVariablesWS, 0, sizeof(ns1__getVariablesWS), 0, soap_copy_ns1__getVariablesWS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getVariablesWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getVariablesWS);
	if (this->soap_out(soap, tag?tag:"ns1:getVariablesWS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getVariablesWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getVariablesWS(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getVariablesWS * SOAP_FMAC4 soap_get_ns1__getVariablesWS(struct soap *soap, ns1__getVariablesWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVariablesWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getVariablesWS * SOAP_FMAC2 soap_instantiate_ns1__getVariablesWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVariablesWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVariablesWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getVariablesWS);
		if (size)
			*size = sizeof(ns1__getVariablesWS);
		((ns1__getVariablesWS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariablesWS, n);
		if (size)
			*size = n * sizeof(ns1__getVariablesWS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getVariablesWS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getVariablesWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVariablesWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getVariablesWS %p -> %p\n", q, p));
	*(ns1__getVariablesWS*)p = *(ns1__getVariablesWS*)q;
}

void ns1__getSystemLogsCountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->ns1__getSystemLogsCountResponse::result);
}

void ns1__getSystemLogsCountResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__getSystemLogsCountResponse::result, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSystemLogsCountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSystemLogsCountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSystemLogsCountResponse(struct soap *soap, const char *tag, int id, const ns1__getSystemLogsCountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSystemLogsCountResponse), "ns1:getSystemLogsCountResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "result", -1, &(a->ns1__getSystemLogsCountResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getSystemLogsCountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSystemLogsCountResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSystemLogsCountResponse * SOAP_FMAC4 soap_in_ns1__getSystemLogsCountResponse(struct soap *soap, const char *tag, ns1__getSystemLogsCountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSystemLogsCountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSystemLogsCountResponse, sizeof(ns1__getSystemLogsCountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSystemLogsCountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSystemLogsCountResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &(a->ns1__getSystemLogsCountResponse::result), "xsd:int"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSystemLogsCountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSystemLogsCountResponse, 0, sizeof(ns1__getSystemLogsCountResponse), 0, soap_copy_ns1__getSystemLogsCountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getSystemLogsCountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSystemLogsCountResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSystemLogsCountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSystemLogsCountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSystemLogsCountResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSystemLogsCountResponse * SOAP_FMAC4 soap_get_ns1__getSystemLogsCountResponse(struct soap *soap, ns1__getSystemLogsCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSystemLogsCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSystemLogsCountResponse * SOAP_FMAC2 soap_instantiate_ns1__getSystemLogsCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSystemLogsCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSystemLogsCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogsCountResponse);
		if (size)
			*size = sizeof(ns1__getSystemLogsCountResponse);
		((ns1__getSystemLogsCountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogsCountResponse, n);
		if (size)
			*size = n * sizeof(ns1__getSystemLogsCountResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSystemLogsCountResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSystemLogsCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSystemLogsCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSystemLogsCountResponse %p -> %p\n", q, p));
	*(ns1__getSystemLogsCountResponse*)p = *(ns1__getSystemLogsCountResponse*)q;
}

void ns1__getSystemLogsCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getSystemLogsCount::user = NULL;
	this->ns1__getSystemLogsCount::batchPresentation = NULL;
}

void ns1__getSystemLogsCount::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getSystemLogsCount::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__getSystemLogsCount::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSystemLogsCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSystemLogsCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSystemLogsCount(struct soap *soap, const char *tag, int id, const ns1__getSystemLogsCount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSystemLogsCount), "ns1:getSystemLogsCount"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getSystemLogsCount::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__getSystemLogsCount::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getSystemLogsCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSystemLogsCount(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSystemLogsCount * SOAP_FMAC4 soap_in_ns1__getSystemLogsCount(struct soap *soap, const char *tag, ns1__getSystemLogsCount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSystemLogsCount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSystemLogsCount, sizeof(ns1__getSystemLogsCount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSystemLogsCount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSystemLogsCount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getSystemLogsCount::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__getSystemLogsCount::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSystemLogsCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSystemLogsCount, 0, sizeof(ns1__getSystemLogsCount), 0, soap_copy_ns1__getSystemLogsCount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSystemLogsCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSystemLogsCount);
	if (this->soap_out(soap, tag?tag:"ns1:getSystemLogsCount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSystemLogsCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSystemLogsCount(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSystemLogsCount * SOAP_FMAC4 soap_get_ns1__getSystemLogsCount(struct soap *soap, ns1__getSystemLogsCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSystemLogsCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSystemLogsCount * SOAP_FMAC2 soap_instantiate_ns1__getSystemLogsCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSystemLogsCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSystemLogsCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogsCount);
		if (size)
			*size = sizeof(ns1__getSystemLogsCount);
		((ns1__getSystemLogsCount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogsCount, n);
		if (size)
			*size = n * sizeof(ns1__getSystemLogsCount);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSystemLogsCount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSystemLogsCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSystemLogsCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSystemLogsCount %p -> %p\n", q, p));
	*(ns1__getSystemLogsCount*)p = *(ns1__getSystemLogsCount*)q;
}

void ns1__processDeleteLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__systemLog::soap_default(soap);
	this->ns1__processDeleteLog::processId = NULL;
}

void ns1__processDeleteLog::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__processDeleteLog::processId);
	this->ns1__systemLog::soap_serialize(soap);
#endif
}

int ns1__processDeleteLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__processDeleteLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__processDeleteLog(struct soap *soap, const char *tag, int id, const ns1__processDeleteLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__processDeleteLog), "ns1:processDeleteLog"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "actorId", -1, &(a->ns1__systemLog::actorId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__systemLog::createDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__systemLog::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__processDeleteLog::processId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__processDeleteLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__processDeleteLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__processDeleteLog * SOAP_FMAC4 soap_in_ns1__processDeleteLog(struct soap *soap, const char *tag, ns1__processDeleteLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__processDeleteLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__processDeleteLog, sizeof(ns1__processDeleteLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__processDeleteLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__processDeleteLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_actorId2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_id2 = 1;
	size_t soap_flag_processId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actorId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "actorId", &(a->ns1__systemLog::actorId), "xsd:long"))
				{	soap_flag_actorId2--;
					continue;
				}
			if (soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__systemLog::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__systemLog::id), "xsd:long"))
				{	soap_flag_id2--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__processDeleteLog::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__processDeleteLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__processDeleteLog, 0, sizeof(ns1__processDeleteLog), 0, soap_copy_ns1__processDeleteLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__processDeleteLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__processDeleteLog);
	if (this->soap_out(soap, tag?tag:"ns1:processDeleteLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__processDeleteLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__processDeleteLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__processDeleteLog * SOAP_FMAC4 soap_get_ns1__processDeleteLog(struct soap *soap, ns1__processDeleteLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__processDeleteLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__processDeleteLog * SOAP_FMAC2 soap_instantiate_ns1__processDeleteLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__processDeleteLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__processDeleteLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__processDeleteLog);
		if (size)
			*size = sizeof(ns1__processDeleteLog);
		((ns1__processDeleteLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processDeleteLog, n);
		if (size)
			*size = n * sizeof(ns1__processDeleteLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__processDeleteLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__processDeleteLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__processDeleteLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__processDeleteLog %p -> %p\n", q, p));
	*(ns1__processDeleteLog*)p = *(ns1__processDeleteLog*)q;
}

void ns1__processDefinitionDeleteLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__systemLog::soap_default(soap);
	this->ns1__processDefinitionDeleteLog::name = NULL;
	this->ns1__processDefinitionDeleteLog::version = NULL;
}

void ns1__processDefinitionDeleteLog::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__processDefinitionDeleteLog::name);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processDefinitionDeleteLog::version);
	this->ns1__systemLog::soap_serialize(soap);
#endif
}

int ns1__processDefinitionDeleteLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__processDefinitionDeleteLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__processDefinitionDeleteLog(struct soap *soap, const char *tag, int id, const ns1__processDefinitionDeleteLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__processDefinitionDeleteLog), "ns1:processDefinitionDeleteLog"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "actorId", -1, &(a->ns1__systemLog::actorId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__systemLog::createDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__systemLog::id), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__processDefinitionDeleteLog::name), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__processDefinitionDeleteLog::version), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__processDefinitionDeleteLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__processDefinitionDeleteLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__processDefinitionDeleteLog * SOAP_FMAC4 soap_in_ns1__processDefinitionDeleteLog(struct soap *soap, const char *tag, ns1__processDefinitionDeleteLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__processDefinitionDeleteLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__processDefinitionDeleteLog, sizeof(ns1__processDefinitionDeleteLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__processDefinitionDeleteLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__processDefinitionDeleteLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_actorId2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_id2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actorId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "actorId", &(a->ns1__systemLog::actorId), "xsd:long"))
				{	soap_flag_actorId2--;
					continue;
				}
			if (soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__systemLog::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__systemLog::id), "xsd:long"))
				{	soap_flag_id2--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__processDefinitionDeleteLog::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__processDefinitionDeleteLog::version), "xsd:long"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__processDefinitionDeleteLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__processDefinitionDeleteLog, 0, sizeof(ns1__processDefinitionDeleteLog), 0, soap_copy_ns1__processDefinitionDeleteLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__processDefinitionDeleteLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__processDefinitionDeleteLog);
	if (this->soap_out(soap, tag?tag:"ns1:processDefinitionDeleteLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__processDefinitionDeleteLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__processDefinitionDeleteLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__processDefinitionDeleteLog * SOAP_FMAC4 soap_get_ns1__processDefinitionDeleteLog(struct soap *soap, ns1__processDefinitionDeleteLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__processDefinitionDeleteLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__processDefinitionDeleteLog * SOAP_FMAC2 soap_instantiate_ns1__processDefinitionDeleteLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__processDefinitionDeleteLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__processDefinitionDeleteLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__processDefinitionDeleteLog);
		if (size)
			*size = sizeof(ns1__processDefinitionDeleteLog);
		((ns1__processDefinitionDeleteLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processDefinitionDeleteLog, n);
		if (size)
			*size = n * sizeof(ns1__processDefinitionDeleteLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__processDefinitionDeleteLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__processDefinitionDeleteLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__processDefinitionDeleteLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__processDefinitionDeleteLog %p -> %p\n", q, p));
	*(ns1__processDefinitionDeleteLog*)p = *(ns1__processDefinitionDeleteLog*)q;
}

void ns1__systemLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__systemLog::actorId = NULL;
	this->ns1__systemLog::createDate = NULL;
	this->ns1__systemLog::id = NULL;
}

void ns1__systemLog::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__systemLog::actorId);
	soap_serialize_PointerTotime(soap, &this->ns1__systemLog::createDate);
	soap_serialize_PointerToLONG64(soap, &this->ns1__systemLog::id);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__systemLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__systemLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__systemLog(struct soap *soap, const char *tag, int id, const ns1__systemLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__systemLog), "ns1:systemLog"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "actorId", -1, &(a->ns1__systemLog::actorId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__systemLog::createDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__systemLog::id), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__systemLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__systemLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__systemLog * SOAP_FMAC4 soap_in_ns1__systemLog(struct soap *soap, const char *tag, ns1__systemLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__systemLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__systemLog, sizeof(ns1__systemLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__systemLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__systemLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_actorId1 = 1;
	size_t soap_flag_createDate1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actorId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "actorId", &(a->ns1__systemLog::actorId), "xsd:long"))
				{	soap_flag_actorId1--;
					continue;
				}
			if (soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__systemLog::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__systemLog::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__systemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__systemLog, 0, sizeof(ns1__systemLog), 0, soap_copy_ns1__systemLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__systemLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__systemLog);
	if (this->soap_out(soap, tag?tag:"ns1:systemLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__systemLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__systemLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__systemLog * SOAP_FMAC4 soap_get_ns1__systemLog(struct soap *soap, ns1__systemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__systemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__systemLog * SOAP_FMAC2 soap_instantiate_ns1__systemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__systemLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__systemLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:processDefinitionDeleteLog"))
	{	cp->type = SOAP_TYPE_ns1__processDefinitionDeleteLog;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processDefinitionDeleteLog);
			if (size)
				*size = sizeof(ns1__processDefinitionDeleteLog);
			((ns1__processDefinitionDeleteLog*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processDefinitionDeleteLog, n);
			if (size)
				*size = n * sizeof(ns1__processDefinitionDeleteLog);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processDefinitionDeleteLog*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processDefinitionDeleteLog*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:processDeleteLog"))
	{	cp->type = SOAP_TYPE_ns1__processDeleteLog;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processDeleteLog);
			if (size)
				*size = sizeof(ns1__processDeleteLog);
			((ns1__processDeleteLog*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processDeleteLog, n);
			if (size)
				*size = n * sizeof(ns1__processDeleteLog);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processDeleteLog*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processDeleteLog*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__systemLog);
		if (size)
			*size = sizeof(ns1__systemLog);
		((ns1__systemLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__systemLog, n);
		if (size)
			*size = n * sizeof(ns1__systemLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__systemLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__systemLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__systemLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__systemLog %p -> %p\n", q, p));
	*(ns1__systemLog*)p = *(ns1__systemLog*)q;
}

void ns1__getSystemLogsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getSystemLogsResponse::__sizeresult = 0;
	this->ns1__getSystemLogsResponse::result = NULL;
}

void ns1__getSystemLogsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getSystemLogsResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getSystemLogsResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__systemLog(soap, this->ns1__getSystemLogsResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSystemLogsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSystemLogsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSystemLogsResponse(struct soap *soap, const char *tag, int id, const ns1__getSystemLogsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSystemLogsResponse), "ns1:getSystemLogsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getSystemLogsResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getSystemLogsResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__systemLog(soap, "result", -1, a->ns1__getSystemLogsResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getSystemLogsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSystemLogsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSystemLogsResponse * SOAP_FMAC4 soap_in_ns1__getSystemLogsResponse(struct soap *soap, const char *tag, ns1__getSystemLogsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSystemLogsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSystemLogsResponse, sizeof(ns1__getSystemLogsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSystemLogsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSystemLogsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getSystemLogsResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getSystemLogsResponse::result = (ns1__systemLog **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__systemLog *));
					if (a->ns1__getSystemLogsResponse::result == NULL)
						return NULL;
					*a->ns1__getSystemLogsResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__systemLog(soap, "result", a->ns1__getSystemLogsResponse::result, "ns1:systemLog"))
				{	a->ns1__getSystemLogsResponse::__sizeresult++;
					a->ns1__getSystemLogsResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getSystemLogsResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getSystemLogsResponse::__sizeresult)
			a->ns1__getSystemLogsResponse::result = (ns1__systemLog **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getSystemLogsResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSystemLogsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSystemLogsResponse, 0, sizeof(ns1__getSystemLogsResponse), 0, soap_copy_ns1__getSystemLogsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSystemLogsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSystemLogsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSystemLogsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSystemLogsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSystemLogsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSystemLogsResponse * SOAP_FMAC4 soap_get_ns1__getSystemLogsResponse(struct soap *soap, ns1__getSystemLogsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSystemLogsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSystemLogsResponse * SOAP_FMAC2 soap_instantiate_ns1__getSystemLogsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSystemLogsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSystemLogsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogsResponse);
		if (size)
			*size = sizeof(ns1__getSystemLogsResponse);
		((ns1__getSystemLogsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogsResponse, n);
		if (size)
			*size = n * sizeof(ns1__getSystemLogsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSystemLogsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSystemLogsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSystemLogsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSystemLogsResponse %p -> %p\n", q, p));
	*(ns1__getSystemLogsResponse*)p = *(ns1__getSystemLogsResponse*)q;
}

void ns1__getSystemLogs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getSystemLogs::user = NULL;
	this->ns1__getSystemLogs::batchPresentation = NULL;
}

void ns1__getSystemLogs::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getSystemLogs::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__getSystemLogs::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSystemLogs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSystemLogs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSystemLogs(struct soap *soap, const char *tag, int id, const ns1__getSystemLogs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSystemLogs), "ns1:getSystemLogs"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getSystemLogs::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__getSystemLogs::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getSystemLogs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSystemLogs(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSystemLogs * SOAP_FMAC4 soap_in_ns1__getSystemLogs(struct soap *soap, const char *tag, ns1__getSystemLogs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSystemLogs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSystemLogs, sizeof(ns1__getSystemLogs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSystemLogs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSystemLogs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getSystemLogs::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__getSystemLogs::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSystemLogs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSystemLogs, 0, sizeof(ns1__getSystemLogs), 0, soap_copy_ns1__getSystemLogs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSystemLogs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSystemLogs);
	if (this->soap_out(soap, tag?tag:"ns1:getSystemLogs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSystemLogs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSystemLogs(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSystemLogs * SOAP_FMAC4 soap_get_ns1__getSystemLogs(struct soap *soap, ns1__getSystemLogs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSystemLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSystemLogs * SOAP_FMAC2 soap_instantiate_ns1__getSystemLogs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSystemLogs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSystemLogs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogs);
		if (size)
			*size = sizeof(ns1__getSystemLogs);
		((ns1__getSystemLogs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogs, n);
		if (size)
			*size = n * sizeof(ns1__getSystemLogs);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSystemLogs*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSystemLogs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSystemLogs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSystemLogs %p -> %p\n", q, p));
	*(ns1__getSystemLogs*)p = *(ns1__getSystemLogs*)q;
}

void ns1__removeProcessesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__removeProcessesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__removeProcessesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeProcessesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeProcessesResponse(struct soap *soap, const char *tag, int id, const ns1__removeProcessesResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:removeProcessesResponse");
}

void *ns1__removeProcessesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeProcessesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeProcessesResponse * SOAP_FMAC4 soap_in_ns1__removeProcessesResponse(struct soap *soap, const char *tag, ns1__removeProcessesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__removeProcessesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeProcessesResponse, sizeof(ns1__removeProcessesResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeProcessesResponse)
			return (ns1__removeProcessesResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__removeProcessesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeProcessesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:removeProcessesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeProcessesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeProcessesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeProcessesResponse * SOAP_FMAC4 soap_get_ns1__removeProcessesResponse(struct soap *soap, ns1__removeProcessesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeProcessesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeProcessesResponse * SOAP_FMAC2 soap_instantiate_ns1__removeProcessesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeProcessesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeProcessesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeProcessesResponse);
		if (size)
			*size = sizeof(ns1__removeProcessesResponse);
		((ns1__removeProcessesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__removeProcessesResponse, n);
		if (size)
			*size = n * sizeof(ns1__removeProcessesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__removeProcessesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__removeProcessesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeProcessesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeProcessesResponse %p -> %p\n", q, p));
	*(ns1__removeProcessesResponse*)p = *(ns1__removeProcessesResponse*)q;
}

void ns1__removeProcesses::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__removeProcesses::user = NULL;
	this->ns1__removeProcesses::filter = NULL;
}

void ns1__removeProcesses::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__removeProcesses::user);
	soap_serialize_PointerTons1__processFilter(soap, &this->ns1__removeProcesses::filter);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__removeProcesses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeProcesses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeProcesses(struct soap *soap, const char *tag, int id, const ns1__removeProcesses *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeProcesses), "ns1:removeProcesses"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__removeProcesses::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__processFilter(soap, "filter", -1, &(a->ns1__removeProcesses::filter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__removeProcesses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeProcesses(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeProcesses * SOAP_FMAC4 soap_in_ns1__removeProcesses(struct soap *soap, const char *tag, ns1__removeProcesses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeProcesses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeProcesses, sizeof(ns1__removeProcesses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeProcesses)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeProcesses *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__removeProcesses::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__processFilter(soap, "filter", &(a->ns1__removeProcesses::filter), "ns1:processFilter"))
				{	soap_flag_filter1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeProcesses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeProcesses, 0, sizeof(ns1__removeProcesses), 0, soap_copy_ns1__removeProcesses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__removeProcesses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeProcesses);
	if (this->soap_out(soap, tag?tag:"ns1:removeProcesses", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__removeProcesses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeProcesses(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeProcesses * SOAP_FMAC4 soap_get_ns1__removeProcesses(struct soap *soap, ns1__removeProcesses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeProcesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__removeProcesses * SOAP_FMAC2 soap_instantiate_ns1__removeProcesses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeProcesses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeProcesses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__removeProcesses);
		if (size)
			*size = sizeof(ns1__removeProcesses);
		((ns1__removeProcesses*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__removeProcesses, n);
		if (size)
			*size = n * sizeof(ns1__removeProcesses);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__removeProcesses*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__removeProcesses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeProcesses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeProcesses %p -> %p\n", q, p));
	*(ns1__removeProcesses*)p = *(ns1__removeProcesses*)q;
}

void ns1__markTaskOpenedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__markTaskOpenedResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__markTaskOpenedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__markTaskOpenedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, int id, const ns1__markTaskOpenedResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:markTaskOpenedResponse");
}

void *ns1__markTaskOpenedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__markTaskOpenedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_in_ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, ns1__markTaskOpenedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__markTaskOpenedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__markTaskOpenedResponse, sizeof(ns1__markTaskOpenedResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__markTaskOpenedResponse)
			return (ns1__markTaskOpenedResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__markTaskOpenedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__markTaskOpenedResponse);
	if (this->soap_out(soap, tag?tag:"ns1:markTaskOpenedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__markTaskOpenedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__markTaskOpenedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_get_ns1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__markTaskOpenedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__markTaskOpenedResponse * SOAP_FMAC2 soap_instantiate_ns1__markTaskOpenedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__markTaskOpenedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__markTaskOpenedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpenedResponse);
		if (size)
			*size = sizeof(ns1__markTaskOpenedResponse);
		((ns1__markTaskOpenedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpenedResponse, n);
		if (size)
			*size = n * sizeof(ns1__markTaskOpenedResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__markTaskOpenedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__markTaskOpenedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__markTaskOpenedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__markTaskOpenedResponse %p -> %p\n", q, p));
	*(ns1__markTaskOpenedResponse*)p = *(ns1__markTaskOpenedResponse*)q;
}

void ns1__markTaskOpened::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__markTaskOpened::user = NULL;
	this->ns1__markTaskOpened::taskId = NULL;
}

void ns1__markTaskOpened::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__markTaskOpened::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__markTaskOpened::taskId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__markTaskOpened::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__markTaskOpened(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__markTaskOpened(struct soap *soap, const char *tag, int id, const ns1__markTaskOpened *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__markTaskOpened), "ns1:markTaskOpened"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__markTaskOpened::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__markTaskOpened::taskId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__markTaskOpened::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__markTaskOpened(soap, tag, this, type);
}

SOAP_FMAC3 ns1__markTaskOpened * SOAP_FMAC4 soap_in_ns1__markTaskOpened(struct soap *soap, const char *tag, ns1__markTaskOpened *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__markTaskOpened *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__markTaskOpened, sizeof(ns1__markTaskOpened), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__markTaskOpened)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__markTaskOpened *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__markTaskOpened::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__markTaskOpened::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__markTaskOpened *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__markTaskOpened, 0, sizeof(ns1__markTaskOpened), 0, soap_copy_ns1__markTaskOpened);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__markTaskOpened::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__markTaskOpened);
	if (this->soap_out(soap, tag?tag:"ns1:markTaskOpened", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__markTaskOpened::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__markTaskOpened(soap, this, tag, type);
}

SOAP_FMAC3 ns1__markTaskOpened * SOAP_FMAC4 soap_get_ns1__markTaskOpened(struct soap *soap, ns1__markTaskOpened *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__markTaskOpened(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__markTaskOpened * SOAP_FMAC2 soap_instantiate_ns1__markTaskOpened(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__markTaskOpened(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__markTaskOpened, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpened);
		if (size)
			*size = sizeof(ns1__markTaskOpened);
		((ns1__markTaskOpened*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpened, n);
		if (size)
			*size = n * sizeof(ns1__markTaskOpened);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__markTaskOpened*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__markTaskOpened*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__markTaskOpened(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__markTaskOpened %p -> %p\n", q, p));
	*(ns1__markTaskOpened*)p = *(ns1__markTaskOpened*)q;
}

void ns1__getProcessLogValueResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessLogValueResponse::result = NULL;
}

void ns1__getProcessLogValueResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &this->ns1__getProcessLogValueResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessLogValueResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessLogValueResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessLogValueResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessLogValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessLogValueResponse), "ns1:getProcessLogValueResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__anyType(soap, "result", -1, &(a->ns1__getProcessLogValueResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessLogValueResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessLogValueResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessLogValueResponse * SOAP_FMAC4 soap_in_ns1__getProcessLogValueResponse(struct soap *soap, const char *tag, ns1__getProcessLogValueResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessLogValueResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessLogValueResponse, sizeof(ns1__getProcessLogValueResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessLogValueResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessLogValueResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "result", &(a->ns1__getProcessLogValueResponse::result), "xsd:anyType"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessLogValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessLogValueResponse, 0, sizeof(ns1__getProcessLogValueResponse), 0, soap_copy_ns1__getProcessLogValueResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessLogValueResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessLogValueResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessLogValueResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessLogValueResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessLogValueResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessLogValueResponse * SOAP_FMAC4 soap_get_ns1__getProcessLogValueResponse(struct soap *soap, ns1__getProcessLogValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessLogValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessLogValueResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessLogValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessLogValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessLogValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogValueResponse);
		if (size)
			*size = sizeof(ns1__getProcessLogValueResponse);
		((ns1__getProcessLogValueResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogValueResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessLogValueResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessLogValueResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessLogValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessLogValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessLogValueResponse %p -> %p\n", q, p));
	*(ns1__getProcessLogValueResponse*)p = *(ns1__getProcessLogValueResponse*)q;
}

void ns1__getProcessLogValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessLogValue::user = NULL;
	this->ns1__getProcessLogValue::logId = NULL;
}

void ns1__getProcessLogValue::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessLogValue::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessLogValue::logId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessLogValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessLogValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessLogValue(struct soap *soap, const char *tag, int id, const ns1__getProcessLogValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessLogValue), "ns1:getProcessLogValue"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessLogValue::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "logId", -1, &(a->ns1__getProcessLogValue::logId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessLogValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessLogValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessLogValue * SOAP_FMAC4 soap_in_ns1__getProcessLogValue(struct soap *soap, const char *tag, ns1__getProcessLogValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessLogValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessLogValue, sizeof(ns1__getProcessLogValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessLogValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessLogValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_logId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessLogValue::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_logId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "logId", &(a->ns1__getProcessLogValue::logId), "xsd:long"))
				{	soap_flag_logId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessLogValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessLogValue, 0, sizeof(ns1__getProcessLogValue), 0, soap_copy_ns1__getProcessLogValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessLogValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessLogValue);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessLogValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessLogValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessLogValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessLogValue * SOAP_FMAC4 soap_get_ns1__getProcessLogValue(struct soap *soap, ns1__getProcessLogValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessLogValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessLogValue * SOAP_FMAC2 soap_instantiate_ns1__getProcessLogValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessLogValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessLogValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogValue);
		if (size)
			*size = sizeof(ns1__getProcessLogValue);
		((ns1__getProcessLogValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogValue, n);
		if (size)
			*size = n * sizeof(ns1__getProcessLogValue);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessLogValue*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessLogValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessLogValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessLogValue %p -> %p\n", q, p));
	*(ns1__getProcessLogValue*)p = *(ns1__getProcessLogValue*)q;
}

void ns1__processLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__processLog::id = NULL;
	this->ns1__processLog::processId = NULL;
	this->ns1__processLog::tokenId = NULL;
	this->ns1__processLog::createDate = NULL;
	this->ns1__processLog::severity = NULL;
	this->ns1__processLog::bytes = NULL;
	this->ns1__processLog::nodeId = NULL;
}

void ns1__processLog::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__processLog::id);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processLog::processId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processLog::tokenId);
	soap_serialize_PointerTotime(soap, &this->ns1__processLog::createDate);
	soap_serialize_PointerTons1__severity(soap, &this->ns1__processLog::severity);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__processLog::bytes);
	soap_serialize_wstring(soap, &this->ns1__processLog::nodeId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__processLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__processLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__processLog(struct soap *soap, const char *tag, int id, const ns1__processLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__processLog), "ns1:processLog"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__processLog::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__processLog::processId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "tokenId", -1, &(a->ns1__processLog::tokenId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__processLog::createDate), ""))
		return soap->error;
	if (soap_out_PointerTons1__severity(soap, "severity", -1, &(a->ns1__processLog::severity), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "bytes", -1, &(a->ns1__processLog::bytes), ""))
		return soap->error;
	if (soap_out_wstring(soap, "nodeId", -1, &(a->ns1__processLog::nodeId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__processLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__processLog(soap, tag, this, type);
}

SOAP_FMAC3 ns1__processLog * SOAP_FMAC4 soap_in_ns1__processLog(struct soap *soap, const char *tag, ns1__processLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__processLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__processLog, sizeof(ns1__processLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__processLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__processLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_createDate1 = 1;
	size_t soap_flag_severity1 = 1;
	size_t soap_flag_bytes1 = 1;
	size_t soap_flag_nodeId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__processLog::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__processLog::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "tokenId", &(a->ns1__processLog::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__processLog::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if (soap_flag_severity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__severity(soap, "severity", &(a->ns1__processLog::severity), "ns1:severity"))
				{	soap_flag_severity1--;
					continue;
				}
			if (soap_flag_bytes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "bytes", &(a->ns1__processLog::bytes), "xsd:base64Binary"))
				{	soap_flag_bytes1--;
					continue;
				}
			if (soap_flag_nodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "nodeId", &(a->ns1__processLog::nodeId), "xsd:string"))
				{	soap_flag_nodeId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__processLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__processLog, 0, sizeof(ns1__processLog), 0, soap_copy_ns1__processLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__processLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__processLog);
	if (this->soap_out(soap, tag?tag:"ns1:processLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__processLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__processLog(soap, this, tag, type);
}

SOAP_FMAC3 ns1__processLog * SOAP_FMAC4 soap_get_ns1__processLog(struct soap *soap, ns1__processLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__processLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__processLog * SOAP_FMAC2 soap_instantiate_ns1__processLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__processLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__processLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__processLog);
		if (size)
			*size = sizeof(ns1__processLog);
		((ns1__processLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processLog, n);
		if (size)
			*size = n * sizeof(ns1__processLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__processLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__processLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__processLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__processLog %p -> %p\n", q, p));
	*(ns1__processLog*)p = *(ns1__processLog*)q;
}

void ns1__processLogs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__processLogs::__sizelogs = 0;
	this->ns1__processLogs::logs = NULL;
}

void ns1__processLogs::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__processLogs::logs)
	{	int i;
		for (i = 0; i < this->ns1__processLogs::__sizelogs; i++)
		{
			soap_serialize_PointerTons1__processLog(soap, this->ns1__processLogs::logs + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__processLogs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__processLogs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__processLogs(struct soap *soap, const char *tag, int id, const ns1__processLogs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__processLogs), "ns1:processLogs"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__processLogs::logs)
	{	int i;
		for (i = 0; i < a->ns1__processLogs::__sizelogs; i++)
			if (soap_out_PointerTons1__processLog(soap, "logs", -1, a->ns1__processLogs::logs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__processLogs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__processLogs(soap, tag, this, type);
}

SOAP_FMAC3 ns1__processLogs * SOAP_FMAC4 soap_in_ns1__processLogs(struct soap *soap, const char *tag, ns1__processLogs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__processLogs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__processLogs, sizeof(ns1__processLogs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__processLogs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__processLogs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_logs1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "logs", 1, NULL))
			{	if (a->ns1__processLogs::logs == NULL)
				{	if (soap_blist_logs1 == NULL)
						soap_blist_logs1 = soap_new_block(soap);
					a->ns1__processLogs::logs = (ns1__processLog **)soap_push_block(soap, soap_blist_logs1, sizeof(ns1__processLog *));
					if (a->ns1__processLogs::logs == NULL)
						return NULL;
					*a->ns1__processLogs::logs = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__processLog(soap, "logs", a->ns1__processLogs::logs, "ns1:processLog"))
				{	a->ns1__processLogs::__sizelogs++;
					a->ns1__processLogs::logs = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__processLogs::logs)
			soap_pop_block(soap, soap_blist_logs1);
		if (a->ns1__processLogs::__sizelogs)
			a->ns1__processLogs::logs = (ns1__processLog **)soap_save_block(soap, soap_blist_logs1, NULL, 1);
		else
		{	a->ns1__processLogs::logs = NULL;
			if (soap_blist_logs1)
				soap_end_block(soap, soap_blist_logs1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__processLogs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__processLogs, 0, sizeof(ns1__processLogs), 0, soap_copy_ns1__processLogs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__processLogs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__processLogs);
	if (this->soap_out(soap, tag?tag:"ns1:processLogs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__processLogs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__processLogs(soap, this, tag, type);
}

SOAP_FMAC3 ns1__processLogs * SOAP_FMAC4 soap_get_ns1__processLogs(struct soap *soap, ns1__processLogs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__processLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__processLogs * SOAP_FMAC2 soap_instantiate_ns1__processLogs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__processLogs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__processLogs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__processLogs);
		if (size)
			*size = sizeof(ns1__processLogs);
		((ns1__processLogs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processLogs, n);
		if (size)
			*size = n * sizeof(ns1__processLogs);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__processLogs*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__processLogs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__processLogs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__processLogs %p -> %p\n", q, p));
	*(ns1__processLogs*)p = *(ns1__processLogs*)q;
}

void ns1__getProcessLogsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessLogsResponse::result = NULL;
}

void ns1__getProcessLogsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__processLogs(soap, &this->ns1__getProcessLogsResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessLogsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessLogsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessLogsResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessLogsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessLogsResponse), "ns1:getProcessLogsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__processLogs(soap, "result", -1, &(a->ns1__getProcessLogsResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessLogsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessLogsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessLogsResponse * SOAP_FMAC4 soap_in_ns1__getProcessLogsResponse(struct soap *soap, const char *tag, ns1__getProcessLogsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessLogsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessLogsResponse, sizeof(ns1__getProcessLogsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessLogsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessLogsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__processLogs(soap, "result", &(a->ns1__getProcessLogsResponse::result), "ns1:processLogs"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessLogsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessLogsResponse, 0, sizeof(ns1__getProcessLogsResponse), 0, soap_copy_ns1__getProcessLogsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessLogsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessLogsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessLogsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessLogsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessLogsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessLogsResponse * SOAP_FMAC4 soap_get_ns1__getProcessLogsResponse(struct soap *soap, ns1__getProcessLogsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessLogsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessLogsResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessLogsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessLogsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessLogsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogsResponse);
		if (size)
			*size = sizeof(ns1__getProcessLogsResponse);
		((ns1__getProcessLogsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogsResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessLogsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessLogsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessLogsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessLogsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessLogsResponse %p -> %p\n", q, p));
	*(ns1__getProcessLogsResponse*)p = *(ns1__getProcessLogsResponse*)q;
}

void ns1__processLogFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->ns1__processLogFilter::includeSubprocessLogs);
	this->ns1__processLogFilter::processId = NULL;
}

void ns1__processLogFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__processLogFilter::includeSubprocessLogs, SOAP_TYPE_bool);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processLogFilter::processId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__processLogFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__processLogFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__processLogFilter(struct soap *soap, const char *tag, int id, const ns1__processLogFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__processLogFilter), "ns1:processLogFilter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "includeSubprocessLogs", -1, &(a->ns1__processLogFilter::includeSubprocessLogs), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__processLogFilter::processId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__processLogFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__processLogFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__processLogFilter * SOAP_FMAC4 soap_in_ns1__processLogFilter(struct soap *soap, const char *tag, ns1__processLogFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__processLogFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__processLogFilter, sizeof(ns1__processLogFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__processLogFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__processLogFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_includeSubprocessLogs1 = 1;
	size_t soap_flag_processId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_includeSubprocessLogs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "includeSubprocessLogs", &(a->ns1__processLogFilter::includeSubprocessLogs), "xsd:boolean"))
				{	soap_flag_includeSubprocessLogs1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__processLogFilter::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__processLogFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__processLogFilter, 0, sizeof(ns1__processLogFilter), 0, soap_copy_ns1__processLogFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_includeSubprocessLogs1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__processLogFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__processLogFilter);
	if (this->soap_out(soap, tag?tag:"ns1:processLogFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__processLogFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__processLogFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__processLogFilter * SOAP_FMAC4 soap_get_ns1__processLogFilter(struct soap *soap, ns1__processLogFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__processLogFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__processLogFilter * SOAP_FMAC2 soap_instantiate_ns1__processLogFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__processLogFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__processLogFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__processLogFilter);
		if (size)
			*size = sizeof(ns1__processLogFilter);
		((ns1__processLogFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processLogFilter, n);
		if (size)
			*size = n * sizeof(ns1__processLogFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__processLogFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__processLogFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__processLogFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__processLogFilter %p -> %p\n", q, p));
	*(ns1__processLogFilter*)p = *(ns1__processLogFilter*)q;
}

void ns1__getProcessLogs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessLogs::user = NULL;
	this->ns1__getProcessLogs::filter = NULL;
}

void ns1__getProcessLogs::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessLogs::user);
	soap_serialize_PointerTons1__processLogFilter(soap, &this->ns1__getProcessLogs::filter);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessLogs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessLogs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessLogs(struct soap *soap, const char *tag, int id, const ns1__getProcessLogs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessLogs), "ns1:getProcessLogs"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessLogs::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__processLogFilter(soap, "filter", -1, &(a->ns1__getProcessLogs::filter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessLogs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessLogs(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessLogs * SOAP_FMAC4 soap_in_ns1__getProcessLogs(struct soap *soap, const char *tag, ns1__getProcessLogs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessLogs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessLogs, sizeof(ns1__getProcessLogs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessLogs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessLogs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessLogs::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__processLogFilter(soap, "filter", &(a->ns1__getProcessLogs::filter), "ns1:processLogFilter"))
				{	soap_flag_filter1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessLogs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessLogs, 0, sizeof(ns1__getProcessLogs), 0, soap_copy_ns1__getProcessLogs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessLogs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessLogs);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessLogs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessLogs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessLogs(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessLogs * SOAP_FMAC4 soap_get_ns1__getProcessLogs(struct soap *soap, ns1__getProcessLogs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessLogs * SOAP_FMAC2 soap_instantiate_ns1__getProcessLogs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessLogs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessLogs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogs);
		if (size)
			*size = sizeof(ns1__getProcessLogs);
		((ns1__getProcessLogs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogs, n);
		if (size)
			*size = n * sizeof(ns1__getProcessLogs);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessLogs*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessLogs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessLogs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessLogs %p -> %p\n", q, p));
	*(ns1__getProcessLogs*)p = *(ns1__getProcessLogs*)q;
}

void ns1__assignSwimlaneResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__assignSwimlaneResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__assignSwimlaneResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignSwimlaneResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignSwimlaneResponse(struct soap *soap, const char *tag, int id, const ns1__assignSwimlaneResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:assignSwimlaneResponse");
}

void *ns1__assignSwimlaneResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignSwimlaneResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignSwimlaneResponse * SOAP_FMAC4 soap_in_ns1__assignSwimlaneResponse(struct soap *soap, const char *tag, ns1__assignSwimlaneResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__assignSwimlaneResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignSwimlaneResponse, sizeof(ns1__assignSwimlaneResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignSwimlaneResponse)
			return (ns1__assignSwimlaneResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__assignSwimlaneResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignSwimlaneResponse);
	if (this->soap_out(soap, tag?tag:"ns1:assignSwimlaneResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__assignSwimlaneResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignSwimlaneResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignSwimlaneResponse * SOAP_FMAC4 soap_get_ns1__assignSwimlaneResponse(struct soap *soap, ns1__assignSwimlaneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignSwimlaneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__assignSwimlaneResponse * SOAP_FMAC2 soap_instantiate_ns1__assignSwimlaneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignSwimlaneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignSwimlaneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__assignSwimlaneResponse);
		if (size)
			*size = sizeof(ns1__assignSwimlaneResponse);
		((ns1__assignSwimlaneResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignSwimlaneResponse, n);
		if (size)
			*size = n * sizeof(ns1__assignSwimlaneResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__assignSwimlaneResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__assignSwimlaneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignSwimlaneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignSwimlaneResponse %p -> %p\n", q, p));
	*(ns1__assignSwimlaneResponse*)p = *(ns1__assignSwimlaneResponse*)q;
}

void ns1__assignSwimlane::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__assignSwimlane::user = NULL;
	this->ns1__assignSwimlane::processId = NULL;
	this->ns1__assignSwimlane::swimlaneName = NULL;
	this->ns1__assignSwimlane::executor = NULL;
}

void ns1__assignSwimlane::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__assignSwimlane::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__assignSwimlane::processId);
	soap_serialize_wstring(soap, &this->ns1__assignSwimlane::swimlaneName);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__assignSwimlane::executor);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__assignSwimlane::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignSwimlane(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignSwimlane(struct soap *soap, const char *tag, int id, const ns1__assignSwimlane *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__assignSwimlane), "ns1:assignSwimlane"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__assignSwimlane::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__assignSwimlane::processId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "swimlaneName", -1, &(a->ns1__assignSwimlane::swimlaneName), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "executor", -1, &(a->ns1__assignSwimlane::executor), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__assignSwimlane::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignSwimlane(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignSwimlane * SOAP_FMAC4 soap_in_ns1__assignSwimlane(struct soap *soap, const char *tag, ns1__assignSwimlane *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__assignSwimlane *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignSwimlane, sizeof(ns1__assignSwimlane), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignSwimlane)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__assignSwimlane *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_swimlaneName1 = 1;
	size_t soap_flag_executor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__assignSwimlane::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__assignSwimlane::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_swimlaneName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "swimlaneName", &(a->ns1__assignSwimlane::swimlaneName), "xsd:string"))
				{	soap_flag_swimlaneName1--;
					continue;
				}
			if (soap_flag_executor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "executor", &(a->ns1__assignSwimlane::executor), "ns1:wfExecutor"))
				{	soap_flag_executor1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__assignSwimlane *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__assignSwimlane, 0, sizeof(ns1__assignSwimlane), 0, soap_copy_ns1__assignSwimlane);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__assignSwimlane::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignSwimlane);
	if (this->soap_out(soap, tag?tag:"ns1:assignSwimlane", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__assignSwimlane::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignSwimlane(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignSwimlane * SOAP_FMAC4 soap_get_ns1__assignSwimlane(struct soap *soap, ns1__assignSwimlane *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignSwimlane(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__assignSwimlane * SOAP_FMAC2 soap_instantiate_ns1__assignSwimlane(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignSwimlane(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignSwimlane, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__assignSwimlane);
		if (size)
			*size = sizeof(ns1__assignSwimlane);
		((ns1__assignSwimlane*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignSwimlane, n);
		if (size)
			*size = n * sizeof(ns1__assignSwimlane);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__assignSwimlane*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__assignSwimlane*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignSwimlane(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignSwimlane %p -> %p\n", q, p));
	*(ns1__assignSwimlane*)p = *(ns1__assignSwimlane*)q;
}

void ns1__getProcessDiagramElementsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessDiagramElementsResponse::__sizeresult = 0;
	this->ns1__getProcessDiagramElementsResponse::result = NULL;
}

void ns1__getProcessDiagramElementsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getProcessDiagramElementsResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getProcessDiagramElementsResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__graphElementPresentation(soap, this->ns1__getProcessDiagramElementsResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessDiagramElementsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessDiagramElementsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessDiagramElementsResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessDiagramElementsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessDiagramElementsResponse), "ns1:getProcessDiagramElementsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getProcessDiagramElementsResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getProcessDiagramElementsResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__graphElementPresentation(soap, "result", -1, a->ns1__getProcessDiagramElementsResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessDiagramElementsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessDiagramElementsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessDiagramElementsResponse * SOAP_FMAC4 soap_in_ns1__getProcessDiagramElementsResponse(struct soap *soap, const char *tag, ns1__getProcessDiagramElementsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessDiagramElementsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessDiagramElementsResponse, sizeof(ns1__getProcessDiagramElementsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessDiagramElementsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessDiagramElementsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getProcessDiagramElementsResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getProcessDiagramElementsResponse::result = (ns1__graphElementPresentation **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__graphElementPresentation *));
					if (a->ns1__getProcessDiagramElementsResponse::result == NULL)
						return NULL;
					*a->ns1__getProcessDiagramElementsResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__graphElementPresentation(soap, "result", a->ns1__getProcessDiagramElementsResponse::result, "ns1:graphElementPresentation"))
				{	a->ns1__getProcessDiagramElementsResponse::__sizeresult++;
					a->ns1__getProcessDiagramElementsResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getProcessDiagramElementsResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getProcessDiagramElementsResponse::__sizeresult)
			a->ns1__getProcessDiagramElementsResponse::result = (ns1__graphElementPresentation **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getProcessDiagramElementsResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessDiagramElementsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessDiagramElementsResponse, 0, sizeof(ns1__getProcessDiagramElementsResponse), 0, soap_copy_ns1__getProcessDiagramElementsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessDiagramElementsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessDiagramElementsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessDiagramElementsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessDiagramElementsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessDiagramElementsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessDiagramElementsResponse * SOAP_FMAC4 soap_get_ns1__getProcessDiagramElementsResponse(struct soap *soap, ns1__getProcessDiagramElementsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessDiagramElementsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessDiagramElementsResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessDiagramElementsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessDiagramElementsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessDiagramElementsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagramElementsResponse);
		if (size)
			*size = sizeof(ns1__getProcessDiagramElementsResponse);
		((ns1__getProcessDiagramElementsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagramElementsResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessDiagramElementsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessDiagramElementsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessDiagramElementsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessDiagramElementsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessDiagramElementsResponse %p -> %p\n", q, p));
	*(ns1__getProcessDiagramElementsResponse*)p = *(ns1__getProcessDiagramElementsResponse*)q;
}

void ns1__getProcessDiagramElements::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessDiagramElements::user = NULL;
	this->ns1__getProcessDiagramElements::processId = NULL;
	this->ns1__getProcessDiagramElements::subprocessId = NULL;
}

void ns1__getProcessDiagramElements::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessDiagramElements::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessDiagramElements::processId);
	soap_serialize_wstring(soap, &this->ns1__getProcessDiagramElements::subprocessId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessDiagramElements::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessDiagramElements(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessDiagramElements(struct soap *soap, const char *tag, int id, const ns1__getProcessDiagramElements *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessDiagramElements), "ns1:getProcessDiagramElements"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessDiagramElements::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getProcessDiagramElements::processId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "subprocessId", -1, &(a->ns1__getProcessDiagramElements::subprocessId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessDiagramElements::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessDiagramElements(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessDiagramElements * SOAP_FMAC4 soap_in_ns1__getProcessDiagramElements(struct soap *soap, const char *tag, ns1__getProcessDiagramElements *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessDiagramElements *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessDiagramElements, sizeof(ns1__getProcessDiagramElements), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessDiagramElements)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessDiagramElements *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_subprocessId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessDiagramElements::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getProcessDiagramElements::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_subprocessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "subprocessId", &(a->ns1__getProcessDiagramElements::subprocessId), "xsd:string"))
				{	soap_flag_subprocessId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessDiagramElements *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessDiagramElements, 0, sizeof(ns1__getProcessDiagramElements), 0, soap_copy_ns1__getProcessDiagramElements);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessDiagramElements::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessDiagramElements);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessDiagramElements", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessDiagramElements::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessDiagramElements(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessDiagramElements * SOAP_FMAC4 soap_get_ns1__getProcessDiagramElements(struct soap *soap, ns1__getProcessDiagramElements *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessDiagramElements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessDiagramElements * SOAP_FMAC2 soap_instantiate_ns1__getProcessDiagramElements(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessDiagramElements(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessDiagramElements, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagramElements);
		if (size)
			*size = sizeof(ns1__getProcessDiagramElements);
		((ns1__getProcessDiagramElements*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagramElements, n);
		if (size)
			*size = n * sizeof(ns1__getProcessDiagramElements);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessDiagramElements*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessDiagramElements*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessDiagramElements(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessDiagramElements %p -> %p\n", q, p));
	*(ns1__getProcessDiagramElements*)p = *(ns1__getProcessDiagramElements*)q;
}

void ns1__getProcessHistoryDiagramResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessHistoryDiagramResponse::result = NULL;
}

void ns1__getProcessHistoryDiagramResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__getProcessHistoryDiagramResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessHistoryDiagramResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessHistoryDiagramResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessHistoryDiagramResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessHistoryDiagramResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse), "ns1:getProcessHistoryDiagramResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__base64Binary(soap, "result", -1, &(a->ns1__getProcessHistoryDiagramResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessHistoryDiagramResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessHistoryDiagramResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramResponse * SOAP_FMAC4 soap_in_ns1__getProcessHistoryDiagramResponse(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagramResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessHistoryDiagramResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse, sizeof(ns1__getProcessHistoryDiagramResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessHistoryDiagramResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessHistoryDiagramResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "result", &(a->ns1__getProcessHistoryDiagramResponse::result), "xsd:base64Binary"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessHistoryDiagramResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse, 0, sizeof(ns1__getProcessHistoryDiagramResponse), 0, soap_copy_ns1__getProcessHistoryDiagramResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessHistoryDiagramResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessHistoryDiagramResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessHistoryDiagramResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessHistoryDiagramResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramResponse * SOAP_FMAC4 soap_get_ns1__getProcessHistoryDiagramResponse(struct soap *soap, ns1__getProcessHistoryDiagramResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessHistoryDiagramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessHistoryDiagramResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessHistoryDiagramResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessHistoryDiagramResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagramResponse);
		if (size)
			*size = sizeof(ns1__getProcessHistoryDiagramResponse);
		((ns1__getProcessHistoryDiagramResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagramResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessHistoryDiagramResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessHistoryDiagramResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessHistoryDiagramResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessHistoryDiagramResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessHistoryDiagramResponse %p -> %p\n", q, p));
	*(ns1__getProcessHistoryDiagramResponse*)p = *(ns1__getProcessHistoryDiagramResponse*)q;
}

void ns1__getProcessHistoryDiagram::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessHistoryDiagram::user = NULL;
	this->ns1__getProcessHistoryDiagram::processId = NULL;
	this->ns1__getProcessHistoryDiagram::taskId = NULL;
}

void ns1__getProcessHistoryDiagram::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessHistoryDiagram::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessHistoryDiagram::processId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessHistoryDiagram::taskId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessHistoryDiagram::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessHistoryDiagram(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessHistoryDiagram(struct soap *soap, const char *tag, int id, const ns1__getProcessHistoryDiagram *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessHistoryDiagram), "ns1:getProcessHistoryDiagram"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessHistoryDiagram::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getProcessHistoryDiagram::processId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__getProcessHistoryDiagram::taskId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessHistoryDiagram::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessHistoryDiagram(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagram * SOAP_FMAC4 soap_in_ns1__getProcessHistoryDiagram(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagram *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessHistoryDiagram *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessHistoryDiagram, sizeof(ns1__getProcessHistoryDiagram), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessHistoryDiagram)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessHistoryDiagram *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessHistoryDiagram::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getProcessHistoryDiagram::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__getProcessHistoryDiagram::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessHistoryDiagram *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessHistoryDiagram, 0, sizeof(ns1__getProcessHistoryDiagram), 0, soap_copy_ns1__getProcessHistoryDiagram);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessHistoryDiagram::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessHistoryDiagram);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessHistoryDiagram", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessHistoryDiagram::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessHistoryDiagram(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagram * SOAP_FMAC4 soap_get_ns1__getProcessHistoryDiagram(struct soap *soap, ns1__getProcessHistoryDiagram *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessHistoryDiagram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessHistoryDiagram * SOAP_FMAC2 soap_instantiate_ns1__getProcessHistoryDiagram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessHistoryDiagram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessHistoryDiagram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagram);
		if (size)
			*size = sizeof(ns1__getProcessHistoryDiagram);
		((ns1__getProcessHistoryDiagram*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagram, n);
		if (size)
			*size = n * sizeof(ns1__getProcessHistoryDiagram);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessHistoryDiagram*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessHistoryDiagram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessHistoryDiagram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessHistoryDiagram %p -> %p\n", q, p));
	*(ns1__getProcessHistoryDiagram*)p = *(ns1__getProcessHistoryDiagram*)q;
}

void ns1__getProcessDiagramResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessDiagramResponse::result = NULL;
}

void ns1__getProcessDiagramResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__getProcessDiagramResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessDiagramResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessDiagramResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessDiagramResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessDiagramResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessDiagramResponse), "ns1:getProcessDiagramResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__base64Binary(soap, "result", -1, &(a->ns1__getProcessDiagramResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessDiagramResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessDiagramResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessDiagramResponse * SOAP_FMAC4 soap_in_ns1__getProcessDiagramResponse(struct soap *soap, const char *tag, ns1__getProcessDiagramResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessDiagramResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessDiagramResponse, sizeof(ns1__getProcessDiagramResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessDiagramResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessDiagramResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "result", &(a->ns1__getProcessDiagramResponse::result), "xsd:base64Binary"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessDiagramResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessDiagramResponse, 0, sizeof(ns1__getProcessDiagramResponse), 0, soap_copy_ns1__getProcessDiagramResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessDiagramResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessDiagramResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessDiagramResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessDiagramResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessDiagramResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessDiagramResponse * SOAP_FMAC4 soap_get_ns1__getProcessDiagramResponse(struct soap *soap, ns1__getProcessDiagramResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessDiagramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessDiagramResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessDiagramResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessDiagramResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessDiagramResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagramResponse);
		if (size)
			*size = sizeof(ns1__getProcessDiagramResponse);
		((ns1__getProcessDiagramResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagramResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessDiagramResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessDiagramResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessDiagramResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessDiagramResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessDiagramResponse %p -> %p\n", q, p));
	*(ns1__getProcessDiagramResponse*)p = *(ns1__getProcessDiagramResponse*)q;
}

void ns1__getProcessDiagram::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessDiagram::user = NULL;
	this->ns1__getProcessDiagram::processId = NULL;
	this->ns1__getProcessDiagram::taskId = NULL;
	this->ns1__getProcessDiagram::childProcessId = NULL;
	this->ns1__getProcessDiagram::subprocessId = NULL;
}

void ns1__getProcessDiagram::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessDiagram::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessDiagram::processId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessDiagram::taskId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessDiagram::childProcessId);
	soap_serialize_wstring(soap, &this->ns1__getProcessDiagram::subprocessId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessDiagram::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessDiagram(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessDiagram(struct soap *soap, const char *tag, int id, const ns1__getProcessDiagram *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessDiagram), "ns1:getProcessDiagram"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessDiagram::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getProcessDiagram::processId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__getProcessDiagram::taskId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "childProcessId", -1, &(a->ns1__getProcessDiagram::childProcessId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "subprocessId", -1, &(a->ns1__getProcessDiagram::subprocessId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessDiagram::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessDiagram(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessDiagram * SOAP_FMAC4 soap_in_ns1__getProcessDiagram(struct soap *soap, const char *tag, ns1__getProcessDiagram *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessDiagram *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessDiagram, sizeof(ns1__getProcessDiagram), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessDiagram)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessDiagram *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_taskId1 = 1;
	size_t soap_flag_childProcessId1 = 1;
	size_t soap_flag_subprocessId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessDiagram::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getProcessDiagram::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__getProcessDiagram::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag_childProcessId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "childProcessId", &(a->ns1__getProcessDiagram::childProcessId), "xsd:long"))
				{	soap_flag_childProcessId1--;
					continue;
				}
			if (soap_flag_subprocessId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "subprocessId", &(a->ns1__getProcessDiagram::subprocessId), "xsd:string"))
				{	soap_flag_subprocessId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessDiagram *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessDiagram, 0, sizeof(ns1__getProcessDiagram), 0, soap_copy_ns1__getProcessDiagram);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessDiagram::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessDiagram);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessDiagram", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessDiagram::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessDiagram(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessDiagram * SOAP_FMAC4 soap_get_ns1__getProcessDiagram(struct soap *soap, ns1__getProcessDiagram *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessDiagram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessDiagram * SOAP_FMAC2 soap_instantiate_ns1__getProcessDiagram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessDiagram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessDiagram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagram);
		if (size)
			*size = sizeof(ns1__getProcessDiagram);
		((ns1__getProcessDiagram*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagram, n);
		if (size)
			*size = n * sizeof(ns1__getProcessDiagram);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessDiagram*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessDiagram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessDiagram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessDiagram %p -> %p\n", q, p));
	*(ns1__getProcessDiagram*)p = *(ns1__getProcessDiagram*)q;
}

void ns1__getProcessTasksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessTasksResponse::__sizeresult = 0;
	this->ns1__getProcessTasksResponse::result = NULL;
}

void ns1__getProcessTasksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getProcessTasksResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getProcessTasksResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfTask(soap, this->ns1__getProcessTasksResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessTasksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessTasksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessTasksResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessTasksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessTasksResponse), "ns1:getProcessTasksResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getProcessTasksResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getProcessTasksResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfTask(soap, "result", -1, a->ns1__getProcessTasksResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessTasksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessTasksResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessTasksResponse * SOAP_FMAC4 soap_in_ns1__getProcessTasksResponse(struct soap *soap, const char *tag, ns1__getProcessTasksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessTasksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessTasksResponse, sizeof(ns1__getProcessTasksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessTasksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessTasksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getProcessTasksResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getProcessTasksResponse::result = (ns1__wfTask **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfTask *));
					if (a->ns1__getProcessTasksResponse::result == NULL)
						return NULL;
					*a->ns1__getProcessTasksResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfTask(soap, "result", a->ns1__getProcessTasksResponse::result, "ns1:wfTask"))
				{	a->ns1__getProcessTasksResponse::__sizeresult++;
					a->ns1__getProcessTasksResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getProcessTasksResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getProcessTasksResponse::__sizeresult)
			a->ns1__getProcessTasksResponse::result = (ns1__wfTask **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getProcessTasksResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessTasksResponse, 0, sizeof(ns1__getProcessTasksResponse), 0, soap_copy_ns1__getProcessTasksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessTasksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessTasksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessTasksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessTasksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessTasksResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessTasksResponse * SOAP_FMAC4 soap_get_ns1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessTasksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessTasksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasksResponse);
		if (size)
			*size = sizeof(ns1__getProcessTasksResponse);
		((ns1__getProcessTasksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasksResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessTasksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessTasksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessTasksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessTasksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessTasksResponse %p -> %p\n", q, p));
	*(ns1__getProcessTasksResponse*)p = *(ns1__getProcessTasksResponse*)q;
}

void ns1__getProcessTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessTasks::user = NULL;
	this->ns1__getProcessTasks::processId = NULL;
}

void ns1__getProcessTasks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessTasks::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessTasks::processId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessTasks(struct soap *soap, const char *tag, int id, const ns1__getProcessTasks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessTasks), "ns1:getProcessTasks"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessTasks::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getProcessTasks::processId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessTasks * SOAP_FMAC4 soap_in_ns1__getProcessTasks(struct soap *soap, const char *tag, ns1__getProcessTasks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessTasks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessTasks, sizeof(ns1__getProcessTasks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessTasks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessTasks *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessTasks::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getProcessTasks::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessTasks, 0, sizeof(ns1__getProcessTasks), 0, soap_copy_ns1__getProcessTasks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessTasks);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessTasks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessTasks * SOAP_FMAC4 soap_get_ns1__getProcessTasks(struct soap *soap, ns1__getProcessTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessTasks * SOAP_FMAC2 soap_instantiate_ns1__getProcessTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasks);
		if (size)
			*size = sizeof(ns1__getProcessTasks);
		((ns1__getProcessTasks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasks, n);
		if (size)
			*size = n * sizeof(ns1__getProcessTasks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessTasks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessTasks %p -> %p\n", q, p));
	*(ns1__getProcessTasks*)p = *(ns1__getProcessTasks*)q;
}

void ns1__cancelProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__cancelProcessResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__cancelProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cancelProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelProcessResponse(struct soap *soap, const char *tag, int id, const ns1__cancelProcessResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:cancelProcessResponse");
}

void *ns1__cancelProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cancelProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cancelProcessResponse * SOAP_FMAC4 soap_in_ns1__cancelProcessResponse(struct soap *soap, const char *tag, ns1__cancelProcessResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__cancelProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelProcessResponse, sizeof(ns1__cancelProcessResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cancelProcessResponse)
			return (ns1__cancelProcessResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__cancelProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__cancelProcessResponse);
	if (this->soap_out(soap, tag?tag:"ns1:cancelProcessResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cancelProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cancelProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cancelProcessResponse * SOAP_FMAC4 soap_get_ns1__cancelProcessResponse(struct soap *soap, ns1__cancelProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cancelProcessResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cancelProcessResponse);
		if (size)
			*size = sizeof(ns1__cancelProcessResponse);
		((ns1__cancelProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cancelProcessResponse, n);
		if (size)
			*size = n * sizeof(ns1__cancelProcessResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cancelProcessResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cancelProcessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cancelProcessResponse %p -> %p\n", q, p));
	*(ns1__cancelProcessResponse*)p = *(ns1__cancelProcessResponse*)q;
}

void ns1__cancelProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__cancelProcess::user = NULL;
	this->ns1__cancelProcess::processId = NULL;
}

void ns1__cancelProcess::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__cancelProcess::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__cancelProcess::processId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__cancelProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cancelProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelProcess(struct soap *soap, const char *tag, int id, const ns1__cancelProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelProcess), "ns1:cancelProcess"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__cancelProcess::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__cancelProcess::processId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__cancelProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cancelProcess(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cancelProcess * SOAP_FMAC4 soap_in_ns1__cancelProcess(struct soap *soap, const char *tag, ns1__cancelProcess *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cancelProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelProcess, sizeof(ns1__cancelProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cancelProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cancelProcess *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__cancelProcess::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__cancelProcess::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cancelProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelProcess, 0, sizeof(ns1__cancelProcess), 0, soap_copy_ns1__cancelProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__cancelProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__cancelProcess);
	if (this->soap_out(soap, tag?tag:"ns1:cancelProcess", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cancelProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cancelProcess(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cancelProcess * SOAP_FMAC4 soap_get_ns1__cancelProcess(struct soap *soap, ns1__cancelProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cancelProcess * SOAP_FMAC2 soap_instantiate_ns1__cancelProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cancelProcess);
		if (size)
			*size = sizeof(ns1__cancelProcess);
		((ns1__cancelProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cancelProcess, n);
		if (size)
			*size = n * sizeof(ns1__cancelProcess);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__cancelProcess*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__cancelProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cancelProcess %p -> %p\n", q, p));
	*(ns1__cancelProcess*)p = *(ns1__cancelProcess*)q;
}

void ns1__getSubprocessesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getSubprocessesResponse::__sizeresult = 0;
	this->ns1__getSubprocessesResponse::result = NULL;
}

void ns1__getSubprocessesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getSubprocessesResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getSubprocessesResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfProcess(soap, this->ns1__getSubprocessesResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSubprocessesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSubprocessesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSubprocessesResponse(struct soap *soap, const char *tag, int id, const ns1__getSubprocessesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSubprocessesResponse), "ns1:getSubprocessesResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getSubprocessesResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getSubprocessesResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfProcess(soap, "result", -1, a->ns1__getSubprocessesResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getSubprocessesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSubprocessesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSubprocessesResponse * SOAP_FMAC4 soap_in_ns1__getSubprocessesResponse(struct soap *soap, const char *tag, ns1__getSubprocessesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSubprocessesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSubprocessesResponse, sizeof(ns1__getSubprocessesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSubprocessesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSubprocessesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getSubprocessesResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getSubprocessesResponse::result = (ns1__wfProcess **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfProcess *));
					if (a->ns1__getSubprocessesResponse::result == NULL)
						return NULL;
					*a->ns1__getSubprocessesResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfProcess(soap, "result", a->ns1__getSubprocessesResponse::result, "ns1:wfProcess"))
				{	a->ns1__getSubprocessesResponse::__sizeresult++;
					a->ns1__getSubprocessesResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getSubprocessesResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getSubprocessesResponse::__sizeresult)
			a->ns1__getSubprocessesResponse::result = (ns1__wfProcess **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getSubprocessesResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSubprocessesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSubprocessesResponse, 0, sizeof(ns1__getSubprocessesResponse), 0, soap_copy_ns1__getSubprocessesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getSubprocessesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSubprocessesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getSubprocessesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSubprocessesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSubprocessesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSubprocessesResponse * SOAP_FMAC4 soap_get_ns1__getSubprocessesResponse(struct soap *soap, ns1__getSubprocessesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSubprocessesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSubprocessesResponse * SOAP_FMAC2 soap_instantiate_ns1__getSubprocessesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSubprocessesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSubprocessesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSubprocessesResponse);
		if (size)
			*size = sizeof(ns1__getSubprocessesResponse);
		((ns1__getSubprocessesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSubprocessesResponse, n);
		if (size)
			*size = n * sizeof(ns1__getSubprocessesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSubprocessesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSubprocessesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSubprocessesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSubprocessesResponse %p -> %p\n", q, p));
	*(ns1__getSubprocessesResponse*)p = *(ns1__getSubprocessesResponse*)q;
}

void ns1__getSubprocesses::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getSubprocesses::user = NULL;
	this->ns1__getSubprocesses::id = NULL;
	soap_default_bool(soap, &this->ns1__getSubprocesses::recursive);
}

void ns1__getSubprocesses::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getSubprocesses::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getSubprocesses::id);
	soap_embedded(soap, &this->ns1__getSubprocesses::recursive, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getSubprocesses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getSubprocesses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSubprocesses(struct soap *soap, const char *tag, int id, const ns1__getSubprocesses *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSubprocesses), "ns1:getSubprocesses"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getSubprocesses::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__getSubprocesses::id), ""))
		return soap->error;
	if (soap_out_bool(soap, "recursive", -1, &(a->ns1__getSubprocesses::recursive), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getSubprocesses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getSubprocesses(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getSubprocesses * SOAP_FMAC4 soap_in_ns1__getSubprocesses(struct soap *soap, const char *tag, ns1__getSubprocesses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getSubprocesses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSubprocesses, sizeof(ns1__getSubprocesses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getSubprocesses)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getSubprocesses *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_recursive1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getSubprocesses::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__getSubprocesses::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_recursive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "recursive", &(a->ns1__getSubprocesses::recursive), "xsd:boolean"))
				{	soap_flag_recursive1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getSubprocesses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSubprocesses, 0, sizeof(ns1__getSubprocesses), 0, soap_copy_ns1__getSubprocesses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recursive1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getSubprocesses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getSubprocesses);
	if (this->soap_out(soap, tag?tag:"ns1:getSubprocesses", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getSubprocesses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getSubprocesses(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getSubprocesses * SOAP_FMAC4 soap_get_ns1__getSubprocesses(struct soap *soap, ns1__getSubprocesses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSubprocesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getSubprocesses * SOAP_FMAC2 soap_instantiate_ns1__getSubprocesses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSubprocesses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSubprocesses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getSubprocesses);
		if (size)
			*size = sizeof(ns1__getSubprocesses);
		((ns1__getSubprocesses*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSubprocesses, n);
		if (size)
			*size = n * sizeof(ns1__getSubprocesses);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getSubprocesses*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getSubprocesses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSubprocesses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getSubprocesses %p -> %p\n", q, p));
	*(ns1__getSubprocesses*)p = *(ns1__getSubprocesses*)q;
}

void ns1__getParentProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getParentProcessResponse::result = NULL;
}

void ns1__getParentProcessResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__wfProcess(soap, &this->ns1__getParentProcessResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getParentProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getParentProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getParentProcessResponse(struct soap *soap, const char *tag, int id, const ns1__getParentProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getParentProcessResponse), "ns1:getParentProcessResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__wfProcess(soap, "result", -1, &(a->ns1__getParentProcessResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getParentProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getParentProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getParentProcessResponse * SOAP_FMAC4 soap_in_ns1__getParentProcessResponse(struct soap *soap, const char *tag, ns1__getParentProcessResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getParentProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getParentProcessResponse, sizeof(ns1__getParentProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getParentProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getParentProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfProcess(soap, "result", &(a->ns1__getParentProcessResponse::result), "ns1:wfProcess"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getParentProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getParentProcessResponse, 0, sizeof(ns1__getParentProcessResponse), 0, soap_copy_ns1__getParentProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getParentProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getParentProcessResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getParentProcessResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getParentProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getParentProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getParentProcessResponse * SOAP_FMAC4 soap_get_ns1__getParentProcessResponse(struct soap *soap, ns1__getParentProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getParentProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getParentProcessResponse * SOAP_FMAC2 soap_instantiate_ns1__getParentProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getParentProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getParentProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getParentProcessResponse);
		if (size)
			*size = sizeof(ns1__getParentProcessResponse);
		((ns1__getParentProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getParentProcessResponse, n);
		if (size)
			*size = n * sizeof(ns1__getParentProcessResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getParentProcessResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getParentProcessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getParentProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getParentProcessResponse %p -> %p\n", q, p));
	*(ns1__getParentProcessResponse*)p = *(ns1__getParentProcessResponse*)q;
}

void ns1__getParentProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getParentProcess::user = NULL;
	this->ns1__getParentProcess::id = NULL;
}

void ns1__getParentProcess::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getParentProcess::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getParentProcess::id);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getParentProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getParentProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getParentProcess(struct soap *soap, const char *tag, int id, const ns1__getParentProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getParentProcess), "ns1:getParentProcess"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getParentProcess::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__getParentProcess::id), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getParentProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getParentProcess(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getParentProcess * SOAP_FMAC4 soap_in_ns1__getParentProcess(struct soap *soap, const char *tag, ns1__getParentProcess *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getParentProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getParentProcess, sizeof(ns1__getParentProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getParentProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getParentProcess *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getParentProcess::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__getParentProcess::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getParentProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getParentProcess, 0, sizeof(ns1__getParentProcess), 0, soap_copy_ns1__getParentProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getParentProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getParentProcess);
	if (this->soap_out(soap, tag?tag:"ns1:getParentProcess", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getParentProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getParentProcess(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getParentProcess * SOAP_FMAC4 soap_get_ns1__getParentProcess(struct soap *soap, ns1__getParentProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getParentProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getParentProcess * SOAP_FMAC2 soap_instantiate_ns1__getParentProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getParentProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getParentProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getParentProcess);
		if (size)
			*size = sizeof(ns1__getParentProcess);
		((ns1__getParentProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getParentProcess, n);
		if (size)
			*size = n * sizeof(ns1__getParentProcess);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getParentProcess*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getParentProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getParentProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getParentProcess %p -> %p\n", q, p));
	*(ns1__getParentProcess*)p = *(ns1__getParentProcess*)q;
}

void ns1__getProcessesByFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessesByFilterResponse::__sizeresult = 0;
	this->ns1__getProcessesByFilterResponse::result = NULL;
}

void ns1__getProcessesByFilterResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getProcessesByFilterResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getProcessesByFilterResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfProcess(soap, this->ns1__getProcessesByFilterResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessesByFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessesByFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessesByFilterResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessesByFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessesByFilterResponse), "ns1:getProcessesByFilterResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getProcessesByFilterResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getProcessesByFilterResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfProcess(soap, "result", -1, a->ns1__getProcessesByFilterResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessesByFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessesByFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessesByFilterResponse * SOAP_FMAC4 soap_in_ns1__getProcessesByFilterResponse(struct soap *soap, const char *tag, ns1__getProcessesByFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessesByFilterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessesByFilterResponse, sizeof(ns1__getProcessesByFilterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessesByFilterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessesByFilterResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getProcessesByFilterResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getProcessesByFilterResponse::result = (ns1__wfProcess **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfProcess *));
					if (a->ns1__getProcessesByFilterResponse::result == NULL)
						return NULL;
					*a->ns1__getProcessesByFilterResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfProcess(soap, "result", a->ns1__getProcessesByFilterResponse::result, "ns1:wfProcess"))
				{	a->ns1__getProcessesByFilterResponse::__sizeresult++;
					a->ns1__getProcessesByFilterResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getProcessesByFilterResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getProcessesByFilterResponse::__sizeresult)
			a->ns1__getProcessesByFilterResponse::result = (ns1__wfProcess **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getProcessesByFilterResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessesByFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessesByFilterResponse, 0, sizeof(ns1__getProcessesByFilterResponse), 0, soap_copy_ns1__getProcessesByFilterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessesByFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessesByFilterResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessesByFilterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessesByFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessesByFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessesByFilterResponse * SOAP_FMAC4 soap_get_ns1__getProcessesByFilterResponse(struct soap *soap, ns1__getProcessesByFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessesByFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessesByFilterResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessesByFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessesByFilterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessesByFilterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesByFilterResponse);
		if (size)
			*size = sizeof(ns1__getProcessesByFilterResponse);
		((ns1__getProcessesByFilterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesByFilterResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessesByFilterResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessesByFilterResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessesByFilterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessesByFilterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessesByFilterResponse %p -> %p\n", q, p));
	*(ns1__getProcessesByFilterResponse*)p = *(ns1__getProcessesByFilterResponse*)q;
}

void ns1__processFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__processFilter::definitionName = NULL;
	this->ns1__processFilter::definitionVersion = NULL;
	this->ns1__processFilter::endDateFrom = NULL;
	this->ns1__processFilter::endDateTo = NULL;
	this->ns1__processFilter::finishedOnly = NULL;
	this->ns1__processFilter::id = NULL;
	this->ns1__processFilter::idFrom = NULL;
	this->ns1__processFilter::idTo = NULL;
	this->ns1__processFilter::startDateFrom = NULL;
	this->ns1__processFilter::startDateTo = NULL;
}

void ns1__processFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__processFilter::definitionName);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processFilter::definitionVersion);
	soap_serialize_PointerTotime(soap, &this->ns1__processFilter::endDateFrom);
	soap_serialize_PointerTotime(soap, &this->ns1__processFilter::endDateTo);
	soap_serialize_PointerTobool(soap, &this->ns1__processFilter::finishedOnly);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processFilter::id);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processFilter::idFrom);
	soap_serialize_PointerToLONG64(soap, &this->ns1__processFilter::idTo);
	soap_serialize_PointerTotime(soap, &this->ns1__processFilter::startDateFrom);
	soap_serialize_PointerTotime(soap, &this->ns1__processFilter::startDateTo);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__processFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__processFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__processFilter(struct soap *soap, const char *tag, int id, const ns1__processFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__processFilter), "ns1:processFilter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "definitionName", -1, &(a->ns1__processFilter::definitionName), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "definitionVersion", -1, &(a->ns1__processFilter::definitionVersion), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endDateFrom", -1, &(a->ns1__processFilter::endDateFrom), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endDateTo", -1, &(a->ns1__processFilter::endDateTo), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "finishedOnly", -1, &(a->ns1__processFilter::finishedOnly), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__processFilter::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "idFrom", -1, &(a->ns1__processFilter::idFrom), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "idTo", -1, &(a->ns1__processFilter::idTo), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startDateFrom", -1, &(a->ns1__processFilter::startDateFrom), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startDateTo", -1, &(a->ns1__processFilter::startDateTo), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__processFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__processFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__processFilter * SOAP_FMAC4 soap_in_ns1__processFilter(struct soap *soap, const char *tag, ns1__processFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__processFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__processFilter, sizeof(ns1__processFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__processFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__processFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_definitionName1 = 1;
	size_t soap_flag_definitionVersion1 = 1;
	size_t soap_flag_endDateFrom1 = 1;
	size_t soap_flag_endDateTo1 = 1;
	size_t soap_flag_finishedOnly1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_idFrom1 = 1;
	size_t soap_flag_idTo1 = 1;
	size_t soap_flag_startDateFrom1 = 1;
	size_t soap_flag_startDateTo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_definitionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "definitionName", &(a->ns1__processFilter::definitionName), "xsd:string"))
				{	soap_flag_definitionName1--;
					continue;
				}
			if (soap_flag_definitionVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "definitionVersion", &(a->ns1__processFilter::definitionVersion), "xsd:long"))
				{	soap_flag_definitionVersion1--;
					continue;
				}
			if (soap_flag_endDateFrom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endDateFrom", &(a->ns1__processFilter::endDateFrom), "xsd:dateTime"))
				{	soap_flag_endDateFrom1--;
					continue;
				}
			if (soap_flag_endDateTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endDateTo", &(a->ns1__processFilter::endDateTo), "xsd:dateTime"))
				{	soap_flag_endDateTo1--;
					continue;
				}
			if (soap_flag_finishedOnly1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "finishedOnly", &(a->ns1__processFilter::finishedOnly), "xsd:boolean"))
				{	soap_flag_finishedOnly1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__processFilter::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_idFrom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "idFrom", &(a->ns1__processFilter::idFrom), "xsd:long"))
				{	soap_flag_idFrom1--;
					continue;
				}
			if (soap_flag_idTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "idTo", &(a->ns1__processFilter::idTo), "xsd:long"))
				{	soap_flag_idTo1--;
					continue;
				}
			if (soap_flag_startDateFrom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startDateFrom", &(a->ns1__processFilter::startDateFrom), "xsd:dateTime"))
				{	soap_flag_startDateFrom1--;
					continue;
				}
			if (soap_flag_startDateTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startDateTo", &(a->ns1__processFilter::startDateTo), "xsd:dateTime"))
				{	soap_flag_startDateTo1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__processFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__processFilter, 0, sizeof(ns1__processFilter), 0, soap_copy_ns1__processFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__processFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__processFilter);
	if (this->soap_out(soap, tag?tag:"ns1:processFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__processFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__processFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__processFilter * SOAP_FMAC4 soap_get_ns1__processFilter(struct soap *soap, ns1__processFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__processFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__processFilter * SOAP_FMAC2 soap_instantiate_ns1__processFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__processFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__processFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__processFilter);
		if (size)
			*size = sizeof(ns1__processFilter);
		((ns1__processFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processFilter, n);
		if (size)
			*size = n * sizeof(ns1__processFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__processFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__processFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__processFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__processFilter %p -> %p\n", q, p));
	*(ns1__processFilter*)p = *(ns1__processFilter*)q;
}

void ns1__getProcessesByFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessesByFilter::user = NULL;
	this->ns1__getProcessesByFilter::filter = NULL;
}

void ns1__getProcessesByFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessesByFilter::user);
	soap_serialize_PointerTons1__processFilter(soap, &this->ns1__getProcessesByFilter::filter);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessesByFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessesByFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessesByFilter(struct soap *soap, const char *tag, int id, const ns1__getProcessesByFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessesByFilter), "ns1:getProcessesByFilter"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessesByFilter::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__processFilter(soap, "filter", -1, &(a->ns1__getProcessesByFilter::filter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessesByFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessesByFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessesByFilter * SOAP_FMAC4 soap_in_ns1__getProcessesByFilter(struct soap *soap, const char *tag, ns1__getProcessesByFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessesByFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessesByFilter, sizeof(ns1__getProcessesByFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessesByFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessesByFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessesByFilter::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__processFilter(soap, "filter", &(a->ns1__getProcessesByFilter::filter), "ns1:processFilter"))
				{	soap_flag_filter1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessesByFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessesByFilter, 0, sizeof(ns1__getProcessesByFilter), 0, soap_copy_ns1__getProcessesByFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessesByFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessesByFilter);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessesByFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessesByFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessesByFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessesByFilter * SOAP_FMAC4 soap_get_ns1__getProcessesByFilter(struct soap *soap, ns1__getProcessesByFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessesByFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessesByFilter * SOAP_FMAC2 soap_instantiate_ns1__getProcessesByFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessesByFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessesByFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesByFilter);
		if (size)
			*size = sizeof(ns1__getProcessesByFilter);
		((ns1__getProcessesByFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesByFilter, n);
		if (size)
			*size = n * sizeof(ns1__getProcessesByFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessesByFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessesByFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessesByFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessesByFilter %p -> %p\n", q, p));
	*(ns1__getProcessesByFilter*)p = *(ns1__getProcessesByFilter*)q;
}

void ns1__getProcessesCountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->ns1__getProcessesCountResponse::result);
}

void ns1__getProcessesCountResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__getProcessesCountResponse::result, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessesCountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessesCountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessesCountResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessesCountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessesCountResponse), "ns1:getProcessesCountResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "result", -1, &(a->ns1__getProcessesCountResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessesCountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessesCountResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessesCountResponse * SOAP_FMAC4 soap_in_ns1__getProcessesCountResponse(struct soap *soap, const char *tag, ns1__getProcessesCountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessesCountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessesCountResponse, sizeof(ns1__getProcessesCountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessesCountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessesCountResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &(a->ns1__getProcessesCountResponse::result), "xsd:int"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessesCountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessesCountResponse, 0, sizeof(ns1__getProcessesCountResponse), 0, soap_copy_ns1__getProcessesCountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getProcessesCountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessesCountResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessesCountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessesCountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessesCountResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessesCountResponse * SOAP_FMAC4 soap_get_ns1__getProcessesCountResponse(struct soap *soap, ns1__getProcessesCountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessesCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessesCountResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessesCountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessesCountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessesCountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesCountResponse);
		if (size)
			*size = sizeof(ns1__getProcessesCountResponse);
		((ns1__getProcessesCountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesCountResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessesCountResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessesCountResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessesCountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessesCountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessesCountResponse %p -> %p\n", q, p));
	*(ns1__getProcessesCountResponse*)p = *(ns1__getProcessesCountResponse*)q;
}

void ns1__batchPresentation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__batchPresentation::id = NULL;
	this->ns1__batchPresentation::version = NULL;
	this->ns1__batchPresentation::type = NULL;
	this->ns1__batchPresentation::category = NULL;
	this->ns1__batchPresentation::name = NULL;
	soap_default_bool(soap, &this->ns1__batchPresentation::active);
	soap_default_int(soap, &this->ns1__batchPresentation::rangeSize);
	soap_default_int(soap, &this->ns1__batchPresentation::pageNumber);
	this->ns1__batchPresentation::fieldsData = NULL;
	this->ns1__batchPresentation::createDate = NULL;
}

void ns1__batchPresentation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__batchPresentation::id);
	soap_serialize_PointerToLONG64(soap, &this->ns1__batchPresentation::version);
	soap_serialize_PointerTons1__classPresentationType(soap, &this->ns1__batchPresentation::type);
	soap_serialize_wstring(soap, &this->ns1__batchPresentation::category);
	soap_serialize_wstring(soap, &this->ns1__batchPresentation::name);
	soap_embedded(soap, &this->ns1__batchPresentation::active, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns1__batchPresentation::rangeSize, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__batchPresentation::pageNumber, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__batchPresentation::fieldsData);
	soap_serialize_PointerTotime(soap, &this->ns1__batchPresentation::createDate);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__batchPresentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__batchPresentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__batchPresentation(struct soap *soap, const char *tag, int id, const ns1__batchPresentation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__batchPresentation), "ns1:batchPresentation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__batchPresentation::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__batchPresentation::version), ""))
		return soap->error;
	if (soap_out_PointerTons1__classPresentationType(soap, "type", -1, &(a->ns1__batchPresentation::type), ""))
		return soap->error;
	if (soap_out_wstring(soap, "category", -1, &(a->ns1__batchPresentation::category), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__batchPresentation::name), ""))
		return soap->error;
	if (soap_out_bool(soap, "active", -1, &(a->ns1__batchPresentation::active), ""))
		return soap->error;
	if (soap_out_int(soap, "rangeSize", -1, &(a->ns1__batchPresentation::rangeSize), ""))
		return soap->error;
	if (soap_out_int(soap, "pageNumber", -1, &(a->ns1__batchPresentation::pageNumber), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "fieldsData", -1, &(a->ns1__batchPresentation::fieldsData), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__batchPresentation::createDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__batchPresentation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__batchPresentation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__batchPresentation * SOAP_FMAC4 soap_in_ns1__batchPresentation(struct soap *soap, const char *tag, ns1__batchPresentation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__batchPresentation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__batchPresentation, sizeof(ns1__batchPresentation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__batchPresentation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__batchPresentation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_category1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_active1 = 1;
	size_t soap_flag_rangeSize1 = 1;
	size_t soap_flag_pageNumber1 = 1;
	size_t soap_flag_fieldsData1 = 1;
	size_t soap_flag_createDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__batchPresentation::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__batchPresentation::version), "xsd:long"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__classPresentationType(soap, "type", &(a->ns1__batchPresentation::type), "ns1:classPresentationType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "category", &(a->ns1__batchPresentation::category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__batchPresentation::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "active", &(a->ns1__batchPresentation::active), "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			if (soap_flag_rangeSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "rangeSize", &(a->ns1__batchPresentation::rangeSize), "xsd:int"))
				{	soap_flag_rangeSize1--;
					continue;
				}
			if (soap_flag_pageNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "pageNumber", &(a->ns1__batchPresentation::pageNumber), "xsd:int"))
				{	soap_flag_pageNumber1--;
					continue;
				}
			if (soap_flag_fieldsData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "fieldsData", &(a->ns1__batchPresentation::fieldsData), "xsd:base64Binary"))
				{	soap_flag_fieldsData1--;
					continue;
				}
			if (soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__batchPresentation::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__batchPresentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__batchPresentation, 0, sizeof(ns1__batchPresentation), 0, soap_copy_ns1__batchPresentation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_active1 > 0 || soap_flag_rangeSize1 > 0 || soap_flag_pageNumber1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__batchPresentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__batchPresentation);
	if (this->soap_out(soap, tag?tag:"ns1:batchPresentation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__batchPresentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__batchPresentation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__batchPresentation * SOAP_FMAC4 soap_get_ns1__batchPresentation(struct soap *soap, ns1__batchPresentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__batchPresentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__batchPresentation * SOAP_FMAC2 soap_instantiate_ns1__batchPresentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__batchPresentation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__batchPresentation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__batchPresentation);
		if (size)
			*size = sizeof(ns1__batchPresentation);
		((ns1__batchPresentation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__batchPresentation, n);
		if (size)
			*size = n * sizeof(ns1__batchPresentation);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__batchPresentation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__batchPresentation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__batchPresentation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__batchPresentation %p -> %p\n", q, p));
	*(ns1__batchPresentation*)p = *(ns1__batchPresentation*)q;
}

void ns1__getProcessesCount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessesCount::user = NULL;
	this->ns1__getProcessesCount::batchPresentation = NULL;
}

void ns1__getProcessesCount::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessesCount::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__getProcessesCount::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessesCount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessesCount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessesCount(struct soap *soap, const char *tag, int id, const ns1__getProcessesCount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessesCount), "ns1:getProcessesCount"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessesCount::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__getProcessesCount::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessesCount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessesCount(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessesCount * SOAP_FMAC4 soap_in_ns1__getProcessesCount(struct soap *soap, const char *tag, ns1__getProcessesCount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessesCount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessesCount, sizeof(ns1__getProcessesCount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessesCount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessesCount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessesCount::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__getProcessesCount::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessesCount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessesCount, 0, sizeof(ns1__getProcessesCount), 0, soap_copy_ns1__getProcessesCount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessesCount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessesCount);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessesCount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessesCount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessesCount(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessesCount * SOAP_FMAC4 soap_get_ns1__getProcessesCount(struct soap *soap, ns1__getProcessesCount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessesCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessesCount * SOAP_FMAC2 soap_instantiate_ns1__getProcessesCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessesCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessesCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesCount);
		if (size)
			*size = sizeof(ns1__getProcessesCount);
		((ns1__getProcessesCount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesCount, n);
		if (size)
			*size = n * sizeof(ns1__getProcessesCount);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessesCount*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessesCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessesCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessesCount %p -> %p\n", q, p));
	*(ns1__getProcessesCount*)p = *(ns1__getProcessesCount*)q;
}

void ns1__variableUserType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__variableUserType::name = NULL;
	this->ns1__variableUserType::__sizeattributes = 0;
	this->ns1__variableUserType::attributes = NULL;
}

void ns1__variableUserType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__variableUserType::name);
	if (this->ns1__variableUserType::attributes)
	{	int i;
		for (i = 0; i < this->ns1__variableUserType::__sizeattributes; i++)
		{
			soap_serialize_PointerTons1__variableDefinition(soap, this->ns1__variableUserType::attributes + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__variableUserType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__variableUserType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__variableUserType(struct soap *soap, const char *tag, int id, const ns1__variableUserType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__variableUserType), "ns1:variableUserType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__variableUserType::name), ""))
		return soap->error;
	if (a->ns1__variableUserType::attributes)
	{	int i;
		for (i = 0; i < a->ns1__variableUserType::__sizeattributes; i++)
			if (soap_out_PointerTons1__variableDefinition(soap, "attributes", -1, a->ns1__variableUserType::attributes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__variableUserType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__variableUserType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__variableUserType * SOAP_FMAC4 soap_in_ns1__variableUserType(struct soap *soap, const char *tag, ns1__variableUserType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__variableUserType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__variableUserType, sizeof(ns1__variableUserType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__variableUserType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__variableUserType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_name1 = 1;
	struct soap_blist *soap_blist_attributes1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__variableUserType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "attributes", 1, NULL))
			{	if (a->ns1__variableUserType::attributes == NULL)
				{	if (soap_blist_attributes1 == NULL)
						soap_blist_attributes1 = soap_new_block(soap);
					a->ns1__variableUserType::attributes = (ns1__variableDefinition **)soap_push_block(soap, soap_blist_attributes1, sizeof(ns1__variableDefinition *));
					if (a->ns1__variableUserType::attributes == NULL)
						return NULL;
					*a->ns1__variableUserType::attributes = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__variableDefinition(soap, "attributes", a->ns1__variableUserType::attributes, "ns1:variableDefinition"))
				{	a->ns1__variableUserType::__sizeattributes++;
					a->ns1__variableUserType::attributes = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__variableUserType::attributes)
			soap_pop_block(soap, soap_blist_attributes1);
		if (a->ns1__variableUserType::__sizeattributes)
			a->ns1__variableUserType::attributes = (ns1__variableDefinition **)soap_save_block(soap, soap_blist_attributes1, NULL, 1);
		else
		{	a->ns1__variableUserType::attributes = NULL;
			if (soap_blist_attributes1)
				soap_end_block(soap, soap_blist_attributes1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__variableUserType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__variableUserType, 0, sizeof(ns1__variableUserType), 0, soap_copy_ns1__variableUserType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__variableUserType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__variableUserType);
	if (this->soap_out(soap, tag?tag:"ns1:variableUserType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__variableUserType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__variableUserType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__variableUserType * SOAP_FMAC4 soap_get_ns1__variableUserType(struct soap *soap, ns1__variableUserType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__variableUserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__variableUserType * SOAP_FMAC2 soap_instantiate_ns1__variableUserType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__variableUserType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__variableUserType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__variableUserType);
		if (size)
			*size = sizeof(ns1__variableUserType);
		((ns1__variableUserType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableUserType, n);
		if (size)
			*size = n * sizeof(ns1__variableUserType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__variableUserType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__variableUserType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__variableUserType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__variableUserType %p -> %p\n", q, p));
	*(ns1__variableUserType*)p = *(ns1__variableUserType*)q;
}

void ns1__variableDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->ns1__variableDefinition::synthetic);
	this->ns1__variableDefinition::name = NULL;
	this->ns1__variableDefinition::format = NULL;
	soap_default_bool(soap, &this->ns1__variableDefinition::publicAccess);
	this->ns1__variableDefinition::defaultValue = NULL;
	this->ns1__variableDefinition::scriptingName = NULL;
	this->ns1__variableDefinition::formatLabel = NULL;
	this->ns1__variableDefinition::userTypes._ns1__variableDefinition_userTypes::soap_default(soap);
}

void ns1__variableDefinition::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__variableDefinition::synthetic, SOAP_TYPE_bool);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::name);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::format);
	soap_embedded(soap, &this->ns1__variableDefinition::publicAccess, SOAP_TYPE_bool);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::defaultValue);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::scriptingName);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::formatLabel);
	this->ns1__variableDefinition::userTypes.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__variableDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__variableDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__variableDefinition(struct soap *soap, const char *tag, int id, const ns1__variableDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__variableDefinition), "ns1:variableDefinition"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "synthetic", -1, &(a->ns1__variableDefinition::synthetic), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__variableDefinition::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "format", -1, &(a->ns1__variableDefinition::format), ""))
		return soap->error;
	if (soap_out_bool(soap, "publicAccess", -1, &(a->ns1__variableDefinition::publicAccess), ""))
		return soap->error;
	if (soap_out_wstring(soap, "defaultValue", -1, &(a->ns1__variableDefinition::defaultValue), ""))
		return soap->error;
	if (soap_out_wstring(soap, "scriptingName", -1, &(a->ns1__variableDefinition::scriptingName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "formatLabel", -1, &(a->ns1__variableDefinition::formatLabel), ""))
		return soap->error;
	if ((a->ns1__variableDefinition::userTypes).soap_out(soap, "userTypes", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__variableDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__variableDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ns1__variableDefinition * SOAP_FMAC4 soap_in_ns1__variableDefinition(struct soap *soap, const char *tag, ns1__variableDefinition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__variableDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__variableDefinition, sizeof(ns1__variableDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__variableDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__variableDefinition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_synthetic1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_format1 = 1;
	size_t soap_flag_publicAccess1 = 1;
	size_t soap_flag_defaultValue1 = 1;
	size_t soap_flag_scriptingName1 = 1;
	size_t soap_flag_formatLabel1 = 1;
	size_t soap_flag_userTypes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_synthetic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "synthetic", &(a->ns1__variableDefinition::synthetic), "xsd:boolean"))
				{	soap_flag_synthetic1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__variableDefinition::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_format1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "format", &(a->ns1__variableDefinition::format), "xsd:string"))
				{	soap_flag_format1--;
					continue;
				}
			if (soap_flag_publicAccess1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicAccess", &(a->ns1__variableDefinition::publicAccess), "xsd:boolean"))
				{	soap_flag_publicAccess1--;
					continue;
				}
			if (soap_flag_defaultValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "defaultValue", &(a->ns1__variableDefinition::defaultValue), "xsd:string"))
				{	soap_flag_defaultValue1--;
					continue;
				}
			if (soap_flag_scriptingName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "scriptingName", &(a->ns1__variableDefinition::scriptingName), "xsd:string"))
				{	soap_flag_scriptingName1--;
					continue;
				}
			if (soap_flag_formatLabel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "formatLabel", &(a->ns1__variableDefinition::formatLabel), "xsd:string"))
				{	soap_flag_formatLabel1--;
					continue;
				}
			if (soap_flag_userTypes1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns1__variableDefinition::userTypes).soap_in(soap, "userTypes", ""))
				{	soap_flag_userTypes1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__variableDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__variableDefinition, 0, sizeof(ns1__variableDefinition), 0, soap_copy_ns1__variableDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_synthetic1 > 0 || soap_flag_publicAccess1 > 0 || soap_flag_userTypes1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__variableDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__variableDefinition);
	if (this->soap_out(soap, tag?tag:"ns1:variableDefinition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__variableDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__variableDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ns1__variableDefinition * SOAP_FMAC4 soap_get_ns1__variableDefinition(struct soap *soap, ns1__variableDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__variableDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__variableDefinition * SOAP_FMAC2 soap_instantiate_ns1__variableDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__variableDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__variableDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__variableDefinition);
		if (size)
			*size = sizeof(ns1__variableDefinition);
		((ns1__variableDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableDefinition, n);
		if (size)
			*size = n * sizeof(ns1__variableDefinition);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__variableDefinition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__variableDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__variableDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__variableDefinition %p -> %p\n", q, p));
	*(ns1__variableDefinition*)p = *(ns1__variableDefinition*)q;
}

void ns1__getVariableResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getVariableResponse::result = NULL;
}

void ns1__getVariableResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__wfVariableStub(soap, &this->ns1__getVariableResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getVariableResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getVariableResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVariableResponse(struct soap *soap, const char *tag, int id, const ns1__getVariableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVariableResponse), "ns1:getVariableResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__wfVariableStub(soap, "result", -1, &(a->ns1__getVariableResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getVariableResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getVariableResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getVariableResponse * SOAP_FMAC4 soap_in_ns1__getVariableResponse(struct soap *soap, const char *tag, ns1__getVariableResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getVariableResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVariableResponse, sizeof(ns1__getVariableResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getVariableResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getVariableResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__wfVariableStub(soap, "result", &(a->ns1__getVariableResponse::result), "ns2:wfVariableStub"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getVariableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVariableResponse, 0, sizeof(ns1__getVariableResponse), 0, soap_copy_ns1__getVariableResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getVariableResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getVariableResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getVariableResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getVariableResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getVariableResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getVariableResponse * SOAP_FMAC4 soap_get_ns1__getVariableResponse(struct soap *soap, ns1__getVariableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVariableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getVariableResponse * SOAP_FMAC2 soap_instantiate_ns1__getVariableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVariableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVariableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getVariableResponse);
		if (size)
			*size = sizeof(ns1__getVariableResponse);
		((ns1__getVariableResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariableResponse, n);
		if (size)
			*size = n * sizeof(ns1__getVariableResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getVariableResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getVariableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVariableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getVariableResponse %p -> %p\n", q, p));
	*(ns1__getVariableResponse*)p = *(ns1__getVariableResponse*)q;
}

void ns1__getVariable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getVariable::user = NULL;
	this->ns1__getVariable::processId = NULL;
	this->ns1__getVariable::variableName = NULL;
}

void ns1__getVariable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getVariable::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getVariable::processId);
	soap_serialize_wstring(soap, &this->ns1__getVariable::variableName);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getVariable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getVariable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVariable(struct soap *soap, const char *tag, int id, const ns1__getVariable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVariable), "ns1:getVariable"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getVariable::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getVariable::processId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "variableName", -1, &(a->ns1__getVariable::variableName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getVariable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getVariable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getVariable * SOAP_FMAC4 soap_in_ns1__getVariable(struct soap *soap, const char *tag, ns1__getVariable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getVariable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVariable, sizeof(ns1__getVariable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getVariable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getVariable *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_variableName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getVariable::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getVariable::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_variableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "variableName", &(a->ns1__getVariable::variableName), "xsd:string"))
				{	soap_flag_variableName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getVariable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVariable, 0, sizeof(ns1__getVariable), 0, soap_copy_ns1__getVariable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getVariable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getVariable);
	if (this->soap_out(soap, tag?tag:"ns1:getVariable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getVariable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getVariable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getVariable * SOAP_FMAC4 soap_get_ns1__getVariable(struct soap *soap, ns1__getVariable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getVariable * SOAP_FMAC2 soap_instantiate_ns1__getVariable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVariable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVariable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getVariable);
		if (size)
			*size = sizeof(ns1__getVariable);
		((ns1__getVariable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariable, n);
		if (size)
			*size = n * sizeof(ns1__getVariable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getVariable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getVariable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVariable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getVariable %p -> %p\n", q, p));
	*(ns1__getVariable*)p = *(ns1__getVariable*)q;
}

void ns1__wfProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__identifiableBase::soap_default(soap);
	this->ns1__wfProcess::id = NULL;
	this->ns1__wfProcess::name = NULL;
	this->ns1__wfProcess::startDate = NULL;
	this->ns1__wfProcess::endDate = NULL;
	soap_default_int(soap, &this->ns1__wfProcess::version);
	this->ns1__wfProcess::definitionId = NULL;
	this->ns1__wfProcess::hierarchyIds = NULL;
}

void ns1__wfProcess::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfProcess::id);
	soap_serialize_wstring(soap, &this->ns1__wfProcess::name);
	soap_serialize_PointerTotime(soap, &this->ns1__wfProcess::startDate);
	soap_serialize_PointerTotime(soap, &this->ns1__wfProcess::endDate);
	soap_embedded(soap, &this->ns1__wfProcess::version, SOAP_TYPE_int);
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfProcess::definitionId);
	soap_serialize_wstring(soap, &this->ns1__wfProcess::hierarchyIds);
	this->ns1__identifiableBase::soap_serialize(soap);
#endif
}

int ns1__wfProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wfProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wfProcess(struct soap *soap, const char *tag, int id, const ns1__wfProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wfProcess), "ns1:wfProcess"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__wfProcess::id), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__wfProcess::name), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns1__wfProcess::startDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endDate", -1, &(a->ns1__wfProcess::endDate), ""))
		return soap->error;
	if (soap_out_int(soap, "version", -1, &(a->ns1__wfProcess::version), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "definitionId", -1, &(a->ns1__wfProcess::definitionId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "hierarchyIds", -1, &(a->ns1__wfProcess::hierarchyIds), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__wfProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wfProcess(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wfProcess * SOAP_FMAC4 soap_in_ns1__wfProcess(struct soap *soap, const char *tag, ns1__wfProcess *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wfProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wfProcess, sizeof(ns1__wfProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wfProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wfProcess *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item4 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_definitionId1 = 1;
	size_t soap_flag_hierarchyIds1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__wfProcess::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__wfProcess::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startDate", &(a->ns1__wfProcess::startDate), "xsd:dateTime"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endDate", &(a->ns1__wfProcess::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "version", &(a->ns1__wfProcess::version), "xsd:int"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_definitionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "definitionId", &(a->ns1__wfProcess::definitionId), "xsd:long"))
				{	soap_flag_definitionId1--;
					continue;
				}
			if (soap_flag_hierarchyIds1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "hierarchyIds", &(a->ns1__wfProcess::hierarchyIds), "xsd:string"))
				{	soap_flag_hierarchyIds1--;
					continue;
				}
			if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wfProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wfProcess, 0, sizeof(ns1__wfProcess), 0, soap_copy_ns1__wfProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_version1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wfProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__wfProcess);
	if (this->soap_out(soap, tag?tag:"ns1:wfProcess", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wfProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wfProcess(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wfProcess * SOAP_FMAC4 soap_get_ns1__wfProcess(struct soap *soap, ns1__wfProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wfProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wfProcess * SOAP_FMAC2 soap_instantiate_ns1__wfProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wfProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wfProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wfProcess);
		if (size)
			*size = sizeof(ns1__wfProcess);
		((ns1__wfProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfProcess, n);
		if (size)
			*size = n * sizeof(ns1__wfProcess);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wfProcess*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wfProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wfProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wfProcess %p -> %p\n", q, p));
	*(ns1__wfProcess*)p = *(ns1__wfProcess*)q;
}

void ns1__getProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessResponse::result = NULL;
}

void ns1__getProcessResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__wfProcess(soap, &this->ns1__getProcessResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessResponse), "ns1:getProcessResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__wfProcess(soap, "result", -1, &(a->ns1__getProcessResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessResponse * SOAP_FMAC4 soap_in_ns1__getProcessResponse(struct soap *soap, const char *tag, ns1__getProcessResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessResponse, sizeof(ns1__getProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfProcess(soap, "result", &(a->ns1__getProcessResponse::result), "ns1:wfProcess"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessResponse, 0, sizeof(ns1__getProcessResponse), 0, soap_copy_ns1__getProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessResponse * SOAP_FMAC4 soap_get_ns1__getProcessResponse(struct soap *soap, ns1__getProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessResponse);
		if (size)
			*size = sizeof(ns1__getProcessResponse);
		((ns1__getProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessResponse %p -> %p\n", q, p));
	*(ns1__getProcessResponse*)p = *(ns1__getProcessResponse*)q;
}

void ns1__getProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcess::user = NULL;
	this->ns1__getProcess::id = NULL;
}

void ns1__getProcess::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcess::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcess::id);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcess(struct soap *soap, const char *tag, int id, const ns1__getProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcess), "ns1:getProcess"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcess::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__getProcess::id), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcess(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcess * SOAP_FMAC4 soap_in_ns1__getProcess(struct soap *soap, const char *tag, ns1__getProcess *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcess, sizeof(ns1__getProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcess *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcess::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__getProcess::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcess, 0, sizeof(ns1__getProcess), 0, soap_copy_ns1__getProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcess);
	if (this->soap_out(soap, tag?tag:"ns1:getProcess", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcess(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcess * SOAP_FMAC4 soap_get_ns1__getProcess(struct soap *soap, ns1__getProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcess * SOAP_FMAC2 soap_instantiate_ns1__getProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcess);
		if (size)
			*size = sizeof(ns1__getProcess);
		((ns1__getProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcess, n);
		if (size)
			*size = n * sizeof(ns1__getProcess);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcess*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcess %p -> %p\n", q, p));
	*(ns1__getProcess*)p = *(ns1__getProcess*)q;
}

void ns1__wfExecutor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__executor::soap_default(soap);
	this->ns1__wfExecutor::executorClassName = NULL;
}

void ns1__wfExecutor::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__wfExecutor::executorClassName);
	this->ns1__executor::soap_serialize(soap);
#endif
}

int ns1__wfExecutor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wfExecutor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wfExecutor(struct soap *soap, const char *tag, int id, const ns1__wfExecutor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wfExecutor), "ns1:wfExecutor"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__executor::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__executor::version), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__executor::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__executor::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "fullName", -1, &(a->ns1__executor::fullName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__executor::createDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "executorClassName", -1, &(a->ns1__wfExecutor::executorClassName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__wfExecutor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wfExecutor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wfExecutor * SOAP_FMAC4 soap_in_ns1__wfExecutor(struct soap *soap, const char *tag, ns1__wfExecutor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wfExecutor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wfExecutor, sizeof(ns1__wfExecutor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wfExecutor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wfExecutor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item5 = 1;
	size_t soap_flag_id2 = 1;
	size_t soap_flag_version2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_fullName2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_executorClassName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__executor::id), "xsd:long"))
				{	soap_flag_id2--;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__executor::version), "xsd:long"))
				{	soap_flag_version2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__executor::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__executor::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_fullName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "fullName", &(a->ns1__executor::fullName), "xsd:string"))
				{	soap_flag_fullName2--;
					continue;
				}
			if (soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__executor::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if (soap_flag_executorClassName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "executorClassName", &(a->ns1__wfExecutor::executorClassName), "xsd:string"))
				{	soap_flag_executorClassName1--;
					continue;
				}
			if (soap_flag___item5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wfExecutor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wfExecutor, 0, sizeof(ns1__wfExecutor), 0, soap_copy_ns1__wfExecutor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wfExecutor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__wfExecutor);
	if (this->soap_out(soap, tag?tag:"ns1:wfExecutor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wfExecutor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wfExecutor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wfExecutor * SOAP_FMAC4 soap_get_ns1__wfExecutor(struct soap *soap, ns1__wfExecutor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wfExecutor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wfExecutor * SOAP_FMAC2 soap_instantiate_ns1__wfExecutor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wfExecutor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wfExecutor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
		if (size)
			*size = sizeof(ns1__wfExecutor);
		((ns1__wfExecutor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
		if (size)
			*size = n * sizeof(ns1__wfExecutor);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wfExecutor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wfExecutor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wfExecutor %p -> %p\n", q, p));
	*(ns1__wfExecutor*)p = *(ns1__wfExecutor*)q;
}

void ns1__wfTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__wfTask::id = NULL;
	this->ns1__wfTask::name = NULL;
	this->ns1__wfTask::nodeId = NULL;
	this->ns1__wfTask::description = NULL;
	this->ns1__wfTask::swimlaneName = NULL;
	this->ns1__wfTask::owner = NULL;
	this->ns1__wfTask::targetActor = NULL;
	this->ns1__wfTask::definitionId = NULL;
	this->ns1__wfTask::definitionName = NULL;
	this->ns1__wfTask::processId = NULL;
	this->ns1__wfTask::creationDate = NULL;
	this->ns1__wfTask::deadlineDate = NULL;
	this->ns1__wfTask::deadlineWarningDate = NULL;
	soap_default_bool(soap, &this->ns1__wfTask::escalated);
	soap_default_bool(soap, &this->ns1__wfTask::firstOpen);
	soap_default_bool(soap, &this->ns1__wfTask::acquiredBySubstitution);
}

void ns1__wfTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfTask::id);
	soap_serialize_wstring(soap, &this->ns1__wfTask::name);
	soap_serialize_wstring(soap, &this->ns1__wfTask::nodeId);
	soap_serialize_wstring(soap, &this->ns1__wfTask::description);
	soap_serialize_wstring(soap, &this->ns1__wfTask::swimlaneName);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__wfTask::owner);
	soap_serialize_PointerTons1__actor(soap, &this->ns1__wfTask::targetActor);
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfTask::definitionId);
	soap_serialize_wstring(soap, &this->ns1__wfTask::definitionName);
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfTask::processId);
	soap_serialize_PointerTotime(soap, &this->ns1__wfTask::creationDate);
	soap_serialize_PointerTotime(soap, &this->ns1__wfTask::deadlineDate);
	soap_serialize_PointerTotime(soap, &this->ns1__wfTask::deadlineWarningDate);
	soap_embedded(soap, &this->ns1__wfTask::escalated, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns1__wfTask::firstOpen, SOAP_TYPE_bool);
	soap_embedded(soap, &this->ns1__wfTask::acquiredBySubstitution, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__wfTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wfTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wfTask(struct soap *soap, const char *tag, int id, const ns1__wfTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wfTask), "ns1:wfTask"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__wfTask::id), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__wfTask::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "nodeId", -1, &(a->ns1__wfTask::nodeId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__wfTask::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "swimlaneName", -1, &(a->ns1__wfTask::swimlaneName), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "owner", -1, &(a->ns1__wfTask::owner), ""))
		return soap->error;
	if (soap_out_PointerTons1__actor(soap, "targetActor", -1, &(a->ns1__wfTask::targetActor), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "definitionId", -1, &(a->ns1__wfTask::definitionId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "definitionName", -1, &(a->ns1__wfTask::definitionName), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__wfTask::processId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "creationDate", -1, &(a->ns1__wfTask::creationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "deadlineDate", -1, &(a->ns1__wfTask::deadlineDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "deadlineWarningDate", -1, &(a->ns1__wfTask::deadlineWarningDate), ""))
		return soap->error;
	if (soap_out_bool(soap, "escalated", -1, &(a->ns1__wfTask::escalated), ""))
		return soap->error;
	if (soap_out_bool(soap, "firstOpen", -1, &(a->ns1__wfTask::firstOpen), ""))
		return soap->error;
	if (soap_out_bool(soap, "acquiredBySubstitution", -1, &(a->ns1__wfTask::acquiredBySubstitution), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__wfTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wfTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wfTask * SOAP_FMAC4 soap_in_ns1__wfTask(struct soap *soap, const char *tag, ns1__wfTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wfTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wfTask, sizeof(ns1__wfTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wfTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wfTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_nodeId1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_swimlaneName1 = 1;
	size_t soap_flag_owner1 = 1;
	size_t soap_flag_targetActor1 = 1;
	size_t soap_flag_definitionId1 = 1;
	size_t soap_flag_definitionName1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_creationDate1 = 1;
	size_t soap_flag_deadlineDate1 = 1;
	size_t soap_flag_deadlineWarningDate1 = 1;
	size_t soap_flag_escalated1 = 1;
	size_t soap_flag_firstOpen1 = 1;
	size_t soap_flag_acquiredBySubstitution1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__wfTask::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__wfTask::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_nodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "nodeId", &(a->ns1__wfTask::nodeId), "xsd:string"))
				{	soap_flag_nodeId1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__wfTask::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_swimlaneName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "swimlaneName", &(a->ns1__wfTask::swimlaneName), "xsd:string"))
				{	soap_flag_swimlaneName1--;
					continue;
				}
			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "owner", &(a->ns1__wfTask::owner), "ns1:wfExecutor"))
				{	soap_flag_owner1--;
					continue;
				}
			if (soap_flag_targetActor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__actor(soap, "targetActor", &(a->ns1__wfTask::targetActor), "ns1:actor"))
				{	soap_flag_targetActor1--;
					continue;
				}
			if (soap_flag_definitionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "definitionId", &(a->ns1__wfTask::definitionId), "xsd:long"))
				{	soap_flag_definitionId1--;
					continue;
				}
			if (soap_flag_definitionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "definitionName", &(a->ns1__wfTask::definitionName), "xsd:string"))
				{	soap_flag_definitionName1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__wfTask::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_creationDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "creationDate", &(a->ns1__wfTask::creationDate), "xsd:dateTime"))
				{	soap_flag_creationDate1--;
					continue;
				}
			if (soap_flag_deadlineDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "deadlineDate", &(a->ns1__wfTask::deadlineDate), "xsd:dateTime"))
				{	soap_flag_deadlineDate1--;
					continue;
				}
			if (soap_flag_deadlineWarningDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "deadlineWarningDate", &(a->ns1__wfTask::deadlineWarningDate), "xsd:dateTime"))
				{	soap_flag_deadlineWarningDate1--;
					continue;
				}
			if (soap_flag_escalated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "escalated", &(a->ns1__wfTask::escalated), "xsd:boolean"))
				{	soap_flag_escalated1--;
					continue;
				}
			if (soap_flag_firstOpen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "firstOpen", &(a->ns1__wfTask::firstOpen), "xsd:boolean"))
				{	soap_flag_firstOpen1--;
					continue;
				}
			if (soap_flag_acquiredBySubstitution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "acquiredBySubstitution", &(a->ns1__wfTask::acquiredBySubstitution), "xsd:boolean"))
				{	soap_flag_acquiredBySubstitution1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wfTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wfTask, 0, sizeof(ns1__wfTask), 0, soap_copy_ns1__wfTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_escalated1 > 0 || soap_flag_firstOpen1 > 0 || soap_flag_acquiredBySubstitution1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wfTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__wfTask);
	if (this->soap_out(soap, tag?tag:"ns1:wfTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wfTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wfTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wfTask * SOAP_FMAC4 soap_get_ns1__wfTask(struct soap *soap, ns1__wfTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wfTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wfTask * SOAP_FMAC2 soap_instantiate_ns1__wfTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wfTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wfTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wfTask);
		if (size)
			*size = sizeof(ns1__wfTask);
		((ns1__wfTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfTask, n);
		if (size)
			*size = n * sizeof(ns1__wfTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wfTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wfTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wfTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wfTask %p -> %p\n", q, p));
	*(ns1__wfTask*)p = *(ns1__wfTask*)q;
}

void ns1__getTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTaskResponse::result = NULL;
}

void ns1__getTaskResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__wfTask(soap, &this->ns1__getTaskResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTaskResponse(struct soap *soap, const char *tag, int id, const ns1__getTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTaskResponse), "ns1:getTaskResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__wfTask(soap, "result", -1, &(a->ns1__getTaskResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTaskResponse * SOAP_FMAC4 soap_in_ns1__getTaskResponse(struct soap *soap, const char *tag, ns1__getTaskResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTaskResponse, sizeof(ns1__getTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfTask(soap, "result", &(a->ns1__getTaskResponse::result), "ns1:wfTask"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTaskResponse, 0, sizeof(ns1__getTaskResponse), 0, soap_copy_ns1__getTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTaskResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTaskResponse * SOAP_FMAC4 soap_get_ns1__getTaskResponse(struct soap *soap, ns1__getTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__getTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTaskResponse);
		if (size)
			*size = sizeof(ns1__getTaskResponse);
		((ns1__getTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTaskResponse, n);
		if (size)
			*size = n * sizeof(ns1__getTaskResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTaskResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTaskResponse %p -> %p\n", q, p));
	*(ns1__getTaskResponse*)p = *(ns1__getTaskResponse*)q;
}

void ns1__getTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTask::user = NULL;
	this->ns1__getTask::taskId = NULL;
}

void ns1__getTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getTask::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getTask::taskId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTask(struct soap *soap, const char *tag, int id, const ns1__getTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTask), "ns1:getTask"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getTask::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__getTask::taskId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTask * SOAP_FMAC4 soap_in_ns1__getTask(struct soap *soap, const char *tag, ns1__getTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTask, sizeof(ns1__getTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getTask::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__getTask::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTask, 0, sizeof(ns1__getTask), 0, soap_copy_ns1__getTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTask);
	if (this->soap_out(soap, tag?tag:"ns1:getTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTask * SOAP_FMAC4 soap_get_ns1__getTask(struct soap *soap, ns1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTask * SOAP_FMAC2 soap_instantiate_ns1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTask);
		if (size)
			*size = sizeof(ns1__getTask);
		((ns1__getTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTask, n);
		if (size)
			*size = n * sizeof(ns1__getTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTask %p -> %p\n", q, p));
	*(ns1__getTask*)p = *(ns1__getTask*)q;
}

void ns1__graphElementPresentation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__graphElementPresentation::nodeId = NULL;
	this->ns1__graphElementPresentation::nodeType = NULL;
	this->ns1__graphElementPresentation::name = NULL;
	this->ns1__graphElementPresentation::__sizegraphConstraints = 0;
	this->ns1__graphElementPresentation::graphConstraints = NULL;
	this->ns1__graphElementPresentation::data = NULL;
}

void ns1__graphElementPresentation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__graphElementPresentation::nodeId);
	soap_serialize_PointerTons1__nodeType(soap, &this->ns1__graphElementPresentation::nodeType);
	soap_serialize_wstring(soap, &this->ns1__graphElementPresentation::name);
	if (this->ns1__graphElementPresentation::graphConstraints)
	{	int i;
		for (i = 0; i < this->ns1__graphElementPresentation::__sizegraphConstraints; i++)
		{
			soap_embedded(soap, this->ns1__graphElementPresentation::graphConstraints + i, SOAP_TYPE_int);
		}
	}
	soap_serialize_PointerToxsd__anyType(soap, &this->ns1__graphElementPresentation::data);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__graphElementPresentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__graphElementPresentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__graphElementPresentation(struct soap *soap, const char *tag, int id, const ns1__graphElementPresentation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__graphElementPresentation), "ns1:graphElementPresentation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "nodeId", -1, &(a->ns1__graphElementPresentation::nodeId), ""))
		return soap->error;
	if (soap_out_PointerTons1__nodeType(soap, "nodeType", -1, &(a->ns1__graphElementPresentation::nodeType), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__graphElementPresentation::name), ""))
		return soap->error;
	if (a->ns1__graphElementPresentation::graphConstraints)
	{	int i;
		for (i = 0; i < a->ns1__graphElementPresentation::__sizegraphConstraints; i++)
			if (soap_out_int(soap, "graphConstraints", -1, a->ns1__graphElementPresentation::graphConstraints + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__anyType(soap, "data", -1, &(a->ns1__graphElementPresentation::data), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__graphElementPresentation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__graphElementPresentation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__graphElementPresentation * SOAP_FMAC4 soap_in_ns1__graphElementPresentation(struct soap *soap, const char *tag, ns1__graphElementPresentation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__graphElementPresentation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__graphElementPresentation, sizeof(ns1__graphElementPresentation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__graphElementPresentation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__graphElementPresentation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_nodeId1 = 1;
	size_t soap_flag_nodeType1 = 1;
	size_t soap_flag_name1 = 1;
	struct soap_blist *soap_blist_graphConstraints1 = NULL;
	size_t soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_nodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "nodeId", &(a->ns1__graphElementPresentation::nodeId), "xsd:string"))
				{	soap_flag_nodeId1--;
					continue;
				}
			if (soap_flag_nodeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__nodeType(soap, "nodeType", &(a->ns1__graphElementPresentation::nodeType), "ns1:nodeType"))
				{	soap_flag_nodeType1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__graphElementPresentation::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "graphConstraints", 1, NULL))
			{	if (a->ns1__graphElementPresentation::graphConstraints == NULL)
				{	if (soap_blist_graphConstraints1 == NULL)
						soap_blist_graphConstraints1 = soap_new_block(soap);
					a->ns1__graphElementPresentation::graphConstraints = (int *)soap_push_block(soap, soap_blist_graphConstraints1, sizeof(int));
					if (a->ns1__graphElementPresentation::graphConstraints == NULL)
						return NULL;
					soap_default_int(soap, a->ns1__graphElementPresentation::graphConstraints);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "graphConstraints", a->ns1__graphElementPresentation::graphConstraints, "xsd:int"))
				{	a->ns1__graphElementPresentation::__sizegraphConstraints++;
					a->ns1__graphElementPresentation::graphConstraints = NULL;
					continue;
				}
			}
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "data", &(a->ns1__graphElementPresentation::data), "xsd:anyType"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__graphElementPresentation::graphConstraints)
			soap_pop_block(soap, soap_blist_graphConstraints1);
		if (a->ns1__graphElementPresentation::__sizegraphConstraints)
			a->ns1__graphElementPresentation::graphConstraints = (int *)soap_save_block(soap, soap_blist_graphConstraints1, NULL, 1);
		else
		{	a->ns1__graphElementPresentation::graphConstraints = NULL;
			if (soap_blist_graphConstraints1)
				soap_end_block(soap, soap_blist_graphConstraints1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__graphElementPresentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__graphElementPresentation, 0, sizeof(ns1__graphElementPresentation), 0, soap_copy_ns1__graphElementPresentation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__graphElementPresentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__graphElementPresentation);
	if (this->soap_out(soap, tag?tag:"ns1:graphElementPresentation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__graphElementPresentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__graphElementPresentation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__graphElementPresentation * SOAP_FMAC4 soap_get_ns1__graphElementPresentation(struct soap *soap, ns1__graphElementPresentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__graphElementPresentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__graphElementPresentation * SOAP_FMAC2 soap_instantiate_ns1__graphElementPresentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__graphElementPresentation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__graphElementPresentation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__graphElementPresentation);
		if (size)
			*size = sizeof(ns1__graphElementPresentation);
		((ns1__graphElementPresentation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__graphElementPresentation, n);
		if (size)
			*size = n * sizeof(ns1__graphElementPresentation);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__graphElementPresentation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__graphElementPresentation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__graphElementPresentation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__graphElementPresentation %p -> %p\n", q, p));
	*(ns1__graphElementPresentation*)p = *(ns1__graphElementPresentation*)q;
}

void ns1__getProcessHistoryDiagramElementsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessHistoryDiagramElementsResponse::__sizeresult = 0;
	this->ns1__getProcessHistoryDiagramElementsResponse::result = NULL;
}

void ns1__getProcessHistoryDiagramElementsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getProcessHistoryDiagramElementsResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getProcessHistoryDiagramElementsResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__graphElementPresentation(soap, this->ns1__getProcessHistoryDiagramElementsResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessHistoryDiagramElementsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessHistoryDiagramElementsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessHistoryDiagramElementsResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessHistoryDiagramElementsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse), "ns1:getProcessHistoryDiagramElementsResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getProcessHistoryDiagramElementsResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getProcessHistoryDiagramElementsResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__graphElementPresentation(soap, "result", -1, a->ns1__getProcessHistoryDiagramElementsResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessHistoryDiagramElementsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessHistoryDiagramElementsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElementsResponse * SOAP_FMAC4 soap_in_ns1__getProcessHistoryDiagramElementsResponse(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagramElementsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessHistoryDiagramElementsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse, sizeof(ns1__getProcessHistoryDiagramElementsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessHistoryDiagramElementsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getProcessHistoryDiagramElementsResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getProcessHistoryDiagramElementsResponse::result = (ns1__graphElementPresentation **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__graphElementPresentation *));
					if (a->ns1__getProcessHistoryDiagramElementsResponse::result == NULL)
						return NULL;
					*a->ns1__getProcessHistoryDiagramElementsResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__graphElementPresentation(soap, "result", a->ns1__getProcessHistoryDiagramElementsResponse::result, "ns1:graphElementPresentation"))
				{	a->ns1__getProcessHistoryDiagramElementsResponse::__sizeresult++;
					a->ns1__getProcessHistoryDiagramElementsResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getProcessHistoryDiagramElementsResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getProcessHistoryDiagramElementsResponse::__sizeresult)
			a->ns1__getProcessHistoryDiagramElementsResponse::result = (ns1__graphElementPresentation **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getProcessHistoryDiagramElementsResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessHistoryDiagramElementsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse, 0, sizeof(ns1__getProcessHistoryDiagramElementsResponse), 0, soap_copy_ns1__getProcessHistoryDiagramElementsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessHistoryDiagramElementsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessHistoryDiagramElementsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessHistoryDiagramElementsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessHistoryDiagramElementsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElementsResponse * SOAP_FMAC4 soap_get_ns1__getProcessHistoryDiagramElementsResponse(struct soap *soap, ns1__getProcessHistoryDiagramElementsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessHistoryDiagramElementsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessHistoryDiagramElementsResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessHistoryDiagramElementsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessHistoryDiagramElementsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagramElementsResponse);
		if (size)
			*size = sizeof(ns1__getProcessHistoryDiagramElementsResponse);
		((ns1__getProcessHistoryDiagramElementsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagramElementsResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessHistoryDiagramElementsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessHistoryDiagramElementsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessHistoryDiagramElementsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessHistoryDiagramElementsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessHistoryDiagramElementsResponse %p -> %p\n", q, p));
	*(ns1__getProcessHistoryDiagramElementsResponse*)p = *(ns1__getProcessHistoryDiagramElementsResponse*)q;
}

void ns1__getProcessHistoryDiagramElements::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessHistoryDiagramElements::user = NULL;
	this->ns1__getProcessHistoryDiagramElements::processId = NULL;
	this->ns1__getProcessHistoryDiagramElements::taskId = NULL;
}

void ns1__getProcessHistoryDiagramElements::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessHistoryDiagramElements::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessHistoryDiagramElements::processId);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessHistoryDiagramElements::taskId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessHistoryDiagramElements::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessHistoryDiagramElements(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessHistoryDiagramElements(struct soap *soap, const char *tag, int id, const ns1__getProcessHistoryDiagramElements *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessHistoryDiagramElements), "ns1:getProcessHistoryDiagramElements"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessHistoryDiagramElements::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getProcessHistoryDiagramElements::processId), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__getProcessHistoryDiagramElements::taskId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessHistoryDiagramElements::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessHistoryDiagramElements(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElements * SOAP_FMAC4 soap_in_ns1__getProcessHistoryDiagramElements(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagramElements *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessHistoryDiagramElements *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessHistoryDiagramElements, sizeof(ns1__getProcessHistoryDiagramElements), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessHistoryDiagramElements)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessHistoryDiagramElements *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessHistoryDiagramElements::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getProcessHistoryDiagramElements::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__getProcessHistoryDiagramElements::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessHistoryDiagramElements *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessHistoryDiagramElements, 0, sizeof(ns1__getProcessHistoryDiagramElements), 0, soap_copy_ns1__getProcessHistoryDiagramElements);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessHistoryDiagramElements::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessHistoryDiagramElements);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessHistoryDiagramElements", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessHistoryDiagramElements::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessHistoryDiagramElements(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElements * SOAP_FMAC4 soap_get_ns1__getProcessHistoryDiagramElements(struct soap *soap, ns1__getProcessHistoryDiagramElements *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessHistoryDiagramElements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessHistoryDiagramElements * SOAP_FMAC2 soap_instantiate_ns1__getProcessHistoryDiagramElements(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessHistoryDiagramElements(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessHistoryDiagramElements, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagramElements);
		if (size)
			*size = sizeof(ns1__getProcessHistoryDiagramElements);
		((ns1__getProcessHistoryDiagramElements*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagramElements, n);
		if (size)
			*size = n * sizeof(ns1__getProcessHistoryDiagramElements);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessHistoryDiagramElements*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessHistoryDiagramElements*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessHistoryDiagramElements(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessHistoryDiagramElements %p -> %p\n", q, p));
	*(ns1__getProcessHistoryDiagramElements*)p = *(ns1__getProcessHistoryDiagramElements*)q;
}

void ns1__authenticateByKerberosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByKerberosResponse::result = NULL;
}

void ns1__authenticateByKerberosResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByKerberosResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByKerberosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByKerberosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByKerberosResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateByKerberosResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByKerberosResponse), "ns1:authenticateByKerberosResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "result", -1, &(a->ns1__authenticateByKerberosResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByKerberosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByKerberosResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse * SOAP_FMAC4 soap_in_ns1__authenticateByKerberosResponse(struct soap *soap, const char *tag, ns1__authenticateByKerberosResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByKerberosResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByKerberosResponse, sizeof(ns1__authenticateByKerberosResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByKerberosResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByKerberosResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "result", &(a->ns1__authenticateByKerberosResponse::result), "ns1:user"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByKerberosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByKerberosResponse, 0, sizeof(ns1__authenticateByKerberosResponse), 0, soap_copy_ns1__authenticateByKerberosResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByKerberosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByKerberosResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByKerberosResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByKerberosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByKerberosResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse * SOAP_FMAC4 soap_get_ns1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByKerberosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByKerberosResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByKerberosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByKerberosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByKerberosResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberosResponse);
		if (size)
			*size = sizeof(ns1__authenticateByKerberosResponse);
		((ns1__authenticateByKerberosResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberosResponse, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByKerberosResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByKerberosResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByKerberosResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByKerberosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByKerberosResponse %p -> %p\n", q, p));
	*(ns1__authenticateByKerberosResponse*)p = *(ns1__authenticateByKerberosResponse*)q;
}

void ns1__authenticateByKerberos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByKerberos::token = NULL;
}

void ns1__authenticateByKerberos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__authenticateByKerberos::token);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByKerberos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByKerberos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByKerberos(struct soap *soap, const char *tag, int id, const ns1__authenticateByKerberos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByKerberos), "ns1:authenticateByKerberos"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__base64Binary(soap, "token", -1, &(a->ns1__authenticateByKerberos::token), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByKerberos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByKerberos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByKerberos * SOAP_FMAC4 soap_in_ns1__authenticateByKerberos(struct soap *soap, const char *tag, ns1__authenticateByKerberos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByKerberos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByKerberos, sizeof(ns1__authenticateByKerberos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByKerberos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByKerberos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_token1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "token", &(a->ns1__authenticateByKerberos::token), "xsd:base64Binary"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByKerberos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByKerberos, 0, sizeof(ns1__authenticateByKerberos), 0, soap_copy_ns1__authenticateByKerberos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByKerberos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByKerberos);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByKerberos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByKerberos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByKerberos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByKerberos * SOAP_FMAC4 soap_get_ns1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByKerberos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByKerberos * SOAP_FMAC2 soap_instantiate_ns1__authenticateByKerberos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByKerberos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByKerberos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberos);
		if (size)
			*size = sizeof(ns1__authenticateByKerberos);
		((ns1__authenticateByKerberos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberos, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByKerberos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByKerberos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByKerberos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByKerberos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByKerberos %p -> %p\n", q, p));
	*(ns1__authenticateByKerberos*)p = *(ns1__authenticateByKerberos*)q;
}

void ns1__authenticateByCallerPrincipalResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByCallerPrincipalResponse::result = NULL;
}

void ns1__authenticateByCallerPrincipalResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByCallerPrincipalResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByCallerPrincipalResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByCallerPrincipalResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateByCallerPrincipalResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse), "ns1:authenticateByCallerPrincipalResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "result", -1, &(a->ns1__authenticateByCallerPrincipalResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByCallerPrincipalResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByCallerPrincipalResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse * SOAP_FMAC4 soap_in_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipalResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByCallerPrincipalResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, sizeof(ns1__authenticateByCallerPrincipalResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByCallerPrincipalResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "result", &(a->ns1__authenticateByCallerPrincipalResponse::result), "ns1:user"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByCallerPrincipalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, 0, sizeof(ns1__authenticateByCallerPrincipalResponse), 0, soap_copy_ns1__authenticateByCallerPrincipalResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByCallerPrincipalResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByCallerPrincipalResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByCallerPrincipalResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByCallerPrincipalResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse * SOAP_FMAC4 soap_get_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByCallerPrincipalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByCallerPrincipalResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByCallerPrincipalResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipalResponse);
		if (size)
			*size = sizeof(ns1__authenticateByCallerPrincipalResponse);
		((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipalResponse, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByCallerPrincipalResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByCallerPrincipalResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByCallerPrincipalResponse %p -> %p\n", q, p));
	*(ns1__authenticateByCallerPrincipalResponse*)p = *(ns1__authenticateByCallerPrincipalResponse*)q;
}

void ns1__authenticateByCallerPrincipal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__authenticateByCallerPrincipal::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByCallerPrincipal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByCallerPrincipal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, int id, const ns1__authenticateByCallerPrincipal *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:authenticateByCallerPrincipal");
}

void *ns1__authenticateByCallerPrincipal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByCallerPrincipal(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_in_ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__authenticateByCallerPrincipal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByCallerPrincipal, sizeof(ns1__authenticateByCallerPrincipal), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByCallerPrincipal)
			return (ns1__authenticateByCallerPrincipal *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__authenticateByCallerPrincipal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByCallerPrincipal);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByCallerPrincipal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByCallerPrincipal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByCallerPrincipal(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_get_ns1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByCallerPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByCallerPrincipal * SOAP_FMAC2 soap_instantiate_ns1__authenticateByCallerPrincipal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByCallerPrincipal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByCallerPrincipal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipal);
		if (size)
			*size = sizeof(ns1__authenticateByCallerPrincipal);
		((ns1__authenticateByCallerPrincipal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipal, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByCallerPrincipal);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByCallerPrincipal*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByCallerPrincipal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByCallerPrincipal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByCallerPrincipal %p -> %p\n", q, p));
	*(ns1__authenticateByCallerPrincipal*)p = *(ns1__authenticateByCallerPrincipal*)q;
}

void ns1__identifiable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__identifiable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__identifiable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__identifiable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__identifiable(struct soap *soap, const char *tag, int id, const ns1__identifiable *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:identifiable");
}

void *ns1__identifiable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__identifiable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__identifiable * SOAP_FMAC4 soap_in_ns1__identifiable(struct soap *soap, const char *tag, ns1__identifiable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__identifiable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__identifiable, sizeof(ns1__identifiable), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__identifiable)
			return (ns1__identifiable *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__identifiable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__identifiable);
	if (this->soap_out(soap, tag?tag:"ns1:identifiable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__identifiable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__identifiable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__identifiable * SOAP_FMAC4 soap_get_ns1__identifiable(struct soap *soap, ns1__identifiable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__identifiable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__identifiable * SOAP_FMAC2 soap_instantiate_ns1__identifiable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__identifiable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__identifiable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:identifiableBase"))
	{	cp->type = SOAP_TYPE_ns1__identifiableBase;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__identifiableBase);
			if (size)
				*size = sizeof(ns1__identifiableBase);
			((ns1__identifiableBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiableBase, n);
			if (size)
				*size = n * sizeof(ns1__identifiableBase);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__identifiableBase*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__identifiableBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:executor"))
	{	cp->type = SOAP_TYPE_ns1__executor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
			if (size)
				*size = sizeof(ns1__executor);
			((ns1__executor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
			if (size)
				*size = n * sizeof(ns1__executor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__executor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__executor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfProcess"))
	{	cp->type = SOAP_TYPE_ns1__wfProcess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfProcess);
			if (size)
				*size = sizeof(ns1__wfProcess);
			((ns1__wfProcess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfProcess, n);
			if (size)
				*size = n * sizeof(ns1__wfProcess);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfProcess*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfProcess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__identifiable);
		if (size)
			*size = sizeof(ns1__identifiable);
		((ns1__identifiable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiable, n);
		if (size)
			*size = n * sizeof(ns1__identifiable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__identifiable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__identifiable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__identifiable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__identifiable %p -> %p\n", q, p));
	*(ns1__identifiable*)p = *(ns1__identifiable*)q;
}

void ns1__identifiableBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__identifiable::soap_default(soap);
}

void ns1__identifiableBase::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns1__identifiable::soap_serialize(soap);
#endif
}

int ns1__identifiableBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__identifiableBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__identifiableBase(struct soap *soap, const char *tag, int id, const ns1__identifiableBase *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:identifiableBase");
}

void *ns1__identifiableBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__identifiableBase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__identifiableBase * SOAP_FMAC4 soap_in_ns1__identifiableBase(struct soap *soap, const char *tag, ns1__identifiableBase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__identifiableBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__identifiableBase, sizeof(ns1__identifiableBase), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__identifiableBase)
			return (ns1__identifiableBase *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__identifiableBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__identifiableBase);
	if (this->soap_out(soap, tag?tag:"ns1:identifiableBase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__identifiableBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__identifiableBase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__identifiableBase * SOAP_FMAC4 soap_get_ns1__identifiableBase(struct soap *soap, ns1__identifiableBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__identifiableBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__identifiableBase * SOAP_FMAC2 soap_instantiate_ns1__identifiableBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__identifiableBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__identifiableBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:executor"))
	{	cp->type = SOAP_TYPE_ns1__executor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
			if (size)
				*size = sizeof(ns1__executor);
			((ns1__executor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
			if (size)
				*size = n * sizeof(ns1__executor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__executor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__executor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfProcess"))
	{	cp->type = SOAP_TYPE_ns1__wfProcess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfProcess);
			if (size)
				*size = sizeof(ns1__wfProcess);
			((ns1__wfProcess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfProcess, n);
			if (size)
				*size = n * sizeof(ns1__wfProcess);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfProcess*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfProcess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__identifiableBase);
		if (size)
			*size = sizeof(ns1__identifiableBase);
		((ns1__identifiableBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiableBase, n);
		if (size)
			*size = n * sizeof(ns1__identifiableBase);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__identifiableBase*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__identifiableBase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__identifiableBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__identifiableBase %p -> %p\n", q, p));
	*(ns1__identifiableBase*)p = *(ns1__identifiableBase*)q;
}

void ns1__executor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__identifiableBase::soap_default(soap);
	this->ns1__executor::id = NULL;
	this->ns1__executor::version = NULL;
	this->ns1__executor::name = NULL;
	this->ns1__executor::description = NULL;
	this->ns1__executor::fullName = NULL;
	this->ns1__executor::createDate = NULL;
}

void ns1__executor::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__executor::id);
	soap_serialize_PointerToLONG64(soap, &this->ns1__executor::version);
	soap_serialize_wstring(soap, &this->ns1__executor::name);
	soap_serialize_wstring(soap, &this->ns1__executor::description);
	soap_serialize_wstring(soap, &this->ns1__executor::fullName);
	soap_serialize_PointerTotime(soap, &this->ns1__executor::createDate);
	this->ns1__identifiableBase::soap_serialize(soap);
#endif
}

int ns1__executor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__executor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__executor(struct soap *soap, const char *tag, int id, const ns1__executor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__executor), "ns1:executor"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__executor::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__executor::version), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__executor::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__executor::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "fullName", -1, &(a->ns1__executor::fullName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__executor::createDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__executor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__executor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__executor * SOAP_FMAC4 soap_in_ns1__executor(struct soap *soap, const char *tag, ns1__executor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__executor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__executor, sizeof(ns1__executor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__executor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__executor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item4 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_createDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__executor::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__executor::version), "xsd:long"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__executor::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__executor::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "fullName", &(a->ns1__executor::fullName), "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__executor::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__executor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__executor, 0, sizeof(ns1__executor), 0, soap_copy_ns1__executor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__executor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__executor);
	if (this->soap_out(soap, tag?tag:"ns1:executor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__executor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__executor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__executor * SOAP_FMAC4 soap_get_ns1__executor(struct soap *soap, ns1__executor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__executor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__executor * SOAP_FMAC2 soap_instantiate_ns1__executor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__executor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__executor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
		if (size)
			*size = sizeof(ns1__executor);
		((ns1__executor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
		if (size)
			*size = n * sizeof(ns1__executor);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__executor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__executor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__executor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__executor %p -> %p\n", q, p));
	*(ns1__executor*)p = *(ns1__executor*)q;
}

void ns1__actor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__executor::soap_default(soap);
	this->ns1__actor::code = NULL;
	soap_default_bool(soap, &this->ns1__actor::active);
	this->ns1__actor::email = NULL;
	this->ns1__actor::phone = NULL;
}

void ns1__actor::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__actor::code);
	soap_embedded(soap, &this->ns1__actor::active, SOAP_TYPE_bool);
	soap_serialize_wstring(soap, &this->ns1__actor::email);
	soap_serialize_wstring(soap, &this->ns1__actor::phone);
	this->ns1__executor::soap_serialize(soap);
#endif
}

int ns1__actor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__actor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__actor(struct soap *soap, const char *tag, int id, const ns1__actor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__actor), "ns1:actor"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__executor::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__executor::version), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__executor::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__executor::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "fullName", -1, &(a->ns1__executor::fullName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__executor::createDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "code", -1, &(a->ns1__actor::code), ""))
		return soap->error;
	if (soap_out_bool(soap, "active", -1, &(a->ns1__actor::active), ""))
		return soap->error;
	if (soap_out_wstring(soap, "email", -1, &(a->ns1__actor::email), ""))
		return soap->error;
	if (soap_out_wstring(soap, "phone", -1, &(a->ns1__actor::phone), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__actor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__actor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__actor * SOAP_FMAC4 soap_in_ns1__actor(struct soap *soap, const char *tag, ns1__actor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__actor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__actor, sizeof(ns1__actor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__actor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__actor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item5 = 1;
	size_t soap_flag_id2 = 1;
	size_t soap_flag_version2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_fullName2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_active1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_phone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__executor::id), "xsd:long"))
				{	soap_flag_id2--;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__executor::version), "xsd:long"))
				{	soap_flag_version2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__executor::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__executor::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_fullName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "fullName", &(a->ns1__executor::fullName), "xsd:string"))
				{	soap_flag_fullName2--;
					continue;
				}
			if (soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__executor::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "code", &(a->ns1__actor::code), "xsd:long"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "active", &(a->ns1__actor::active), "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "email", &(a->ns1__actor::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "phone", &(a->ns1__actor::phone), "xsd:string"))
				{	soap_flag_phone1--;
					continue;
				}
			if (soap_flag___item5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__actor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__actor, 0, sizeof(ns1__actor), 0, soap_copy_ns1__actor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_active1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__actor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__actor);
	if (this->soap_out(soap, tag?tag:"ns1:actor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__actor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__actor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__actor * SOAP_FMAC4 soap_get_ns1__actor(struct soap *soap, ns1__actor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__actor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__actor * SOAP_FMAC2 soap_instantiate_ns1__actor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__actor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__actor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
		if (size)
			*size = sizeof(ns1__actor);
		((ns1__actor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
		if (size)
			*size = n * sizeof(ns1__actor);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__actor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__actor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__actor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__actor %p -> %p\n", q, p));
	*(ns1__actor*)p = *(ns1__actor*)q;
}

void ns1__user::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__user::actor = NULL;
	this->ns1__user::securedKey = NULL;
}

void ns1__user::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__actor(soap, &this->ns1__user::actor);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__user::securedKey);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user(struct soap *soap, const char *tag, int id, const ns1__user *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__user), "ns1:user"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__actor(soap, "actor", -1, &(a->ns1__user::actor), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "securedKey", -1, &(a->ns1__user::securedKey), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__user::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__user(soap, tag, this, type);
}

SOAP_FMAC3 ns1__user * SOAP_FMAC4 soap_in_ns1__user(struct soap *soap, const char *tag, ns1__user *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__user *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__user, sizeof(ns1__user), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__user)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__user *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_actor1 = 1;
	size_t soap_flag_securedKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__actor(soap, "actor", &(a->ns1__user::actor), "ns1:actor"))
				{	soap_flag_actor1--;
					continue;
				}
			if (soap_flag_securedKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "securedKey", &(a->ns1__user::securedKey), "xsd:base64Binary"))
				{	soap_flag_securedKey1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__user, 0, sizeof(ns1__user), 0, soap_copy_ns1__user);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__user::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__user);
	if (this->soap_out(soap, tag?tag:"ns1:user", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__user::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__user(soap, this, tag, type);
}

SOAP_FMAC3 ns1__user * SOAP_FMAC4 soap_get_ns1__user(struct soap *soap, ns1__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__user * SOAP_FMAC2 soap_instantiate_ns1__user(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__user(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__user, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__user);
		if (size)
			*size = sizeof(ns1__user);
		((ns1__user*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__user, n);
		if (size)
			*size = n * sizeof(ns1__user);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__user*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__user*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__user(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__user %p -> %p\n", q, p));
	*(ns1__user*)p = *(ns1__user*)q;
}

void ns1__authenticateByLoginPasswordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByLoginPasswordResponse::result = NULL;
}

void ns1__authenticateByLoginPasswordResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByLoginPasswordResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByLoginPasswordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByLoginPasswordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateByLoginPasswordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse), "ns1:authenticateByLoginPasswordResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "result", -1, &(a->ns1__authenticateByLoginPasswordResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByLoginPasswordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByLoginPasswordResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse * SOAP_FMAC4 soap_in_ns1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, ns1__authenticateByLoginPasswordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByLoginPasswordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, sizeof(ns1__authenticateByLoginPasswordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByLoginPasswordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByLoginPasswordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "result", &(a->ns1__authenticateByLoginPasswordResponse::result), "ns1:user"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByLoginPasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, 0, sizeof(ns1__authenticateByLoginPasswordResponse), 0, soap_copy_ns1__authenticateByLoginPasswordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByLoginPasswordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByLoginPasswordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByLoginPasswordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByLoginPasswordResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse * SOAP_FMAC4 soap_get_ns1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByLoginPasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByLoginPasswordResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByLoginPasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByLoginPasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPasswordResponse);
		if (size)
			*size = sizeof(ns1__authenticateByLoginPasswordResponse);
		((ns1__authenticateByLoginPasswordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPasswordResponse, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByLoginPasswordResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByLoginPasswordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByLoginPasswordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByLoginPasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByLoginPasswordResponse %p -> %p\n", q, p));
	*(ns1__authenticateByLoginPasswordResponse*)p = *(ns1__authenticateByLoginPasswordResponse*)q;
}

void ns1__authenticateByLoginPassword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByLoginPassword::name = NULL;
	this->ns1__authenticateByLoginPassword::password = NULL;
}

void ns1__authenticateByLoginPassword::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__authenticateByLoginPassword::name);
	soap_serialize_wstring(soap, &this->ns1__authenticateByLoginPassword::password);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByLoginPassword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByLoginPassword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, int id, const ns1__authenticateByLoginPassword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByLoginPassword), "ns1:authenticateByLoginPassword"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__authenticateByLoginPassword::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "password", -1, &(a->ns1__authenticateByLoginPassword::password), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByLoginPassword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByLoginPassword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_in_ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, ns1__authenticateByLoginPassword *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByLoginPassword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByLoginPassword, sizeof(ns1__authenticateByLoginPassword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByLoginPassword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByLoginPassword *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__authenticateByLoginPassword::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "password", &(a->ns1__authenticateByLoginPassword::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByLoginPassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByLoginPassword, 0, sizeof(ns1__authenticateByLoginPassword), 0, soap_copy_ns1__authenticateByLoginPassword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByLoginPassword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByLoginPassword);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByLoginPassword", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByLoginPassword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByLoginPassword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_get_ns1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByLoginPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByLoginPassword * SOAP_FMAC2 soap_instantiate_ns1__authenticateByLoginPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByLoginPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByLoginPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPassword);
		if (size)
			*size = sizeof(ns1__authenticateByLoginPassword);
		((ns1__authenticateByLoginPassword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPassword, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByLoginPassword);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByLoginPassword*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByLoginPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByLoginPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByLoginPassword %p -> %p\n", q, p));
	*(ns1__authenticateByLoginPassword*)p = *(ns1__authenticateByLoginPassword*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__string::__item = NULL;
}

void xsd__string::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->xsd__string::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_wstring(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_wstring(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag?tag:"xsd:string", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__string);
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__string, n);
		if (size)
			*size = n * sizeof(xsd__string);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_LONG64(soap, &this->xsd__long::__item);
}

void xsd__long::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__long::__item, SOAP_TYPE_LONG64);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))
		return NULL;
	return a;
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag?tag:"xsd:long", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__long);
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__long, n);
		if (size)
			*size = n * sizeof(xsd__long);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__long*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->xsd__int::__item);
}

void xsd__int::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__int::__item, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag?tag:"xsd:int", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__int);
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__int, n);
		if (size)
			*size = n * sizeof(xsd__int);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__int*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_time(soap, &this->xsd__dateTime::__item);
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_time);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag?tag:"xsd:dateTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__dateTime, n);
		if (size)
			*size = n * sizeof(xsd__dateTime);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__dateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->xsd__boolean::__item);
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__boolean::__item, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag?tag:"xsd:boolean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__boolean, n);
		if (size)
			*size = n * sizeof(xsd__boolean);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__boolean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__base64Binary_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__base64Binary_::__item.xsd__base64Binary::soap_default(soap);
}

void xsd__base64Binary_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__base64Binary_::__item, SOAP_TYPE_xsd__base64Binary);
	this->xsd__base64Binary_::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__base64Binary_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary_(struct soap *soap, const char *tag, int id, const xsd__base64Binary_ *a, const char *type)
{
	return (a->xsd__base64Binary_::__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_in_xsd__base64Binary_(struct soap *soap, const char *tag, xsd__base64Binary_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__base64Binary_)
			return (xsd__base64Binary_ *)a->soap_in(soap, tag, type);
	}
	if (!(a->xsd__base64Binary_::__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

int xsd__base64Binary_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__base64Binary_);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_get_xsd__base64Binary_(struct soap *soap, xsd__base64Binary_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary_);
		if (size)
			*size = sizeof(xsd__base64Binary_);
		((xsd__base64Binary_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary_, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary_ %p -> %p\n", q, p));
	*(xsd__base64Binary_*)p = *(xsd__base64Binary_*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag?tag:"xsd:anyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary_);
			if (size)
				*size = sizeof(xsd__base64Binary_);
			((xsd__base64Binary_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary_, n);
			if (size)
				*size = n * sizeof(xsd__base64Binary_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__base64Binary_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__boolean, n);
			if (size)
				*size = n * sizeof(xsd__boolean);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__dateTime, n);
			if (size)
				*size = n * sizeof(xsd__dateTime);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__int);
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__int, n);
			if (size)
				*size = n * sizeof(xsd__int);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__int*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__long);
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__long, n);
			if (size)
				*size = n * sizeof(xsd__long);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__long*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__string);
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__string, n);
			if (size)
				*size = n * sizeof(xsd__string);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__string*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:nodeType"))
	{	cp->type = SOAP_TYPE_ns1__nodeType_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__nodeType_);
			if (size)
				*size = sizeof(ns1__nodeType_);
			((ns1__nodeType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__nodeType_, n);
			if (size)
				*size = n * sizeof(ns1__nodeType_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__nodeType_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__nodeType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:classPresentationType"))
	{	cp->type = SOAP_TYPE_ns1__classPresentationType_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__classPresentationType_);
			if (size)
				*size = sizeof(ns1__classPresentationType_);
			((ns1__classPresentationType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__classPresentationType_, n);
			if (size)
				*size = n * sizeof(ns1__classPresentationType_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__classPresentationType_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__classPresentationType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:severity"))
	{	cp->type = SOAP_TYPE_ns1__severity_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__severity_);
			if (size)
				*size = sizeof(ns1__severity_);
			((ns1__severity_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__severity_, n);
			if (size)
				*size = n * sizeof(ns1__severity_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__severity_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__severity_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByLoginPassword"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByLoginPassword;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPassword);
			if (size)
				*size = sizeof(ns1__authenticateByLoginPassword);
			((ns1__authenticateByLoginPassword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPassword, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByLoginPassword);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByLoginPassword*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByLoginPassword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByLoginPasswordResponse"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByLoginPasswordResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPasswordResponse);
			if (size)
				*size = sizeof(ns1__authenticateByLoginPasswordResponse);
			((ns1__authenticateByLoginPasswordResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPasswordResponse, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByLoginPasswordResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByLoginPasswordResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByLoginPasswordResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:user"))
	{	cp->type = SOAP_TYPE_ns1__user;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__user);
			if (size)
				*size = sizeof(ns1__user);
			((ns1__user*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__user, n);
			if (size)
				*size = n * sizeof(ns1__user);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__user*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__user*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:identifiable"))
	{	cp->type = SOAP_TYPE_ns1__identifiable;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__identifiable);
			if (size)
				*size = sizeof(ns1__identifiable);
			((ns1__identifiable*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiable, n);
			if (size)
				*size = n * sizeof(ns1__identifiable);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__identifiable*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__identifiable*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByCallerPrincipal"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByCallerPrincipal;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipal);
			if (size)
				*size = sizeof(ns1__authenticateByCallerPrincipal);
			((ns1__authenticateByCallerPrincipal*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipal, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByCallerPrincipal);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByCallerPrincipal*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByCallerPrincipal*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByCallerPrincipalResponse"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipalResponse);
			if (size)
				*size = sizeof(ns1__authenticateByCallerPrincipalResponse);
			((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipalResponse, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByCallerPrincipalResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByCallerPrincipalResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByKerberos"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByKerberos;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberos);
			if (size)
				*size = sizeof(ns1__authenticateByKerberos);
			((ns1__authenticateByKerberos*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberos, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByKerberos);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByKerberos*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByKerberos*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByKerberosResponse"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByKerberosResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberosResponse);
			if (size)
				*size = sizeof(ns1__authenticateByKerberosResponse);
			((ns1__authenticateByKerberosResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberosResponse, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByKerberosResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByKerberosResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByKerberosResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessHistoryDiagramElements"))
	{	cp->type = SOAP_TYPE_ns1__getProcessHistoryDiagramElements;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagramElements);
			if (size)
				*size = sizeof(ns1__getProcessHistoryDiagramElements);
			((ns1__getProcessHistoryDiagramElements*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagramElements, n);
			if (size)
				*size = n * sizeof(ns1__getProcessHistoryDiagramElements);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessHistoryDiagramElements*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessHistoryDiagramElements*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessHistoryDiagramElementsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagramElementsResponse);
			if (size)
				*size = sizeof(ns1__getProcessHistoryDiagramElementsResponse);
			((ns1__getProcessHistoryDiagramElementsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagramElementsResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessHistoryDiagramElementsResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessHistoryDiagramElementsResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessHistoryDiagramElementsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:graphElementPresentation"))
	{	cp->type = SOAP_TYPE_ns1__graphElementPresentation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__graphElementPresentation);
			if (size)
				*size = sizeof(ns1__graphElementPresentation);
			((ns1__graphElementPresentation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__graphElementPresentation, n);
			if (size)
				*size = n * sizeof(ns1__graphElementPresentation);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__graphElementPresentation*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__graphElementPresentation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTask"))
	{	cp->type = SOAP_TYPE_ns1__getTask;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTask);
			if (size)
				*size = sizeof(ns1__getTask);
			((ns1__getTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTask, n);
			if (size)
				*size = n * sizeof(ns1__getTask);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTask*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTaskResponse"))
	{	cp->type = SOAP_TYPE_ns1__getTaskResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTaskResponse);
			if (size)
				*size = sizeof(ns1__getTaskResponse);
			((ns1__getTaskResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTaskResponse, n);
			if (size)
				*size = n * sizeof(ns1__getTaskResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTaskResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTaskResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfTask"))
	{	cp->type = SOAP_TYPE_ns1__wfTask;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfTask);
			if (size)
				*size = sizeof(ns1__wfTask);
			((ns1__wfTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfTask, n);
			if (size)
				*size = n * sizeof(ns1__wfTask);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfTask*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcess"))
	{	cp->type = SOAP_TYPE_ns1__getProcess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcess);
			if (size)
				*size = sizeof(ns1__getProcess);
			((ns1__getProcess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcess, n);
			if (size)
				*size = n * sizeof(ns1__getProcess);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcess*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessResponse);
			if (size)
				*size = sizeof(ns1__getProcessResponse);
			((ns1__getProcessResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getVariable"))
	{	cp->type = SOAP_TYPE_ns1__getVariable;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getVariable);
			if (size)
				*size = sizeof(ns1__getVariable);
			((ns1__getVariable*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariable, n);
			if (size)
				*size = n * sizeof(ns1__getVariable);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getVariable*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getVariable*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getVariableResponse"))
	{	cp->type = SOAP_TYPE_ns1__getVariableResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getVariableResponse);
			if (size)
				*size = sizeof(ns1__getVariableResponse);
			((ns1__getVariableResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariableResponse, n);
			if (size)
				*size = n * sizeof(ns1__getVariableResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getVariableResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getVariableResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:variableDefinition"))
	{	cp->type = SOAP_TYPE_ns1__variableDefinition;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__variableDefinition);
			if (size)
				*size = sizeof(ns1__variableDefinition);
			((ns1__variableDefinition*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableDefinition, n);
			if (size)
				*size = n * sizeof(ns1__variableDefinition);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__variableDefinition*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__variableDefinition*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:variableUserType"))
	{	cp->type = SOAP_TYPE_ns1__variableUserType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__variableUserType);
			if (size)
				*size = sizeof(ns1__variableUserType);
			((ns1__variableUserType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableUserType, n);
			if (size)
				*size = n * sizeof(ns1__variableUserType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__variableUserType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__variableUserType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessesCount"))
	{	cp->type = SOAP_TYPE_ns1__getProcessesCount;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesCount);
			if (size)
				*size = sizeof(ns1__getProcessesCount);
			((ns1__getProcessesCount*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesCount, n);
			if (size)
				*size = n * sizeof(ns1__getProcessesCount);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessesCount*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessesCount*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:batchPresentation"))
	{	cp->type = SOAP_TYPE_ns1__batchPresentation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__batchPresentation);
			if (size)
				*size = sizeof(ns1__batchPresentation);
			((ns1__batchPresentation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__batchPresentation, n);
			if (size)
				*size = n * sizeof(ns1__batchPresentation);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__batchPresentation*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__batchPresentation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessesCountResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessesCountResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesCountResponse);
			if (size)
				*size = sizeof(ns1__getProcessesCountResponse);
			((ns1__getProcessesCountResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesCountResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessesCountResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessesCountResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessesCountResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessesByFilter"))
	{	cp->type = SOAP_TYPE_ns1__getProcessesByFilter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesByFilter);
			if (size)
				*size = sizeof(ns1__getProcessesByFilter);
			((ns1__getProcessesByFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesByFilter, n);
			if (size)
				*size = n * sizeof(ns1__getProcessesByFilter);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessesByFilter*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessesByFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:processFilter"))
	{	cp->type = SOAP_TYPE_ns1__processFilter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processFilter);
			if (size)
				*size = sizeof(ns1__processFilter);
			((ns1__processFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processFilter, n);
			if (size)
				*size = n * sizeof(ns1__processFilter);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processFilter*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessesByFilterResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessesByFilterResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesByFilterResponse);
			if (size)
				*size = sizeof(ns1__getProcessesByFilterResponse);
			((ns1__getProcessesByFilterResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesByFilterResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessesByFilterResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessesByFilterResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessesByFilterResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getParentProcess"))
	{	cp->type = SOAP_TYPE_ns1__getParentProcess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getParentProcess);
			if (size)
				*size = sizeof(ns1__getParentProcess);
			((ns1__getParentProcess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getParentProcess, n);
			if (size)
				*size = n * sizeof(ns1__getParentProcess);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getParentProcess*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getParentProcess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getParentProcessResponse"))
	{	cp->type = SOAP_TYPE_ns1__getParentProcessResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getParentProcessResponse);
			if (size)
				*size = sizeof(ns1__getParentProcessResponse);
			((ns1__getParentProcessResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getParentProcessResponse, n);
			if (size)
				*size = n * sizeof(ns1__getParentProcessResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getParentProcessResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getParentProcessResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSubprocesses"))
	{	cp->type = SOAP_TYPE_ns1__getSubprocesses;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSubprocesses);
			if (size)
				*size = sizeof(ns1__getSubprocesses);
			((ns1__getSubprocesses*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSubprocesses, n);
			if (size)
				*size = n * sizeof(ns1__getSubprocesses);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSubprocesses*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSubprocesses*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSubprocessesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getSubprocessesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSubprocessesResponse);
			if (size)
				*size = sizeof(ns1__getSubprocessesResponse);
			((ns1__getSubprocessesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSubprocessesResponse, n);
			if (size)
				*size = n * sizeof(ns1__getSubprocessesResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSubprocessesResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSubprocessesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:cancelProcess"))
	{	cp->type = SOAP_TYPE_ns1__cancelProcess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__cancelProcess);
			if (size)
				*size = sizeof(ns1__cancelProcess);
			((ns1__cancelProcess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cancelProcess, n);
			if (size)
				*size = n * sizeof(ns1__cancelProcess);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__cancelProcess*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__cancelProcess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:cancelProcessResponse"))
	{	cp->type = SOAP_TYPE_ns1__cancelProcessResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__cancelProcessResponse);
			if (size)
				*size = sizeof(ns1__cancelProcessResponse);
			((ns1__cancelProcessResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__cancelProcessResponse, n);
			if (size)
				*size = n * sizeof(ns1__cancelProcessResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__cancelProcessResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__cancelProcessResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessTasks"))
	{	cp->type = SOAP_TYPE_ns1__getProcessTasks;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasks);
			if (size)
				*size = sizeof(ns1__getProcessTasks);
			((ns1__getProcessTasks*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasks, n);
			if (size)
				*size = n * sizeof(ns1__getProcessTasks);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessTasks*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessTasks*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessTasksResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessTasksResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasksResponse);
			if (size)
				*size = sizeof(ns1__getProcessTasksResponse);
			((ns1__getProcessTasksResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasksResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessTasksResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessTasksResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessTasksResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessDiagram"))
	{	cp->type = SOAP_TYPE_ns1__getProcessDiagram;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagram);
			if (size)
				*size = sizeof(ns1__getProcessDiagram);
			((ns1__getProcessDiagram*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagram, n);
			if (size)
				*size = n * sizeof(ns1__getProcessDiagram);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessDiagram*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessDiagram*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessDiagramResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessDiagramResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagramResponse);
			if (size)
				*size = sizeof(ns1__getProcessDiagramResponse);
			((ns1__getProcessDiagramResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagramResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessDiagramResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessDiagramResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessDiagramResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessHistoryDiagram"))
	{	cp->type = SOAP_TYPE_ns1__getProcessHistoryDiagram;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagram);
			if (size)
				*size = sizeof(ns1__getProcessHistoryDiagram);
			((ns1__getProcessHistoryDiagram*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagram, n);
			if (size)
				*size = n * sizeof(ns1__getProcessHistoryDiagram);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessHistoryDiagram*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessHistoryDiagram*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessHistoryDiagramResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessHistoryDiagramResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessHistoryDiagramResponse);
			if (size)
				*size = sizeof(ns1__getProcessHistoryDiagramResponse);
			((ns1__getProcessHistoryDiagramResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessHistoryDiagramResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessHistoryDiagramResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessHistoryDiagramResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessHistoryDiagramResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessDiagramElements"))
	{	cp->type = SOAP_TYPE_ns1__getProcessDiagramElements;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagramElements);
			if (size)
				*size = sizeof(ns1__getProcessDiagramElements);
			((ns1__getProcessDiagramElements*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagramElements, n);
			if (size)
				*size = n * sizeof(ns1__getProcessDiagramElements);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessDiagramElements*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessDiagramElements*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessDiagramElementsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessDiagramElementsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessDiagramElementsResponse);
			if (size)
				*size = sizeof(ns1__getProcessDiagramElementsResponse);
			((ns1__getProcessDiagramElementsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessDiagramElementsResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessDiagramElementsResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessDiagramElementsResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessDiagramElementsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:assignSwimlane"))
	{	cp->type = SOAP_TYPE_ns1__assignSwimlane;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__assignSwimlane);
			if (size)
				*size = sizeof(ns1__assignSwimlane);
			((ns1__assignSwimlane*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignSwimlane, n);
			if (size)
				*size = n * sizeof(ns1__assignSwimlane);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__assignSwimlane*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__assignSwimlane*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:assignSwimlaneResponse"))
	{	cp->type = SOAP_TYPE_ns1__assignSwimlaneResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__assignSwimlaneResponse);
			if (size)
				*size = sizeof(ns1__assignSwimlaneResponse);
			((ns1__assignSwimlaneResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignSwimlaneResponse, n);
			if (size)
				*size = n * sizeof(ns1__assignSwimlaneResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__assignSwimlaneResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__assignSwimlaneResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessLogs"))
	{	cp->type = SOAP_TYPE_ns1__getProcessLogs;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogs);
			if (size)
				*size = sizeof(ns1__getProcessLogs);
			((ns1__getProcessLogs*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogs, n);
			if (size)
				*size = n * sizeof(ns1__getProcessLogs);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessLogs*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessLogs*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:processLogFilter"))
	{	cp->type = SOAP_TYPE_ns1__processLogFilter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processLogFilter);
			if (size)
				*size = sizeof(ns1__processLogFilter);
			((ns1__processLogFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processLogFilter, n);
			if (size)
				*size = n * sizeof(ns1__processLogFilter);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processLogFilter*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processLogFilter*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessLogsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessLogsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogsResponse);
			if (size)
				*size = sizeof(ns1__getProcessLogsResponse);
			((ns1__getProcessLogsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogsResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessLogsResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessLogsResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessLogsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:processLogs"))
	{	cp->type = SOAP_TYPE_ns1__processLogs;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processLogs);
			if (size)
				*size = sizeof(ns1__processLogs);
			((ns1__processLogs*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processLogs, n);
			if (size)
				*size = n * sizeof(ns1__processLogs);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processLogs*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processLogs*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:processLog"))
	{	cp->type = SOAP_TYPE_ns1__processLog;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processLog);
			if (size)
				*size = sizeof(ns1__processLog);
			((ns1__processLog*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processLog, n);
			if (size)
				*size = n * sizeof(ns1__processLog);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processLog*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processLog*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessLogValue"))
	{	cp->type = SOAP_TYPE_ns1__getProcessLogValue;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogValue);
			if (size)
				*size = sizeof(ns1__getProcessLogValue);
			((ns1__getProcessLogValue*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogValue, n);
			if (size)
				*size = n * sizeof(ns1__getProcessLogValue);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessLogValue*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessLogValue*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessLogValueResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessLogValueResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessLogValueResponse);
			if (size)
				*size = sizeof(ns1__getProcessLogValueResponse);
			((ns1__getProcessLogValueResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessLogValueResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessLogValueResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessLogValueResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessLogValueResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:markTaskOpened"))
	{	cp->type = SOAP_TYPE_ns1__markTaskOpened;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpened);
			if (size)
				*size = sizeof(ns1__markTaskOpened);
			((ns1__markTaskOpened*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpened, n);
			if (size)
				*size = n * sizeof(ns1__markTaskOpened);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__markTaskOpened*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__markTaskOpened*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:markTaskOpenedResponse"))
	{	cp->type = SOAP_TYPE_ns1__markTaskOpenedResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpenedResponse);
			if (size)
				*size = sizeof(ns1__markTaskOpenedResponse);
			((ns1__markTaskOpenedResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpenedResponse, n);
			if (size)
				*size = n * sizeof(ns1__markTaskOpenedResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__markTaskOpenedResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__markTaskOpenedResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeProcesses"))
	{	cp->type = SOAP_TYPE_ns1__removeProcesses;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeProcesses);
			if (size)
				*size = sizeof(ns1__removeProcesses);
			((ns1__removeProcesses*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__removeProcesses, n);
			if (size)
				*size = n * sizeof(ns1__removeProcesses);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__removeProcesses*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__removeProcesses*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:removeProcessesResponse"))
	{	cp->type = SOAP_TYPE_ns1__removeProcessesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__removeProcessesResponse);
			if (size)
				*size = sizeof(ns1__removeProcessesResponse);
			((ns1__removeProcessesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__removeProcessesResponse, n);
			if (size)
				*size = n * sizeof(ns1__removeProcessesResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__removeProcessesResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__removeProcessesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSystemLogs"))
	{	cp->type = SOAP_TYPE_ns1__getSystemLogs;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogs);
			if (size)
				*size = sizeof(ns1__getSystemLogs);
			((ns1__getSystemLogs*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogs, n);
			if (size)
				*size = n * sizeof(ns1__getSystemLogs);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSystemLogs*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSystemLogs*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSystemLogsResponse"))
	{	cp->type = SOAP_TYPE_ns1__getSystemLogsResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogsResponse);
			if (size)
				*size = sizeof(ns1__getSystemLogsResponse);
			((ns1__getSystemLogsResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogsResponse, n);
			if (size)
				*size = n * sizeof(ns1__getSystemLogsResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSystemLogsResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSystemLogsResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:systemLog"))
	{	cp->type = SOAP_TYPE_ns1__systemLog;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__systemLog);
			if (size)
				*size = sizeof(ns1__systemLog);
			((ns1__systemLog*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__systemLog, n);
			if (size)
				*size = n * sizeof(ns1__systemLog);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__systemLog*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__systemLog*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSystemLogsCount"))
	{	cp->type = SOAP_TYPE_ns1__getSystemLogsCount;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogsCount);
			if (size)
				*size = sizeof(ns1__getSystemLogsCount);
			((ns1__getSystemLogsCount*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogsCount, n);
			if (size)
				*size = n * sizeof(ns1__getSystemLogsCount);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSystemLogsCount*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSystemLogsCount*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSystemLogsCountResponse"))
	{	cp->type = SOAP_TYPE_ns1__getSystemLogsCountResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSystemLogsCountResponse);
			if (size)
				*size = sizeof(ns1__getSystemLogsCountResponse);
			((ns1__getSystemLogsCountResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSystemLogsCountResponse, n);
			if (size)
				*size = n * sizeof(ns1__getSystemLogsCountResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSystemLogsCountResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSystemLogsCountResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getVariablesWS"))
	{	cp->type = SOAP_TYPE_ns1__getVariablesWS;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getVariablesWS);
			if (size)
				*size = sizeof(ns1__getVariablesWS);
			((ns1__getVariablesWS*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariablesWS, n);
			if (size)
				*size = n * sizeof(ns1__getVariablesWS);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getVariablesWS*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getVariablesWS*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getVariablesWSResponse"))
	{	cp->type = SOAP_TYPE_ns1__getVariablesWSResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getVariablesWSResponse);
			if (size)
				*size = sizeof(ns1__getVariablesWSResponse);
			((ns1__getVariablesWSResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getVariablesWSResponse, n);
			if (size)
				*size = n * sizeof(ns1__getVariablesWSResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getVariablesWSResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getVariablesWSResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:variable"))
	{	cp->type = SOAP_TYPE_ns1__variable;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__variable);
			if (size)
				*size = sizeof(ns1__variable);
			((ns1__variable*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variable, n);
			if (size)
				*size = n * sizeof(ns1__variable);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__variable*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__variable*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:startProcessWS"))
	{	cp->type = SOAP_TYPE_ns1__startProcessWS;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__startProcessWS);
			if (size)
				*size = sizeof(ns1__startProcessWS);
			((ns1__startProcessWS*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__startProcessWS, n);
			if (size)
				*size = n * sizeof(ns1__startProcessWS);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__startProcessWS*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__startProcessWS*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:startProcessWSResponse"))
	{	cp->type = SOAP_TYPE_ns1__startProcessWSResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__startProcessWSResponse);
			if (size)
				*size = sizeof(ns1__startProcessWSResponse);
			((ns1__startProcessWSResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__startProcessWSResponse, n);
			if (size)
				*size = n * sizeof(ns1__startProcessWSResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__startProcessWSResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__startProcessWSResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:completeTaskWS"))
	{	cp->type = SOAP_TYPE_ns1__completeTaskWS;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWS);
			if (size)
				*size = sizeof(ns1__completeTaskWS);
			((ns1__completeTaskWS*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWS, n);
			if (size)
				*size = n * sizeof(ns1__completeTaskWS);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__completeTaskWS*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__completeTaskWS*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:completeTaskWSResponse"))
	{	cp->type = SOAP_TYPE_ns1__completeTaskWSResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWSResponse);
			if (size)
				*size = sizeof(ns1__completeTaskWSResponse);
			((ns1__completeTaskWSResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWSResponse, n);
			if (size)
				*size = n * sizeof(ns1__completeTaskWSResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__completeTaskWSResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__completeTaskWSResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:updateVariablesWS"))
	{	cp->type = SOAP_TYPE_ns1__updateVariablesWS;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__updateVariablesWS);
			if (size)
				*size = sizeof(ns1__updateVariablesWS);
			((ns1__updateVariablesWS*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__updateVariablesWS, n);
			if (size)
				*size = n * sizeof(ns1__updateVariablesWS);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__updateVariablesWS*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__updateVariablesWS*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:updateVariablesWSResponse"))
	{	cp->type = SOAP_TYPE_ns1__updateVariablesWSResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__updateVariablesWSResponse);
			if (size)
				*size = sizeof(ns1__updateVariablesWSResponse);
			((ns1__updateVariablesWSResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__updateVariablesWSResponse, n);
			if (size)
				*size = n * sizeof(ns1__updateVariablesWSResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__updateVariablesWSResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__updateVariablesWSResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSwimlanes"))
	{	cp->type = SOAP_TYPE_ns1__getSwimlanes;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSwimlanes);
			if (size)
				*size = sizeof(ns1__getSwimlanes);
			((ns1__getSwimlanes*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSwimlanes, n);
			if (size)
				*size = n * sizeof(ns1__getSwimlanes);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSwimlanes*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSwimlanes*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getSwimlanesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getSwimlanesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getSwimlanesResponse);
			if (size)
				*size = sizeof(ns1__getSwimlanesResponse);
			((ns1__getSwimlanesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getSwimlanesResponse, n);
			if (size)
				*size = n * sizeof(ns1__getSwimlanesResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getSwimlanesResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getSwimlanesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfSwimlane"))
	{	cp->type = SOAP_TYPE_ns1__wfSwimlane;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfSwimlane);
			if (size)
				*size = sizeof(ns1__wfSwimlane);
			((ns1__wfSwimlane*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfSwimlane, n);
			if (size)
				*size = n * sizeof(ns1__wfSwimlane);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfSwimlane*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfSwimlane*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:graphElement"))
	{	cp->type = SOAP_TYPE_ns1__graphElement;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__graphElement);
			if (size)
				*size = sizeof(ns1__graphElement);
			((ns1__graphElement*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__graphElement, n);
			if (size)
				*size = n * sizeof(ns1__graphElement);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__graphElement*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__graphElement*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:delegation"))
	{	cp->type = SOAP_TYPE_ns1__delegation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__delegation);
			if (size)
				*size = sizeof(ns1__delegation);
			((ns1__delegation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__delegation, n);
			if (size)
				*size = n * sizeof(ns1__delegation);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__delegation*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__delegation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcesses"))
	{	cp->type = SOAP_TYPE_ns1__getProcesses;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcesses);
			if (size)
				*size = sizeof(ns1__getProcesses);
			((ns1__getProcesses*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcesses, n);
			if (size)
				*size = n * sizeof(ns1__getProcesses);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcesses*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcesses*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessesResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessesResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessesResponse);
			if (size)
				*size = sizeof(ns1__getProcessesResponse);
			((ns1__getProcessesResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessesResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessesResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessesResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessesResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTasks"))
	{	cp->type = SOAP_TYPE_ns1__getTasks;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTasks);
			if (size)
				*size = sizeof(ns1__getTasks);
			((ns1__getTasks*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasks, n);
			if (size)
				*size = n * sizeof(ns1__getTasks);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTasks*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTasks*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTasksResponse"))
	{	cp->type = SOAP_TYPE_ns1__getTasksResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTasksResponse);
			if (size)
				*size = sizeof(ns1__getTasksResponse);
			((ns1__getTasksResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasksResponse, n);
			if (size)
				*size = n * sizeof(ns1__getTasksResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTasksResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTasksResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:assignTask"))
	{	cp->type = SOAP_TYPE_ns1__assignTask;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__assignTask);
			if (size)
				*size = sizeof(ns1__assignTask);
			((ns1__assignTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTask, n);
			if (size)
				*size = n * sizeof(ns1__assignTask);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__assignTask*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__assignTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:assignTaskResponse"))
	{	cp->type = SOAP_TYPE_ns1__assignTaskResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__assignTaskResponse);
			if (size)
				*size = sizeof(ns1__assignTaskResponse);
			((ns1__assignTaskResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTaskResponse, n);
			if (size)
				*size = n * sizeof(ns1__assignTaskResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__assignTaskResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__assignTaskResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:wfVariableStub"))
	{	cp->type = SOAP_TYPE_ns2__wfVariableStub;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__wfVariableStub);
			if (size)
				*size = sizeof(ns2__wfVariableStub);
			((ns2__wfVariableStub*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__wfVariableStub, n);
			if (size)
				*size = n * sizeof(ns2__wfVariableStub);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__wfVariableStub*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__wfVariableStub*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:identifiableBase"))
	{	cp->type = SOAP_TYPE_ns1__identifiableBase;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__identifiableBase);
			if (size)
				*size = sizeof(ns1__identifiableBase);
			((ns1__identifiableBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiableBase, n);
			if (size)
				*size = n * sizeof(ns1__identifiableBase);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__identifiableBase*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__identifiableBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:processDefinitionDeleteLog"))
	{	cp->type = SOAP_TYPE_ns1__processDefinitionDeleteLog;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processDefinitionDeleteLog);
			if (size)
				*size = sizeof(ns1__processDefinitionDeleteLog);
			((ns1__processDefinitionDeleteLog*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processDefinitionDeleteLog, n);
			if (size)
				*size = n * sizeof(ns1__processDefinitionDeleteLog);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processDefinitionDeleteLog*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processDefinitionDeleteLog*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:processDeleteLog"))
	{	cp->type = SOAP_TYPE_ns1__processDeleteLog;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__processDeleteLog);
			if (size)
				*size = sizeof(ns1__processDeleteLog);
			((ns1__processDeleteLog*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__processDeleteLog, n);
			if (size)
				*size = n * sizeof(ns1__processDeleteLog);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__processDeleteLog*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__processDeleteLog*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:swimlaneDefinition"))
	{	cp->type = SOAP_TYPE_ns1__swimlaneDefinition;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__swimlaneDefinition);
			if (size)
				*size = sizeof(ns1__swimlaneDefinition);
			((ns1__swimlaneDefinition*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__swimlaneDefinition, n);
			if (size)
				*size = n * sizeof(ns1__swimlaneDefinition);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__swimlaneDefinition*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__swimlaneDefinition*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:executor"))
	{	cp->type = SOAP_TYPE_ns1__executor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
			if (size)
				*size = sizeof(ns1__executor);
			((ns1__executor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
			if (size)
				*size = n * sizeof(ns1__executor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__executor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__executor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfProcess"))
	{	cp->type = SOAP_TYPE_ns1__wfProcess;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfProcess);
			if (size)
				*size = sizeof(ns1__wfProcess);
			((ns1__wfProcess*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfProcess, n);
			if (size)
				*size = n * sizeof(ns1__wfProcess);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfProcess*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfProcess*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyType);
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__anyType, n);
		if (size)
			*size = n * sizeof(xsd__anyType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateVariablesWS(struct soap *soap, struct __ns1__updateVariablesWS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateVariablesWS_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateVariablesWS(struct soap *soap, const struct __ns1__updateVariablesWS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateVariablesWS(soap, &a->ns1__updateVariablesWS_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateVariablesWS(struct soap *soap, const char *tag, int id, const struct __ns1__updateVariablesWS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__updateVariablesWS(soap, "ns1:updateVariablesWS", -1, &a->ns1__updateVariablesWS_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateVariablesWS * SOAP_FMAC4 soap_in___ns1__updateVariablesWS(struct soap *soap, const char *tag, struct __ns1__updateVariablesWS *a, const char *type)
{
	size_t soap_flag_ns1__updateVariablesWS_ = 1;
	short soap_flag;
	a = (struct __ns1__updateVariablesWS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateVariablesWS, sizeof(struct __ns1__updateVariablesWS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateVariablesWS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateVariablesWS_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateVariablesWS(soap, "ns1:updateVariablesWS", &a->ns1__updateVariablesWS_, "ns1:updateVariablesWS"))
				{	soap_flag_ns1__updateVariablesWS_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateVariablesWS(struct soap *soap, const struct __ns1__updateVariablesWS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateVariablesWS(soap, tag?tag:"-ns1:updateVariablesWS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateVariablesWS * SOAP_FMAC4 soap_get___ns1__updateVariablesWS(struct soap *soap, struct __ns1__updateVariablesWS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateVariablesWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateVariablesWS * SOAP_FMAC2 soap_instantiate___ns1__updateVariablesWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateVariablesWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateVariablesWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateVariablesWS);
		if (size)
			*size = sizeof(struct __ns1__updateVariablesWS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__updateVariablesWS, n);
		if (size)
			*size = n * sizeof(struct __ns1__updateVariablesWS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__updateVariablesWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateVariablesWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateVariablesWS %p -> %p\n", q, p));
	*(struct __ns1__updateVariablesWS*)p = *(struct __ns1__updateVariablesWS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateVariablesWSResponse(struct soap *soap, struct __ns1__updateVariablesWSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateVariablesWSResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateVariablesWSResponse(struct soap *soap, const struct __ns1__updateVariablesWSResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateVariablesWSResponse(soap, &a->ns1__updateVariablesWSResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateVariablesWSResponse(struct soap *soap, const char *tag, int id, const struct __ns1__updateVariablesWSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__updateVariablesWSResponse_)
		soap_element_result(soap, "ns1:updateVariablesWSResponse");
	if (soap_out_PointerTons1__updateVariablesWSResponse(soap, "ns1:updateVariablesWSResponse", -1, &a->ns1__updateVariablesWSResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateVariablesWSResponse * SOAP_FMAC4 soap_in___ns1__updateVariablesWSResponse(struct soap *soap, const char *tag, struct __ns1__updateVariablesWSResponse *a, const char *type)
{
	size_t soap_flag_ns1__updateVariablesWSResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__updateVariablesWSResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateVariablesWSResponse, sizeof(struct __ns1__updateVariablesWSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateVariablesWSResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateVariablesWSResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateVariablesWSResponse(soap, "ns1:updateVariablesWSResponse", &a->ns1__updateVariablesWSResponse_, "ns1:updateVariablesWSResponse"))
				{	soap_flag_ns1__updateVariablesWSResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:updateVariablesWSResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateVariablesWSResponse(struct soap *soap, const struct __ns1__updateVariablesWSResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateVariablesWSResponse(soap, tag?tag:"-ns1:updateVariablesWSResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateVariablesWSResponse * SOAP_FMAC4 soap_get___ns1__updateVariablesWSResponse(struct soap *soap, struct __ns1__updateVariablesWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateVariablesWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateVariablesWSResponse * SOAP_FMAC2 soap_instantiate___ns1__updateVariablesWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateVariablesWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateVariablesWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateVariablesWSResponse);
		if (size)
			*size = sizeof(struct __ns1__updateVariablesWSResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__updateVariablesWSResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__updateVariablesWSResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__updateVariablesWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateVariablesWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateVariablesWSResponse %p -> %p\n", q, p));
	*(struct __ns1__updateVariablesWSResponse*)p = *(struct __ns1__updateVariablesWSResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__startProcessWS(struct soap *soap, struct __ns1__startProcessWS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__startProcessWS_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__startProcessWS(struct soap *soap, const struct __ns1__startProcessWS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__startProcessWS(soap, &a->ns1__startProcessWS_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__startProcessWS(struct soap *soap, const char *tag, int id, const struct __ns1__startProcessWS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__startProcessWS(soap, "ns1:startProcessWS", -1, &a->ns1__startProcessWS_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startProcessWS * SOAP_FMAC4 soap_in___ns1__startProcessWS(struct soap *soap, const char *tag, struct __ns1__startProcessWS *a, const char *type)
{
	size_t soap_flag_ns1__startProcessWS_ = 1;
	short soap_flag;
	a = (struct __ns1__startProcessWS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__startProcessWS, sizeof(struct __ns1__startProcessWS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__startProcessWS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__startProcessWS_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__startProcessWS(soap, "ns1:startProcessWS", &a->ns1__startProcessWS_, "ns1:startProcessWS"))
				{	soap_flag_ns1__startProcessWS_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__startProcessWS(struct soap *soap, const struct __ns1__startProcessWS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__startProcessWS(soap, tag?tag:"-ns1:startProcessWS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startProcessWS * SOAP_FMAC4 soap_get___ns1__startProcessWS(struct soap *soap, struct __ns1__startProcessWS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__startProcessWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__startProcessWS * SOAP_FMAC2 soap_instantiate___ns1__startProcessWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__startProcessWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__startProcessWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__startProcessWS);
		if (size)
			*size = sizeof(struct __ns1__startProcessWS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__startProcessWS, n);
		if (size)
			*size = n * sizeof(struct __ns1__startProcessWS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__startProcessWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__startProcessWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__startProcessWS %p -> %p\n", q, p));
	*(struct __ns1__startProcessWS*)p = *(struct __ns1__startProcessWS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeProcesses(struct soap *soap, struct __ns1__removeProcesses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeProcesses_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeProcesses(struct soap *soap, const struct __ns1__removeProcesses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeProcesses(soap, &a->ns1__removeProcesses_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeProcesses(struct soap *soap, const char *tag, int id, const struct __ns1__removeProcesses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__removeProcesses(soap, "ns1:removeProcesses", -1, &a->ns1__removeProcesses_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeProcesses * SOAP_FMAC4 soap_in___ns1__removeProcesses(struct soap *soap, const char *tag, struct __ns1__removeProcesses *a, const char *type)
{
	size_t soap_flag_ns1__removeProcesses_ = 1;
	short soap_flag;
	a = (struct __ns1__removeProcesses *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeProcesses, sizeof(struct __ns1__removeProcesses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeProcesses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeProcesses_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeProcesses(soap, "ns1:removeProcesses", &a->ns1__removeProcesses_, "ns1:removeProcesses"))
				{	soap_flag_ns1__removeProcesses_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeProcesses(struct soap *soap, const struct __ns1__removeProcesses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeProcesses(soap, tag?tag:"-ns1:removeProcesses", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeProcesses * SOAP_FMAC4 soap_get___ns1__removeProcesses(struct soap *soap, struct __ns1__removeProcesses *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeProcesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeProcesses * SOAP_FMAC2 soap_instantiate___ns1__removeProcesses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeProcesses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeProcesses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeProcesses);
		if (size)
			*size = sizeof(struct __ns1__removeProcesses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__removeProcesses, n);
		if (size)
			*size = n * sizeof(struct __ns1__removeProcesses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__removeProcesses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeProcesses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeProcesses %p -> %p\n", q, p));
	*(struct __ns1__removeProcesses*)p = *(struct __ns1__removeProcesses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeProcessesResponse(struct soap *soap, struct __ns1__removeProcessesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeProcessesResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeProcessesResponse(struct soap *soap, const struct __ns1__removeProcessesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeProcessesResponse(soap, &a->ns1__removeProcessesResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeProcessesResponse(struct soap *soap, const char *tag, int id, const struct __ns1__removeProcessesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__removeProcessesResponse_)
		soap_element_result(soap, "ns1:removeProcessesResponse");
	if (soap_out_PointerTons1__removeProcessesResponse(soap, "ns1:removeProcessesResponse", -1, &a->ns1__removeProcessesResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeProcessesResponse * SOAP_FMAC4 soap_in___ns1__removeProcessesResponse(struct soap *soap, const char *tag, struct __ns1__removeProcessesResponse *a, const char *type)
{
	size_t soap_flag_ns1__removeProcessesResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__removeProcessesResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeProcessesResponse, sizeof(struct __ns1__removeProcessesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeProcessesResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeProcessesResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeProcessesResponse(soap, "ns1:removeProcessesResponse", &a->ns1__removeProcessesResponse_, "ns1:removeProcessesResponse"))
				{	soap_flag_ns1__removeProcessesResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:removeProcessesResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeProcessesResponse(struct soap *soap, const struct __ns1__removeProcessesResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeProcessesResponse(soap, tag?tag:"-ns1:removeProcessesResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeProcessesResponse * SOAP_FMAC4 soap_get___ns1__removeProcessesResponse(struct soap *soap, struct __ns1__removeProcessesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeProcessesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__removeProcessesResponse * SOAP_FMAC2 soap_instantiate___ns1__removeProcessesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeProcessesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeProcessesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__removeProcessesResponse);
		if (size)
			*size = sizeof(struct __ns1__removeProcessesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__removeProcessesResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__removeProcessesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__removeProcessesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeProcessesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeProcessesResponse %p -> %p\n", q, p));
	*(struct __ns1__removeProcessesResponse*)p = *(struct __ns1__removeProcessesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__markTaskOpened(struct soap *soap, struct __ns1__markTaskOpened *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__markTaskOpened_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__markTaskOpened(struct soap *soap, const struct __ns1__markTaskOpened *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__markTaskOpened(soap, &a->ns1__markTaskOpened_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__markTaskOpened(struct soap *soap, const char *tag, int id, const struct __ns1__markTaskOpened *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__markTaskOpened(soap, "ns1:markTaskOpened", -1, &a->ns1__markTaskOpened_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpened * SOAP_FMAC4 soap_in___ns1__markTaskOpened(struct soap *soap, const char *tag, struct __ns1__markTaskOpened *a, const char *type)
{
	size_t soap_flag_ns1__markTaskOpened_ = 1;
	short soap_flag;
	a = (struct __ns1__markTaskOpened *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__markTaskOpened, sizeof(struct __ns1__markTaskOpened), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__markTaskOpened(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__markTaskOpened_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__markTaskOpened(soap, "ns1:markTaskOpened", &a->ns1__markTaskOpened_, "ns1:markTaskOpened"))
				{	soap_flag_ns1__markTaskOpened_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__markTaskOpened(struct soap *soap, const struct __ns1__markTaskOpened *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__markTaskOpened(soap, tag?tag:"-ns1:markTaskOpened", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpened * SOAP_FMAC4 soap_get___ns1__markTaskOpened(struct soap *soap, struct __ns1__markTaskOpened *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__markTaskOpened(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__markTaskOpened * SOAP_FMAC2 soap_instantiate___ns1__markTaskOpened(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__markTaskOpened(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__markTaskOpened, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__markTaskOpened);
		if (size)
			*size = sizeof(struct __ns1__markTaskOpened);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__markTaskOpened, n);
		if (size)
			*size = n * sizeof(struct __ns1__markTaskOpened);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__markTaskOpened*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__markTaskOpened(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__markTaskOpened %p -> %p\n", q, p));
	*(struct __ns1__markTaskOpened*)p = *(struct __ns1__markTaskOpened*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__markTaskOpenedResponse(struct soap *soap, struct __ns1__markTaskOpenedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__markTaskOpenedResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__markTaskOpenedResponse(struct soap *soap, const struct __ns1__markTaskOpenedResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__markTaskOpenedResponse(soap, &a->ns1__markTaskOpenedResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, int id, const struct __ns1__markTaskOpenedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__markTaskOpenedResponse_)
		soap_element_result(soap, "ns1:markTaskOpenedResponse");
	if (soap_out_PointerTons1__markTaskOpenedResponse(soap, "ns1:markTaskOpenedResponse", -1, &a->ns1__markTaskOpenedResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_in___ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, struct __ns1__markTaskOpenedResponse *a, const char *type)
{
	size_t soap_flag_ns1__markTaskOpenedResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__markTaskOpenedResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__markTaskOpenedResponse, sizeof(struct __ns1__markTaskOpenedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__markTaskOpenedResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__markTaskOpenedResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__markTaskOpenedResponse(soap, "ns1:markTaskOpenedResponse", &a->ns1__markTaskOpenedResponse_, "ns1:markTaskOpenedResponse"))
				{	soap_flag_ns1__markTaskOpenedResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:markTaskOpenedResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__markTaskOpenedResponse(struct soap *soap, const struct __ns1__markTaskOpenedResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__markTaskOpenedResponse(soap, tag?tag:"-ns1:markTaskOpenedResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_get___ns1__markTaskOpenedResponse(struct soap *soap, struct __ns1__markTaskOpenedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__markTaskOpenedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__markTaskOpenedResponse * SOAP_FMAC2 soap_instantiate___ns1__markTaskOpenedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__markTaskOpenedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__markTaskOpenedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__markTaskOpenedResponse);
		if (size)
			*size = sizeof(struct __ns1__markTaskOpenedResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__markTaskOpenedResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__markTaskOpenedResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__markTaskOpenedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__markTaskOpenedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__markTaskOpenedResponse %p -> %p\n", q, p));
	*(struct __ns1__markTaskOpenedResponse*)p = *(struct __ns1__markTaskOpenedResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVariablesWS(struct soap *soap, struct __ns1__getVariablesWS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVariablesWS_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVariablesWS(struct soap *soap, const struct __ns1__getVariablesWS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getVariablesWS(soap, &a->ns1__getVariablesWS_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVariablesWS(struct soap *soap, const char *tag, int id, const struct __ns1__getVariablesWS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getVariablesWS(soap, "ns1:getVariablesWS", -1, &a->ns1__getVariablesWS_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVariablesWS * SOAP_FMAC4 soap_in___ns1__getVariablesWS(struct soap *soap, const char *tag, struct __ns1__getVariablesWS *a, const char *type)
{
	size_t soap_flag_ns1__getVariablesWS_ = 1;
	short soap_flag;
	a = (struct __ns1__getVariablesWS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVariablesWS, sizeof(struct __ns1__getVariablesWS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVariablesWS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVariablesWS_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getVariablesWS(soap, "ns1:getVariablesWS", &a->ns1__getVariablesWS_, "ns1:getVariablesWS"))
				{	soap_flag_ns1__getVariablesWS_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVariablesWS(struct soap *soap, const struct __ns1__getVariablesWS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVariablesWS(soap, tag?tag:"-ns1:getVariablesWS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVariablesWS * SOAP_FMAC4 soap_get___ns1__getVariablesWS(struct soap *soap, struct __ns1__getVariablesWS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVariablesWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getVariablesWS * SOAP_FMAC2 soap_instantiate___ns1__getVariablesWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getVariablesWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getVariablesWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getVariablesWS);
		if (size)
			*size = sizeof(struct __ns1__getVariablesWS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getVariablesWS, n);
		if (size)
			*size = n * sizeof(struct __ns1__getVariablesWS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getVariablesWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getVariablesWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getVariablesWS %p -> %p\n", q, p));
	*(struct __ns1__getVariablesWS*)p = *(struct __ns1__getVariablesWS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVariable(struct soap *soap, struct __ns1__getVariable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVariable_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVariable(struct soap *soap, const struct __ns1__getVariable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getVariable(soap, &a->ns1__getVariable_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVariable(struct soap *soap, const char *tag, int id, const struct __ns1__getVariable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getVariable(soap, "ns1:getVariable", -1, &a->ns1__getVariable_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVariable * SOAP_FMAC4 soap_in___ns1__getVariable(struct soap *soap, const char *tag, struct __ns1__getVariable *a, const char *type)
{
	size_t soap_flag_ns1__getVariable_ = 1;
	short soap_flag;
	a = (struct __ns1__getVariable *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVariable, sizeof(struct __ns1__getVariable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVariable(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVariable_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getVariable(soap, "ns1:getVariable", &a->ns1__getVariable_, "ns1:getVariable"))
				{	soap_flag_ns1__getVariable_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVariable(struct soap *soap, const struct __ns1__getVariable *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVariable(soap, tag?tag:"-ns1:getVariable", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVariable * SOAP_FMAC4 soap_get___ns1__getVariable(struct soap *soap, struct __ns1__getVariable *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getVariable * SOAP_FMAC2 soap_instantiate___ns1__getVariable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getVariable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getVariable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getVariable);
		if (size)
			*size = sizeof(struct __ns1__getVariable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getVariable, n);
		if (size)
			*size = n * sizeof(struct __ns1__getVariable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getVariable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getVariable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getVariable %p -> %p\n", q, p));
	*(struct __ns1__getVariable*)p = *(struct __ns1__getVariable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTasks(struct soap *soap, struct __ns1__getTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTasks_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTasks(struct soap *soap, const struct __ns1__getTasks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getTasks(soap, &a->ns1__getTasks_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTasks(struct soap *soap, const char *tag, int id, const struct __ns1__getTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getTasks(soap, "ns1:getTasks", -1, &a->ns1__getTasks_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTasks * SOAP_FMAC4 soap_in___ns1__getTasks(struct soap *soap, const char *tag, struct __ns1__getTasks *a, const char *type)
{
	size_t soap_flag_ns1__getTasks_ = 1;
	short soap_flag;
	a = (struct __ns1__getTasks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTasks, sizeof(struct __ns1__getTasks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTasks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTasks_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getTasks(soap, "ns1:getTasks", &a->ns1__getTasks_, "ns1:getTasks"))
				{	soap_flag_ns1__getTasks_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTasks(struct soap *soap, const struct __ns1__getTasks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTasks(soap, tag?tag:"-ns1:getTasks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTasks * SOAP_FMAC4 soap_get___ns1__getTasks(struct soap *soap, struct __ns1__getTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTasks * SOAP_FMAC2 soap_instantiate___ns1__getTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTasks);
		if (size)
			*size = sizeof(struct __ns1__getTasks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTasks, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTasks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTasks %p -> %p\n", q, p));
	*(struct __ns1__getTasks*)p = *(struct __ns1__getTasks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTask(struct soap *soap, struct __ns1__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTask_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTask(struct soap *soap, const struct __ns1__getTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getTask(soap, &a->ns1__getTask_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTask(struct soap *soap, const char *tag, int id, const struct __ns1__getTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getTask(soap, "ns1:getTask", -1, &a->ns1__getTask_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTask * SOAP_FMAC4 soap_in___ns1__getTask(struct soap *soap, const char *tag, struct __ns1__getTask *a, const char *type)
{
	size_t soap_flag_ns1__getTask_ = 1;
	short soap_flag;
	a = (struct __ns1__getTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTask, sizeof(struct __ns1__getTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTask_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getTask(soap, "ns1:getTask", &a->ns1__getTask_, "ns1:getTask"))
				{	soap_flag_ns1__getTask_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTask(struct soap *soap, const struct __ns1__getTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTask(soap, tag?tag:"-ns1:getTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTask * SOAP_FMAC4 soap_get___ns1__getTask(struct soap *soap, struct __ns1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTask * SOAP_FMAC2 soap_instantiate___ns1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTask);
		if (size)
			*size = sizeof(struct __ns1__getTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTask, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTask %p -> %p\n", q, p));
	*(struct __ns1__getTask*)p = *(struct __ns1__getTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSystemLogsCount(struct soap *soap, struct __ns1__getSystemLogsCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSystemLogsCount_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSystemLogsCount(struct soap *soap, const struct __ns1__getSystemLogsCount *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getSystemLogsCount(soap, &a->ns1__getSystemLogsCount_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSystemLogsCount(struct soap *soap, const char *tag, int id, const struct __ns1__getSystemLogsCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getSystemLogsCount(soap, "ns1:getSystemLogsCount", -1, &a->ns1__getSystemLogsCount_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemLogsCount * SOAP_FMAC4 soap_in___ns1__getSystemLogsCount(struct soap *soap, const char *tag, struct __ns1__getSystemLogsCount *a, const char *type)
{
	size_t soap_flag_ns1__getSystemLogsCount_ = 1;
	short soap_flag;
	a = (struct __ns1__getSystemLogsCount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSystemLogsCount, sizeof(struct __ns1__getSystemLogsCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSystemLogsCount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSystemLogsCount_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getSystemLogsCount(soap, "ns1:getSystemLogsCount", &a->ns1__getSystemLogsCount_, "ns1:getSystemLogsCount"))
				{	soap_flag_ns1__getSystemLogsCount_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSystemLogsCount(struct soap *soap, const struct __ns1__getSystemLogsCount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSystemLogsCount(soap, tag?tag:"-ns1:getSystemLogsCount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemLogsCount * SOAP_FMAC4 soap_get___ns1__getSystemLogsCount(struct soap *soap, struct __ns1__getSystemLogsCount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSystemLogsCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSystemLogsCount * SOAP_FMAC2 soap_instantiate___ns1__getSystemLogsCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSystemLogsCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSystemLogsCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSystemLogsCount);
		if (size)
			*size = sizeof(struct __ns1__getSystemLogsCount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getSystemLogsCount, n);
		if (size)
			*size = n * sizeof(struct __ns1__getSystemLogsCount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getSystemLogsCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSystemLogsCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSystemLogsCount %p -> %p\n", q, p));
	*(struct __ns1__getSystemLogsCount*)p = *(struct __ns1__getSystemLogsCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSystemLogs(struct soap *soap, struct __ns1__getSystemLogs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSystemLogs_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSystemLogs(struct soap *soap, const struct __ns1__getSystemLogs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getSystemLogs(soap, &a->ns1__getSystemLogs_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSystemLogs(struct soap *soap, const char *tag, int id, const struct __ns1__getSystemLogs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getSystemLogs(soap, "ns1:getSystemLogs", -1, &a->ns1__getSystemLogs_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemLogs * SOAP_FMAC4 soap_in___ns1__getSystemLogs(struct soap *soap, const char *tag, struct __ns1__getSystemLogs *a, const char *type)
{
	size_t soap_flag_ns1__getSystemLogs_ = 1;
	short soap_flag;
	a = (struct __ns1__getSystemLogs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSystemLogs, sizeof(struct __ns1__getSystemLogs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSystemLogs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSystemLogs_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getSystemLogs(soap, "ns1:getSystemLogs", &a->ns1__getSystemLogs_, "ns1:getSystemLogs"))
				{	soap_flag_ns1__getSystemLogs_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSystemLogs(struct soap *soap, const struct __ns1__getSystemLogs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSystemLogs(soap, tag?tag:"-ns1:getSystemLogs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSystemLogs * SOAP_FMAC4 soap_get___ns1__getSystemLogs(struct soap *soap, struct __ns1__getSystemLogs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSystemLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSystemLogs * SOAP_FMAC2 soap_instantiate___ns1__getSystemLogs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSystemLogs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSystemLogs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSystemLogs);
		if (size)
			*size = sizeof(struct __ns1__getSystemLogs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getSystemLogs, n);
		if (size)
			*size = n * sizeof(struct __ns1__getSystemLogs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getSystemLogs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSystemLogs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSystemLogs %p -> %p\n", q, p));
	*(struct __ns1__getSystemLogs*)p = *(struct __ns1__getSystemLogs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSwimlanes(struct soap *soap, struct __ns1__getSwimlanes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSwimlanes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSwimlanes(struct soap *soap, const struct __ns1__getSwimlanes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getSwimlanes(soap, &a->ns1__getSwimlanes_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSwimlanes(struct soap *soap, const char *tag, int id, const struct __ns1__getSwimlanes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getSwimlanes(soap, "ns1:getSwimlanes", -1, &a->ns1__getSwimlanes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSwimlanes * SOAP_FMAC4 soap_in___ns1__getSwimlanes(struct soap *soap, const char *tag, struct __ns1__getSwimlanes *a, const char *type)
{
	size_t soap_flag_ns1__getSwimlanes_ = 1;
	short soap_flag;
	a = (struct __ns1__getSwimlanes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSwimlanes, sizeof(struct __ns1__getSwimlanes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSwimlanes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSwimlanes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getSwimlanes(soap, "ns1:getSwimlanes", &a->ns1__getSwimlanes_, "ns1:getSwimlanes"))
				{	soap_flag_ns1__getSwimlanes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSwimlanes(struct soap *soap, const struct __ns1__getSwimlanes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSwimlanes(soap, tag?tag:"-ns1:getSwimlanes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSwimlanes * SOAP_FMAC4 soap_get___ns1__getSwimlanes(struct soap *soap, struct __ns1__getSwimlanes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSwimlanes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSwimlanes * SOAP_FMAC2 soap_instantiate___ns1__getSwimlanes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSwimlanes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSwimlanes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSwimlanes);
		if (size)
			*size = sizeof(struct __ns1__getSwimlanes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getSwimlanes, n);
		if (size)
			*size = n * sizeof(struct __ns1__getSwimlanes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getSwimlanes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSwimlanes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSwimlanes %p -> %p\n", q, p));
	*(struct __ns1__getSwimlanes*)p = *(struct __ns1__getSwimlanes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSubprocesses(struct soap *soap, struct __ns1__getSubprocesses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSubprocesses_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSubprocesses(struct soap *soap, const struct __ns1__getSubprocesses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getSubprocesses(soap, &a->ns1__getSubprocesses_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSubprocesses(struct soap *soap, const char *tag, int id, const struct __ns1__getSubprocesses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getSubprocesses(soap, "ns1:getSubprocesses", -1, &a->ns1__getSubprocesses_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSubprocesses * SOAP_FMAC4 soap_in___ns1__getSubprocesses(struct soap *soap, const char *tag, struct __ns1__getSubprocesses *a, const char *type)
{
	size_t soap_flag_ns1__getSubprocesses_ = 1;
	short soap_flag;
	a = (struct __ns1__getSubprocesses *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSubprocesses, sizeof(struct __ns1__getSubprocesses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSubprocesses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSubprocesses_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getSubprocesses(soap, "ns1:getSubprocesses", &a->ns1__getSubprocesses_, "ns1:getSubprocesses"))
				{	soap_flag_ns1__getSubprocesses_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSubprocesses(struct soap *soap, const struct __ns1__getSubprocesses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSubprocesses(soap, tag?tag:"-ns1:getSubprocesses", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSubprocesses * SOAP_FMAC4 soap_get___ns1__getSubprocesses(struct soap *soap, struct __ns1__getSubprocesses *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSubprocesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getSubprocesses * SOAP_FMAC2 soap_instantiate___ns1__getSubprocesses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSubprocesses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSubprocesses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getSubprocesses);
		if (size)
			*size = sizeof(struct __ns1__getSubprocesses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getSubprocesses, n);
		if (size)
			*size = n * sizeof(struct __ns1__getSubprocesses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getSubprocesses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSubprocesses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSubprocesses %p -> %p\n", q, p));
	*(struct __ns1__getSubprocesses*)p = *(struct __ns1__getSubprocesses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessesCount(struct soap *soap, struct __ns1__getProcessesCount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessesCount_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessesCount(struct soap *soap, const struct __ns1__getProcessesCount *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessesCount(soap, &a->ns1__getProcessesCount_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessesCount(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessesCount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessesCount(soap, "ns1:getProcessesCount", -1, &a->ns1__getProcessesCount_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessesCount * SOAP_FMAC4 soap_in___ns1__getProcessesCount(struct soap *soap, const char *tag, struct __ns1__getProcessesCount *a, const char *type)
{
	size_t soap_flag_ns1__getProcessesCount_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessesCount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessesCount, sizeof(struct __ns1__getProcessesCount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessesCount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessesCount_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessesCount(soap, "ns1:getProcessesCount", &a->ns1__getProcessesCount_, "ns1:getProcessesCount"))
				{	soap_flag_ns1__getProcessesCount_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessesCount(struct soap *soap, const struct __ns1__getProcessesCount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessesCount(soap, tag?tag:"-ns1:getProcessesCount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessesCount * SOAP_FMAC4 soap_get___ns1__getProcessesCount(struct soap *soap, struct __ns1__getProcessesCount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessesCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessesCount * SOAP_FMAC2 soap_instantiate___ns1__getProcessesCount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessesCount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessesCount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessesCount);
		if (size)
			*size = sizeof(struct __ns1__getProcessesCount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessesCount, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessesCount);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessesCount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessesCount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessesCount %p -> %p\n", q, p));
	*(struct __ns1__getProcessesCount*)p = *(struct __ns1__getProcessesCount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessesByFilter(struct soap *soap, struct __ns1__getProcessesByFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessesByFilter_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessesByFilter(struct soap *soap, const struct __ns1__getProcessesByFilter *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessesByFilter(soap, &a->ns1__getProcessesByFilter_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessesByFilter(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessesByFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessesByFilter(soap, "ns1:getProcessesByFilter", -1, &a->ns1__getProcessesByFilter_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessesByFilter * SOAP_FMAC4 soap_in___ns1__getProcessesByFilter(struct soap *soap, const char *tag, struct __ns1__getProcessesByFilter *a, const char *type)
{
	size_t soap_flag_ns1__getProcessesByFilter_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessesByFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessesByFilter, sizeof(struct __ns1__getProcessesByFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessesByFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessesByFilter_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessesByFilter(soap, "ns1:getProcessesByFilter", &a->ns1__getProcessesByFilter_, "ns1:getProcessesByFilter"))
				{	soap_flag_ns1__getProcessesByFilter_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessesByFilter(struct soap *soap, const struct __ns1__getProcessesByFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessesByFilter(soap, tag?tag:"-ns1:getProcessesByFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessesByFilter * SOAP_FMAC4 soap_get___ns1__getProcessesByFilter(struct soap *soap, struct __ns1__getProcessesByFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessesByFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessesByFilter * SOAP_FMAC2 soap_instantiate___ns1__getProcessesByFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessesByFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessesByFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessesByFilter);
		if (size)
			*size = sizeof(struct __ns1__getProcessesByFilter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessesByFilter, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessesByFilter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessesByFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessesByFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessesByFilter %p -> %p\n", q, p));
	*(struct __ns1__getProcessesByFilter*)p = *(struct __ns1__getProcessesByFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcesses(struct soap *soap, struct __ns1__getProcesses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcesses_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcesses(struct soap *soap, const struct __ns1__getProcesses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcesses(soap, &a->ns1__getProcesses_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcesses(struct soap *soap, const char *tag, int id, const struct __ns1__getProcesses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcesses(soap, "ns1:getProcesses", -1, &a->ns1__getProcesses_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcesses * SOAP_FMAC4 soap_in___ns1__getProcesses(struct soap *soap, const char *tag, struct __ns1__getProcesses *a, const char *type)
{
	size_t soap_flag_ns1__getProcesses_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcesses *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcesses, sizeof(struct __ns1__getProcesses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcesses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcesses_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcesses(soap, "ns1:getProcesses", &a->ns1__getProcesses_, "ns1:getProcesses"))
				{	soap_flag_ns1__getProcesses_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcesses(struct soap *soap, const struct __ns1__getProcesses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcesses(soap, tag?tag:"-ns1:getProcesses", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcesses * SOAP_FMAC4 soap_get___ns1__getProcesses(struct soap *soap, struct __ns1__getProcesses *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcesses * SOAP_FMAC2 soap_instantiate___ns1__getProcesses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcesses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcesses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcesses);
		if (size)
			*size = sizeof(struct __ns1__getProcesses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcesses, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcesses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcesses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcesses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcesses %p -> %p\n", q, p));
	*(struct __ns1__getProcesses*)p = *(struct __ns1__getProcesses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessTasks(struct soap *soap, struct __ns1__getProcessTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessTasks_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessTasks(struct soap *soap, const struct __ns1__getProcessTasks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessTasks(soap, &a->ns1__getProcessTasks_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessTasks(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessTasks(soap, "ns1:getProcessTasks", -1, &a->ns1__getProcessTasks_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessTasks * SOAP_FMAC4 soap_in___ns1__getProcessTasks(struct soap *soap, const char *tag, struct __ns1__getProcessTasks *a, const char *type)
{
	size_t soap_flag_ns1__getProcessTasks_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessTasks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessTasks, sizeof(struct __ns1__getProcessTasks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessTasks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessTasks_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessTasks(soap, "ns1:getProcessTasks", &a->ns1__getProcessTasks_, "ns1:getProcessTasks"))
				{	soap_flag_ns1__getProcessTasks_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessTasks(struct soap *soap, const struct __ns1__getProcessTasks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessTasks(soap, tag?tag:"-ns1:getProcessTasks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessTasks * SOAP_FMAC4 soap_get___ns1__getProcessTasks(struct soap *soap, struct __ns1__getProcessTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessTasks * SOAP_FMAC2 soap_instantiate___ns1__getProcessTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessTasks);
		if (size)
			*size = sizeof(struct __ns1__getProcessTasks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessTasks, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessTasks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessTasks %p -> %p\n", q, p));
	*(struct __ns1__getProcessTasks*)p = *(struct __ns1__getProcessTasks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessLogs(struct soap *soap, struct __ns1__getProcessLogs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessLogs_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessLogs(struct soap *soap, const struct __ns1__getProcessLogs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessLogs(soap, &a->ns1__getProcessLogs_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessLogs(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessLogs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessLogs(soap, "ns1:getProcessLogs", -1, &a->ns1__getProcessLogs_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessLogs * SOAP_FMAC4 soap_in___ns1__getProcessLogs(struct soap *soap, const char *tag, struct __ns1__getProcessLogs *a, const char *type)
{
	size_t soap_flag_ns1__getProcessLogs_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessLogs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessLogs, sizeof(struct __ns1__getProcessLogs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessLogs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessLogs_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessLogs(soap, "ns1:getProcessLogs", &a->ns1__getProcessLogs_, "ns1:getProcessLogs"))
				{	soap_flag_ns1__getProcessLogs_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessLogs(struct soap *soap, const struct __ns1__getProcessLogs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessLogs(soap, tag?tag:"-ns1:getProcessLogs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessLogs * SOAP_FMAC4 soap_get___ns1__getProcessLogs(struct soap *soap, struct __ns1__getProcessLogs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessLogs * SOAP_FMAC2 soap_instantiate___ns1__getProcessLogs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessLogs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessLogs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessLogs);
		if (size)
			*size = sizeof(struct __ns1__getProcessLogs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessLogs, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessLogs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessLogs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessLogs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessLogs %p -> %p\n", q, p));
	*(struct __ns1__getProcessLogs*)p = *(struct __ns1__getProcessLogs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessLogValue(struct soap *soap, struct __ns1__getProcessLogValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessLogValue_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessLogValue(struct soap *soap, const struct __ns1__getProcessLogValue *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessLogValue(soap, &a->ns1__getProcessLogValue_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessLogValue(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessLogValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessLogValue(soap, "ns1:getProcessLogValue", -1, &a->ns1__getProcessLogValue_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessLogValue * SOAP_FMAC4 soap_in___ns1__getProcessLogValue(struct soap *soap, const char *tag, struct __ns1__getProcessLogValue *a, const char *type)
{
	size_t soap_flag_ns1__getProcessLogValue_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessLogValue *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessLogValue, sizeof(struct __ns1__getProcessLogValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessLogValue(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessLogValue_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessLogValue(soap, "ns1:getProcessLogValue", &a->ns1__getProcessLogValue_, "ns1:getProcessLogValue"))
				{	soap_flag_ns1__getProcessLogValue_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessLogValue(struct soap *soap, const struct __ns1__getProcessLogValue *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessLogValue(soap, tag?tag:"-ns1:getProcessLogValue", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessLogValue * SOAP_FMAC4 soap_get___ns1__getProcessLogValue(struct soap *soap, struct __ns1__getProcessLogValue *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessLogValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessLogValue * SOAP_FMAC2 soap_instantiate___ns1__getProcessLogValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessLogValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessLogValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessLogValue);
		if (size)
			*size = sizeof(struct __ns1__getProcessLogValue);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessLogValue, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessLogValue);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessLogValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessLogValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessLogValue %p -> %p\n", q, p));
	*(struct __ns1__getProcessLogValue*)p = *(struct __ns1__getProcessLogValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessHistoryDiagramElements(struct soap *soap, struct __ns1__getProcessHistoryDiagramElements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessHistoryDiagramElements_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessHistoryDiagramElements(struct soap *soap, const struct __ns1__getProcessHistoryDiagramElements *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessHistoryDiagramElements(soap, &a->ns1__getProcessHistoryDiagramElements_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessHistoryDiagramElements(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessHistoryDiagramElements *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessHistoryDiagramElements(soap, "ns1:getProcessHistoryDiagramElements", -1, &a->ns1__getProcessHistoryDiagramElements_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessHistoryDiagramElements * SOAP_FMAC4 soap_in___ns1__getProcessHistoryDiagramElements(struct soap *soap, const char *tag, struct __ns1__getProcessHistoryDiagramElements *a, const char *type)
{
	size_t soap_flag_ns1__getProcessHistoryDiagramElements_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessHistoryDiagramElements *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessHistoryDiagramElements, sizeof(struct __ns1__getProcessHistoryDiagramElements), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessHistoryDiagramElements(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessHistoryDiagramElements_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessHistoryDiagramElements(soap, "ns1:getProcessHistoryDiagramElements", &a->ns1__getProcessHistoryDiagramElements_, "ns1:getProcessHistoryDiagramElements"))
				{	soap_flag_ns1__getProcessHistoryDiagramElements_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessHistoryDiagramElements(struct soap *soap, const struct __ns1__getProcessHistoryDiagramElements *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessHistoryDiagramElements(soap, tag?tag:"-ns1:getProcessHistoryDiagramElements", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessHistoryDiagramElements * SOAP_FMAC4 soap_get___ns1__getProcessHistoryDiagramElements(struct soap *soap, struct __ns1__getProcessHistoryDiagramElements *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessHistoryDiagramElements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessHistoryDiagramElements * SOAP_FMAC2 soap_instantiate___ns1__getProcessHistoryDiagramElements(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessHistoryDiagramElements(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessHistoryDiagramElements, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessHistoryDiagramElements);
		if (size)
			*size = sizeof(struct __ns1__getProcessHistoryDiagramElements);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessHistoryDiagramElements, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessHistoryDiagramElements);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessHistoryDiagramElements*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessHistoryDiagramElements(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessHistoryDiagramElements %p -> %p\n", q, p));
	*(struct __ns1__getProcessHistoryDiagramElements*)p = *(struct __ns1__getProcessHistoryDiagramElements*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessHistoryDiagram(struct soap *soap, struct __ns1__getProcessHistoryDiagram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessHistoryDiagram_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessHistoryDiagram(struct soap *soap, const struct __ns1__getProcessHistoryDiagram *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessHistoryDiagram(soap, &a->ns1__getProcessHistoryDiagram_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessHistoryDiagram(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessHistoryDiagram *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessHistoryDiagram(soap, "ns1:getProcessHistoryDiagram", -1, &a->ns1__getProcessHistoryDiagram_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessHistoryDiagram * SOAP_FMAC4 soap_in___ns1__getProcessHistoryDiagram(struct soap *soap, const char *tag, struct __ns1__getProcessHistoryDiagram *a, const char *type)
{
	size_t soap_flag_ns1__getProcessHistoryDiagram_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessHistoryDiagram *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessHistoryDiagram, sizeof(struct __ns1__getProcessHistoryDiagram), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessHistoryDiagram(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessHistoryDiagram_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessHistoryDiagram(soap, "ns1:getProcessHistoryDiagram", &a->ns1__getProcessHistoryDiagram_, "ns1:getProcessHistoryDiagram"))
				{	soap_flag_ns1__getProcessHistoryDiagram_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessHistoryDiagram(struct soap *soap, const struct __ns1__getProcessHistoryDiagram *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessHistoryDiagram(soap, tag?tag:"-ns1:getProcessHistoryDiagram", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessHistoryDiagram * SOAP_FMAC4 soap_get___ns1__getProcessHistoryDiagram(struct soap *soap, struct __ns1__getProcessHistoryDiagram *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessHistoryDiagram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessHistoryDiagram * SOAP_FMAC2 soap_instantiate___ns1__getProcessHistoryDiagram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessHistoryDiagram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessHistoryDiagram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessHistoryDiagram);
		if (size)
			*size = sizeof(struct __ns1__getProcessHistoryDiagram);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessHistoryDiagram, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessHistoryDiagram);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessHistoryDiagram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessHistoryDiagram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessHistoryDiagram %p -> %p\n", q, p));
	*(struct __ns1__getProcessHistoryDiagram*)p = *(struct __ns1__getProcessHistoryDiagram*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessDiagramElements(struct soap *soap, struct __ns1__getProcessDiagramElements *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessDiagramElements_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessDiagramElements(struct soap *soap, const struct __ns1__getProcessDiagramElements *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessDiagramElements(soap, &a->ns1__getProcessDiagramElements_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessDiagramElements(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessDiagramElements *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessDiagramElements(soap, "ns1:getProcessDiagramElements", -1, &a->ns1__getProcessDiagramElements_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessDiagramElements * SOAP_FMAC4 soap_in___ns1__getProcessDiagramElements(struct soap *soap, const char *tag, struct __ns1__getProcessDiagramElements *a, const char *type)
{
	size_t soap_flag_ns1__getProcessDiagramElements_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessDiagramElements *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessDiagramElements, sizeof(struct __ns1__getProcessDiagramElements), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessDiagramElements(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessDiagramElements_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessDiagramElements(soap, "ns1:getProcessDiagramElements", &a->ns1__getProcessDiagramElements_, "ns1:getProcessDiagramElements"))
				{	soap_flag_ns1__getProcessDiagramElements_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessDiagramElements(struct soap *soap, const struct __ns1__getProcessDiagramElements *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessDiagramElements(soap, tag?tag:"-ns1:getProcessDiagramElements", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessDiagramElements * SOAP_FMAC4 soap_get___ns1__getProcessDiagramElements(struct soap *soap, struct __ns1__getProcessDiagramElements *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessDiagramElements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessDiagramElements * SOAP_FMAC2 soap_instantiate___ns1__getProcessDiagramElements(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessDiagramElements(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessDiagramElements, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessDiagramElements);
		if (size)
			*size = sizeof(struct __ns1__getProcessDiagramElements);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessDiagramElements, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessDiagramElements);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessDiagramElements*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessDiagramElements(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessDiagramElements %p -> %p\n", q, p));
	*(struct __ns1__getProcessDiagramElements*)p = *(struct __ns1__getProcessDiagramElements*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessDiagram(struct soap *soap, struct __ns1__getProcessDiagram *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessDiagram_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessDiagram(struct soap *soap, const struct __ns1__getProcessDiagram *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessDiagram(soap, &a->ns1__getProcessDiagram_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessDiagram(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessDiagram *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessDiagram(soap, "ns1:getProcessDiagram", -1, &a->ns1__getProcessDiagram_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessDiagram * SOAP_FMAC4 soap_in___ns1__getProcessDiagram(struct soap *soap, const char *tag, struct __ns1__getProcessDiagram *a, const char *type)
{
	size_t soap_flag_ns1__getProcessDiagram_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessDiagram *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessDiagram, sizeof(struct __ns1__getProcessDiagram), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessDiagram(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessDiagram_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessDiagram(soap, "ns1:getProcessDiagram", &a->ns1__getProcessDiagram_, "ns1:getProcessDiagram"))
				{	soap_flag_ns1__getProcessDiagram_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessDiagram(struct soap *soap, const struct __ns1__getProcessDiagram *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessDiagram(soap, tag?tag:"-ns1:getProcessDiagram", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessDiagram * SOAP_FMAC4 soap_get___ns1__getProcessDiagram(struct soap *soap, struct __ns1__getProcessDiagram *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessDiagram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessDiagram * SOAP_FMAC2 soap_instantiate___ns1__getProcessDiagram(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessDiagram(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessDiagram, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessDiagram);
		if (size)
			*size = sizeof(struct __ns1__getProcessDiagram);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessDiagram, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessDiagram);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessDiagram*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessDiagram(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessDiagram %p -> %p\n", q, p));
	*(struct __ns1__getProcessDiagram*)p = *(struct __ns1__getProcessDiagram*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcess(struct soap *soap, struct __ns1__getProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcess_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcess(struct soap *soap, const struct __ns1__getProcess *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcess(soap, &a->ns1__getProcess_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcess(struct soap *soap, const char *tag, int id, const struct __ns1__getProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcess(soap, "ns1:getProcess", -1, &a->ns1__getProcess_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcess * SOAP_FMAC4 soap_in___ns1__getProcess(struct soap *soap, const char *tag, struct __ns1__getProcess *a, const char *type)
{
	size_t soap_flag_ns1__getProcess_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcess, sizeof(struct __ns1__getProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcess_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcess(soap, "ns1:getProcess", &a->ns1__getProcess_, "ns1:getProcess"))
				{	soap_flag_ns1__getProcess_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcess(struct soap *soap, const struct __ns1__getProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcess(soap, tag?tag:"-ns1:getProcess", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcess * SOAP_FMAC4 soap_get___ns1__getProcess(struct soap *soap, struct __ns1__getProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcess * SOAP_FMAC2 soap_instantiate___ns1__getProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcess);
		if (size)
			*size = sizeof(struct __ns1__getProcess);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcess, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcess);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcess %p -> %p\n", q, p));
	*(struct __ns1__getProcess*)p = *(struct __ns1__getProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getParentProcess(struct soap *soap, struct __ns1__getParentProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getParentProcess_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getParentProcess(struct soap *soap, const struct __ns1__getParentProcess *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getParentProcess(soap, &a->ns1__getParentProcess_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getParentProcess(struct soap *soap, const char *tag, int id, const struct __ns1__getParentProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getParentProcess(soap, "ns1:getParentProcess", -1, &a->ns1__getParentProcess_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getParentProcess * SOAP_FMAC4 soap_in___ns1__getParentProcess(struct soap *soap, const char *tag, struct __ns1__getParentProcess *a, const char *type)
{
	size_t soap_flag_ns1__getParentProcess_ = 1;
	short soap_flag;
	a = (struct __ns1__getParentProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getParentProcess, sizeof(struct __ns1__getParentProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getParentProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getParentProcess_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getParentProcess(soap, "ns1:getParentProcess", &a->ns1__getParentProcess_, "ns1:getParentProcess"))
				{	soap_flag_ns1__getParentProcess_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getParentProcess(struct soap *soap, const struct __ns1__getParentProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getParentProcess(soap, tag?tag:"-ns1:getParentProcess", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getParentProcess * SOAP_FMAC4 soap_get___ns1__getParentProcess(struct soap *soap, struct __ns1__getParentProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getParentProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getParentProcess * SOAP_FMAC2 soap_instantiate___ns1__getParentProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getParentProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getParentProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getParentProcess);
		if (size)
			*size = sizeof(struct __ns1__getParentProcess);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getParentProcess, n);
		if (size)
			*size = n * sizeof(struct __ns1__getParentProcess);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getParentProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getParentProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getParentProcess %p -> %p\n", q, p));
	*(struct __ns1__getParentProcess*)p = *(struct __ns1__getParentProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__completeTaskWS(struct soap *soap, struct __ns1__completeTaskWS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__completeTaskWS_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__completeTaskWS(struct soap *soap, const struct __ns1__completeTaskWS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__completeTaskWS(soap, &a->ns1__completeTaskWS_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__completeTaskWS(struct soap *soap, const char *tag, int id, const struct __ns1__completeTaskWS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__completeTaskWS(soap, "ns1:completeTaskWS", -1, &a->ns1__completeTaskWS_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWS * SOAP_FMAC4 soap_in___ns1__completeTaskWS(struct soap *soap, const char *tag, struct __ns1__completeTaskWS *a, const char *type)
{
	size_t soap_flag_ns1__completeTaskWS_ = 1;
	short soap_flag;
	a = (struct __ns1__completeTaskWS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__completeTaskWS, sizeof(struct __ns1__completeTaskWS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__completeTaskWS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__completeTaskWS_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__completeTaskWS(soap, "ns1:completeTaskWS", &a->ns1__completeTaskWS_, "ns1:completeTaskWS"))
				{	soap_flag_ns1__completeTaskWS_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__completeTaskWS(struct soap *soap, const struct __ns1__completeTaskWS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__completeTaskWS(soap, tag?tag:"-ns1:completeTaskWS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWS * SOAP_FMAC4 soap_get___ns1__completeTaskWS(struct soap *soap, struct __ns1__completeTaskWS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__completeTaskWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__completeTaskWS * SOAP_FMAC2 soap_instantiate___ns1__completeTaskWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__completeTaskWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__completeTaskWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__completeTaskWS);
		if (size)
			*size = sizeof(struct __ns1__completeTaskWS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__completeTaskWS, n);
		if (size)
			*size = n * sizeof(struct __ns1__completeTaskWS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__completeTaskWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__completeTaskWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__completeTaskWS %p -> %p\n", q, p));
	*(struct __ns1__completeTaskWS*)p = *(struct __ns1__completeTaskWS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__completeTaskWSResponse(struct soap *soap, struct __ns1__completeTaskWSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__completeTaskWSResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__completeTaskWSResponse(struct soap *soap, const struct __ns1__completeTaskWSResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__completeTaskWSResponse(soap, &a->ns1__completeTaskWSResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__completeTaskWSResponse(struct soap *soap, const char *tag, int id, const struct __ns1__completeTaskWSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__completeTaskWSResponse_)
		soap_element_result(soap, "ns1:completeTaskWSResponse");
	if (soap_out_PointerTons1__completeTaskWSResponse(soap, "ns1:completeTaskWSResponse", -1, &a->ns1__completeTaskWSResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWSResponse * SOAP_FMAC4 soap_in___ns1__completeTaskWSResponse(struct soap *soap, const char *tag, struct __ns1__completeTaskWSResponse *a, const char *type)
{
	size_t soap_flag_ns1__completeTaskWSResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__completeTaskWSResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__completeTaskWSResponse, sizeof(struct __ns1__completeTaskWSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__completeTaskWSResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__completeTaskWSResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__completeTaskWSResponse(soap, "ns1:completeTaskWSResponse", &a->ns1__completeTaskWSResponse_, "ns1:completeTaskWSResponse"))
				{	soap_flag_ns1__completeTaskWSResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:completeTaskWSResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__completeTaskWSResponse(struct soap *soap, const struct __ns1__completeTaskWSResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__completeTaskWSResponse(soap, tag?tag:"-ns1:completeTaskWSResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWSResponse * SOAP_FMAC4 soap_get___ns1__completeTaskWSResponse(struct soap *soap, struct __ns1__completeTaskWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__completeTaskWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__completeTaskWSResponse * SOAP_FMAC2 soap_instantiate___ns1__completeTaskWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__completeTaskWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__completeTaskWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__completeTaskWSResponse);
		if (size)
			*size = sizeof(struct __ns1__completeTaskWSResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__completeTaskWSResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__completeTaskWSResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__completeTaskWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__completeTaskWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__completeTaskWSResponse %p -> %p\n", q, p));
	*(struct __ns1__completeTaskWSResponse*)p = *(struct __ns1__completeTaskWSResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cancelProcess(struct soap *soap, struct __ns1__cancelProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cancelProcess_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cancelProcess(struct soap *soap, const struct __ns1__cancelProcess *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__cancelProcess(soap, &a->ns1__cancelProcess_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cancelProcess(struct soap *soap, const char *tag, int id, const struct __ns1__cancelProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__cancelProcess(soap, "ns1:cancelProcess", -1, &a->ns1__cancelProcess_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelProcess * SOAP_FMAC4 soap_in___ns1__cancelProcess(struct soap *soap, const char *tag, struct __ns1__cancelProcess *a, const char *type)
{
	size_t soap_flag_ns1__cancelProcess_ = 1;
	short soap_flag;
	a = (struct __ns1__cancelProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cancelProcess, sizeof(struct __ns1__cancelProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cancelProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cancelProcess_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cancelProcess(soap, "ns1:cancelProcess", &a->ns1__cancelProcess_, "ns1:cancelProcess"))
				{	soap_flag_ns1__cancelProcess_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cancelProcess(struct soap *soap, const struct __ns1__cancelProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cancelProcess(soap, tag?tag:"-ns1:cancelProcess", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelProcess * SOAP_FMAC4 soap_get___ns1__cancelProcess(struct soap *soap, struct __ns1__cancelProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cancelProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cancelProcess * SOAP_FMAC2 soap_instantiate___ns1__cancelProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cancelProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cancelProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cancelProcess);
		if (size)
			*size = sizeof(struct __ns1__cancelProcess);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cancelProcess, n);
		if (size)
			*size = n * sizeof(struct __ns1__cancelProcess);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cancelProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cancelProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cancelProcess %p -> %p\n", q, p));
	*(struct __ns1__cancelProcess*)p = *(struct __ns1__cancelProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cancelProcessResponse(struct soap *soap, struct __ns1__cancelProcessResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__cancelProcessResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cancelProcessResponse(struct soap *soap, const struct __ns1__cancelProcessResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__cancelProcessResponse(soap, &a->ns1__cancelProcessResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cancelProcessResponse(struct soap *soap, const char *tag, int id, const struct __ns1__cancelProcessResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__cancelProcessResponse_)
		soap_element_result(soap, "ns1:cancelProcessResponse");
	if (soap_out_PointerTons1__cancelProcessResponse(soap, "ns1:cancelProcessResponse", -1, &a->ns1__cancelProcessResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelProcessResponse * SOAP_FMAC4 soap_in___ns1__cancelProcessResponse(struct soap *soap, const char *tag, struct __ns1__cancelProcessResponse *a, const char *type)
{
	size_t soap_flag_ns1__cancelProcessResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__cancelProcessResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cancelProcessResponse, sizeof(struct __ns1__cancelProcessResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cancelProcessResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__cancelProcessResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cancelProcessResponse(soap, "ns1:cancelProcessResponse", &a->ns1__cancelProcessResponse_, "ns1:cancelProcessResponse"))
				{	soap_flag_ns1__cancelProcessResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:cancelProcessResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cancelProcessResponse(struct soap *soap, const struct __ns1__cancelProcessResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__cancelProcessResponse(soap, tag?tag:"-ns1:cancelProcessResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelProcessResponse * SOAP_FMAC4 soap_get___ns1__cancelProcessResponse(struct soap *soap, struct __ns1__cancelProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cancelProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__cancelProcessResponse * SOAP_FMAC2 soap_instantiate___ns1__cancelProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cancelProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__cancelProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__cancelProcessResponse);
		if (size)
			*size = sizeof(struct __ns1__cancelProcessResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__cancelProcessResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__cancelProcessResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__cancelProcessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__cancelProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__cancelProcessResponse %p -> %p\n", q, p));
	*(struct __ns1__cancelProcessResponse*)p = *(struct __ns1__cancelProcessResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__assignTask(struct soap *soap, struct __ns1__assignTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__assignTask_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__assignTask(struct soap *soap, const struct __ns1__assignTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__assignTask(soap, &a->ns1__assignTask_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__assignTask(struct soap *soap, const char *tag, int id, const struct __ns1__assignTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__assignTask(soap, "ns1:assignTask", -1, &a->ns1__assignTask_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTask * SOAP_FMAC4 soap_in___ns1__assignTask(struct soap *soap, const char *tag, struct __ns1__assignTask *a, const char *type)
{
	size_t soap_flag_ns1__assignTask_ = 1;
	short soap_flag;
	a = (struct __ns1__assignTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__assignTask, sizeof(struct __ns1__assignTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__assignTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__assignTask_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__assignTask(soap, "ns1:assignTask", &a->ns1__assignTask_, "ns1:assignTask"))
				{	soap_flag_ns1__assignTask_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__assignTask(struct soap *soap, const struct __ns1__assignTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__assignTask(soap, tag?tag:"-ns1:assignTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTask * SOAP_FMAC4 soap_get___ns1__assignTask(struct soap *soap, struct __ns1__assignTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__assignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__assignTask * SOAP_FMAC2 soap_instantiate___ns1__assignTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__assignTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__assignTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__assignTask);
		if (size)
			*size = sizeof(struct __ns1__assignTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__assignTask, n);
		if (size)
			*size = n * sizeof(struct __ns1__assignTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__assignTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__assignTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__assignTask %p -> %p\n", q, p));
	*(struct __ns1__assignTask*)p = *(struct __ns1__assignTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__assignTaskResponse(struct soap *soap, struct __ns1__assignTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__assignTaskResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__assignTaskResponse(struct soap *soap, const struct __ns1__assignTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__assignTaskResponse(soap, &a->ns1__assignTaskResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__assignTaskResponse(struct soap *soap, const char *tag, int id, const struct __ns1__assignTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__assignTaskResponse_)
		soap_element_result(soap, "ns1:assignTaskResponse");
	if (soap_out_PointerTons1__assignTaskResponse(soap, "ns1:assignTaskResponse", -1, &a->ns1__assignTaskResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTaskResponse * SOAP_FMAC4 soap_in___ns1__assignTaskResponse(struct soap *soap, const char *tag, struct __ns1__assignTaskResponse *a, const char *type)
{
	size_t soap_flag_ns1__assignTaskResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__assignTaskResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__assignTaskResponse, sizeof(struct __ns1__assignTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__assignTaskResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__assignTaskResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__assignTaskResponse(soap, "ns1:assignTaskResponse", &a->ns1__assignTaskResponse_, "ns1:assignTaskResponse"))
				{	soap_flag_ns1__assignTaskResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:assignTaskResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__assignTaskResponse(struct soap *soap, const struct __ns1__assignTaskResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__assignTaskResponse(soap, tag?tag:"-ns1:assignTaskResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTaskResponse * SOAP_FMAC4 soap_get___ns1__assignTaskResponse(struct soap *soap, struct __ns1__assignTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__assignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__assignTaskResponse * SOAP_FMAC2 soap_instantiate___ns1__assignTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__assignTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__assignTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__assignTaskResponse);
		if (size)
			*size = sizeof(struct __ns1__assignTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__assignTaskResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__assignTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__assignTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__assignTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__assignTaskResponse %p -> %p\n", q, p));
	*(struct __ns1__assignTaskResponse*)p = *(struct __ns1__assignTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__assignSwimlane(struct soap *soap, struct __ns1__assignSwimlane *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__assignSwimlane_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__assignSwimlane(struct soap *soap, const struct __ns1__assignSwimlane *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__assignSwimlane(soap, &a->ns1__assignSwimlane_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__assignSwimlane(struct soap *soap, const char *tag, int id, const struct __ns1__assignSwimlane *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__assignSwimlane(soap, "ns1:assignSwimlane", -1, &a->ns1__assignSwimlane_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignSwimlane * SOAP_FMAC4 soap_in___ns1__assignSwimlane(struct soap *soap, const char *tag, struct __ns1__assignSwimlane *a, const char *type)
{
	size_t soap_flag_ns1__assignSwimlane_ = 1;
	short soap_flag;
	a = (struct __ns1__assignSwimlane *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__assignSwimlane, sizeof(struct __ns1__assignSwimlane), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__assignSwimlane(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__assignSwimlane_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__assignSwimlane(soap, "ns1:assignSwimlane", &a->ns1__assignSwimlane_, "ns1:assignSwimlane"))
				{	soap_flag_ns1__assignSwimlane_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__assignSwimlane(struct soap *soap, const struct __ns1__assignSwimlane *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__assignSwimlane(soap, tag?tag:"-ns1:assignSwimlane", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignSwimlane * SOAP_FMAC4 soap_get___ns1__assignSwimlane(struct soap *soap, struct __ns1__assignSwimlane *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__assignSwimlane(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__assignSwimlane * SOAP_FMAC2 soap_instantiate___ns1__assignSwimlane(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__assignSwimlane(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__assignSwimlane, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__assignSwimlane);
		if (size)
			*size = sizeof(struct __ns1__assignSwimlane);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__assignSwimlane, n);
		if (size)
			*size = n * sizeof(struct __ns1__assignSwimlane);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__assignSwimlane*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__assignSwimlane(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__assignSwimlane %p -> %p\n", q, p));
	*(struct __ns1__assignSwimlane*)p = *(struct __ns1__assignSwimlane*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__assignSwimlaneResponse(struct soap *soap, struct __ns1__assignSwimlaneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__assignSwimlaneResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__assignSwimlaneResponse(struct soap *soap, const struct __ns1__assignSwimlaneResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__assignSwimlaneResponse(soap, &a->ns1__assignSwimlaneResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__assignSwimlaneResponse(struct soap *soap, const char *tag, int id, const struct __ns1__assignSwimlaneResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__assignSwimlaneResponse_)
		soap_element_result(soap, "ns1:assignSwimlaneResponse");
	if (soap_out_PointerTons1__assignSwimlaneResponse(soap, "ns1:assignSwimlaneResponse", -1, &a->ns1__assignSwimlaneResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignSwimlaneResponse * SOAP_FMAC4 soap_in___ns1__assignSwimlaneResponse(struct soap *soap, const char *tag, struct __ns1__assignSwimlaneResponse *a, const char *type)
{
	size_t soap_flag_ns1__assignSwimlaneResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__assignSwimlaneResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__assignSwimlaneResponse, sizeof(struct __ns1__assignSwimlaneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__assignSwimlaneResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__assignSwimlaneResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__assignSwimlaneResponse(soap, "ns1:assignSwimlaneResponse", &a->ns1__assignSwimlaneResponse_, "ns1:assignSwimlaneResponse"))
				{	soap_flag_ns1__assignSwimlaneResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:assignSwimlaneResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__assignSwimlaneResponse(struct soap *soap, const struct __ns1__assignSwimlaneResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__assignSwimlaneResponse(soap, tag?tag:"-ns1:assignSwimlaneResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignSwimlaneResponse * SOAP_FMAC4 soap_get___ns1__assignSwimlaneResponse(struct soap *soap, struct __ns1__assignSwimlaneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__assignSwimlaneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__assignSwimlaneResponse * SOAP_FMAC2 soap_instantiate___ns1__assignSwimlaneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__assignSwimlaneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__assignSwimlaneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__assignSwimlaneResponse);
		if (size)
			*size = sizeof(struct __ns1__assignSwimlaneResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__assignSwimlaneResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__assignSwimlaneResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__assignSwimlaneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__assignSwimlaneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__assignSwimlaneResponse %p -> %p\n", q, p));
	*(struct __ns1__assignSwimlaneResponse*)p = *(struct __ns1__assignSwimlaneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateByLoginPassword(struct soap *soap, struct __ns1__authenticateByLoginPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateByLoginPassword_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateByLoginPassword(struct soap *soap, const struct __ns1__authenticateByLoginPassword *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateByLoginPassword(soap, &a->ns1__authenticateByLoginPassword_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateByLoginPassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__authenticateByLoginPassword(soap, "ns1:authenticateByLoginPassword", -1, &a->ns1__authenticateByLoginPassword_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_in___ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, struct __ns1__authenticateByLoginPassword *a, const char *type)
{
	size_t soap_flag_ns1__authenticateByLoginPassword_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateByLoginPassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateByLoginPassword, sizeof(struct __ns1__authenticateByLoginPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateByLoginPassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateByLoginPassword_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateByLoginPassword(soap, "ns1:authenticateByLoginPassword", &a->ns1__authenticateByLoginPassword_, "ns1:authenticateByLoginPassword"))
				{	soap_flag_ns1__authenticateByLoginPassword_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateByLoginPassword(struct soap *soap, const struct __ns1__authenticateByLoginPassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateByLoginPassword(soap, tag?tag:"-ns1:authenticateByLoginPassword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_get___ns1__authenticateByLoginPassword(struct soap *soap, struct __ns1__authenticateByLoginPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateByLoginPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateByLoginPassword * SOAP_FMAC2 soap_instantiate___ns1__authenticateByLoginPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateByLoginPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateByLoginPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateByLoginPassword);
		if (size)
			*size = sizeof(struct __ns1__authenticateByLoginPassword);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__authenticateByLoginPassword, n);
		if (size)
			*size = n * sizeof(struct __ns1__authenticateByLoginPassword);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__authenticateByLoginPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateByLoginPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateByLoginPassword %p -> %p\n", q, p));
	*(struct __ns1__authenticateByLoginPassword*)p = *(struct __ns1__authenticateByLoginPassword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateByKerberos(struct soap *soap, struct __ns1__authenticateByKerberos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateByKerberos_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateByKerberos(struct soap *soap, const struct __ns1__authenticateByKerberos *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateByKerberos(soap, &a->ns1__authenticateByKerberos_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateByKerberos(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateByKerberos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__authenticateByKerberos(soap, "ns1:authenticateByKerberos", -1, &a->ns1__authenticateByKerberos_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByKerberos * SOAP_FMAC4 soap_in___ns1__authenticateByKerberos(struct soap *soap, const char *tag, struct __ns1__authenticateByKerberos *a, const char *type)
{
	size_t soap_flag_ns1__authenticateByKerberos_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateByKerberos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateByKerberos, sizeof(struct __ns1__authenticateByKerberos), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateByKerberos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateByKerberos_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateByKerberos(soap, "ns1:authenticateByKerberos", &a->ns1__authenticateByKerberos_, "ns1:authenticateByKerberos"))
				{	soap_flag_ns1__authenticateByKerberos_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateByKerberos(struct soap *soap, const struct __ns1__authenticateByKerberos *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateByKerberos(soap, tag?tag:"-ns1:authenticateByKerberos", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByKerberos * SOAP_FMAC4 soap_get___ns1__authenticateByKerberos(struct soap *soap, struct __ns1__authenticateByKerberos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateByKerberos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateByKerberos * SOAP_FMAC2 soap_instantiate___ns1__authenticateByKerberos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateByKerberos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateByKerberos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateByKerberos);
		if (size)
			*size = sizeof(struct __ns1__authenticateByKerberos);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__authenticateByKerberos, n);
		if (size)
			*size = n * sizeof(struct __ns1__authenticateByKerberos);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__authenticateByKerberos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateByKerberos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateByKerberos %p -> %p\n", q, p));
	*(struct __ns1__authenticateByKerberos*)p = *(struct __ns1__authenticateByKerberos*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateByCallerPrincipal(struct soap *soap, struct __ns1__authenticateByCallerPrincipal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateByCallerPrincipal_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateByCallerPrincipal(struct soap *soap, const struct __ns1__authenticateByCallerPrincipal *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateByCallerPrincipal(soap, &a->ns1__authenticateByCallerPrincipal_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateByCallerPrincipal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__authenticateByCallerPrincipal(soap, "ns1:authenticateByCallerPrincipal", -1, &a->ns1__authenticateByCallerPrincipal_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_in___ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, struct __ns1__authenticateByCallerPrincipal *a, const char *type)
{
	size_t soap_flag_ns1__authenticateByCallerPrincipal_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateByCallerPrincipal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateByCallerPrincipal, sizeof(struct __ns1__authenticateByCallerPrincipal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateByCallerPrincipal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateByCallerPrincipal_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateByCallerPrincipal(soap, "ns1:authenticateByCallerPrincipal", &a->ns1__authenticateByCallerPrincipal_, "ns1:authenticateByCallerPrincipal"))
				{	soap_flag_ns1__authenticateByCallerPrincipal_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateByCallerPrincipal(struct soap *soap, const struct __ns1__authenticateByCallerPrincipal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateByCallerPrincipal(soap, tag?tag:"-ns1:authenticateByCallerPrincipal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_get___ns1__authenticateByCallerPrincipal(struct soap *soap, struct __ns1__authenticateByCallerPrincipal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateByCallerPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateByCallerPrincipal * SOAP_FMAC2 soap_instantiate___ns1__authenticateByCallerPrincipal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateByCallerPrincipal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateByCallerPrincipal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateByCallerPrincipal);
		if (size)
			*size = sizeof(struct __ns1__authenticateByCallerPrincipal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__authenticateByCallerPrincipal, n);
		if (size)
			*size = n * sizeof(struct __ns1__authenticateByCallerPrincipal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__authenticateByCallerPrincipal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateByCallerPrincipal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateByCallerPrincipal %p -> %p\n", q, p));
	*(struct __ns1__authenticateByCallerPrincipal*)p = *(struct __ns1__authenticateByCallerPrincipal*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateVariablesWSResponse(struct soap *soap, ns1__updateVariablesWSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateVariablesWSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateVariablesWSResponse(struct soap *soap, const char *tag, int id, ns1__updateVariablesWSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateVariablesWSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateVariablesWSResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateVariablesWSResponse(struct soap *soap, const char *tag, ns1__updateVariablesWSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateVariablesWSResponse **)soap_malloc(soap, sizeof(ns1__updateVariablesWSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateVariablesWSResponse *)soap_instantiate_ns1__updateVariablesWSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateVariablesWSResponse ** p = (ns1__updateVariablesWSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateVariablesWSResponse, sizeof(ns1__updateVariablesWSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateVariablesWSResponse(struct soap *soap, ns1__updateVariablesWSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateVariablesWSResponse);
	if (soap_out_PointerTons1__updateVariablesWSResponse(soap, tag?tag:"ns1:updateVariablesWSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateVariablesWSResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateVariablesWSResponse(struct soap *soap, ns1__updateVariablesWSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateVariablesWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateVariablesWS(struct soap *soap, ns1__updateVariablesWS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateVariablesWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateVariablesWS(struct soap *soap, const char *tag, int id, ns1__updateVariablesWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateVariablesWS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateVariablesWS ** SOAP_FMAC4 soap_in_PointerTons1__updateVariablesWS(struct soap *soap, const char *tag, ns1__updateVariablesWS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateVariablesWS **)soap_malloc(soap, sizeof(ns1__updateVariablesWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateVariablesWS *)soap_instantiate_ns1__updateVariablesWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateVariablesWS ** p = (ns1__updateVariablesWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateVariablesWS, sizeof(ns1__updateVariablesWS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateVariablesWS(struct soap *soap, ns1__updateVariablesWS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateVariablesWS);
	if (soap_out_PointerTons1__updateVariablesWS(soap, tag?tag:"ns1:updateVariablesWS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateVariablesWS ** SOAP_FMAC4 soap_get_PointerTons1__updateVariablesWS(struct soap *soap, ns1__updateVariablesWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateVariablesWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__startProcessWSResponse(struct soap *soap, ns1__startProcessWSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__startProcessWSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__startProcessWSResponse(struct soap *soap, const char *tag, int id, ns1__startProcessWSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__startProcessWSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__startProcessWSResponse ** SOAP_FMAC4 soap_in_PointerTons1__startProcessWSResponse(struct soap *soap, const char *tag, ns1__startProcessWSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__startProcessWSResponse **)soap_malloc(soap, sizeof(ns1__startProcessWSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__startProcessWSResponse *)soap_instantiate_ns1__startProcessWSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__startProcessWSResponse ** p = (ns1__startProcessWSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__startProcessWSResponse, sizeof(ns1__startProcessWSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__startProcessWSResponse(struct soap *soap, ns1__startProcessWSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__startProcessWSResponse);
	if (soap_out_PointerTons1__startProcessWSResponse(soap, tag?tag:"ns1:startProcessWSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__startProcessWSResponse ** SOAP_FMAC4 soap_get_PointerTons1__startProcessWSResponse(struct soap *soap, ns1__startProcessWSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__startProcessWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__startProcessWS(struct soap *soap, ns1__startProcessWS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__startProcessWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__startProcessWS(struct soap *soap, const char *tag, int id, ns1__startProcessWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__startProcessWS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__startProcessWS ** SOAP_FMAC4 soap_in_PointerTons1__startProcessWS(struct soap *soap, const char *tag, ns1__startProcessWS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__startProcessWS **)soap_malloc(soap, sizeof(ns1__startProcessWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__startProcessWS *)soap_instantiate_ns1__startProcessWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__startProcessWS ** p = (ns1__startProcessWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__startProcessWS, sizeof(ns1__startProcessWS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__startProcessWS(struct soap *soap, ns1__startProcessWS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__startProcessWS);
	if (soap_out_PointerTons1__startProcessWS(soap, tag?tag:"ns1:startProcessWS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__startProcessWS ** SOAP_FMAC4 soap_get_PointerTons1__startProcessWS(struct soap *soap, ns1__startProcessWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__startProcessWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeProcessesResponse(struct soap *soap, ns1__removeProcessesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeProcessesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeProcessesResponse(struct soap *soap, const char *tag, int id, ns1__removeProcessesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeProcessesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeProcessesResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeProcessesResponse(struct soap *soap, const char *tag, ns1__removeProcessesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeProcessesResponse **)soap_malloc(soap, sizeof(ns1__removeProcessesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeProcessesResponse *)soap_instantiate_ns1__removeProcessesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeProcessesResponse ** p = (ns1__removeProcessesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeProcessesResponse, sizeof(ns1__removeProcessesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeProcessesResponse(struct soap *soap, ns1__removeProcessesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeProcessesResponse);
	if (soap_out_PointerTons1__removeProcessesResponse(soap, tag?tag:"ns1:removeProcessesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeProcessesResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeProcessesResponse(struct soap *soap, ns1__removeProcessesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeProcessesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeProcesses(struct soap *soap, ns1__removeProcesses *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeProcesses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeProcesses(struct soap *soap, const char *tag, int id, ns1__removeProcesses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeProcesses);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeProcesses ** SOAP_FMAC4 soap_in_PointerTons1__removeProcesses(struct soap *soap, const char *tag, ns1__removeProcesses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeProcesses **)soap_malloc(soap, sizeof(ns1__removeProcesses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeProcesses *)soap_instantiate_ns1__removeProcesses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeProcesses ** p = (ns1__removeProcesses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeProcesses, sizeof(ns1__removeProcesses), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeProcesses(struct soap *soap, ns1__removeProcesses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeProcesses);
	if (soap_out_PointerTons1__removeProcesses(soap, tag?tag:"ns1:removeProcesses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__removeProcesses ** SOAP_FMAC4 soap_get_PointerTons1__removeProcesses(struct soap *soap, ns1__removeProcesses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeProcesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__markTaskOpenedResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__markTaskOpenedResponse(struct soap *soap, const char *tag, int id, ns1__markTaskOpenedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__markTaskOpenedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse ** SOAP_FMAC4 soap_in_PointerTons1__markTaskOpenedResponse(struct soap *soap, const char *tag, ns1__markTaskOpenedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__markTaskOpenedResponse **)soap_malloc(soap, sizeof(ns1__markTaskOpenedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__markTaskOpenedResponse *)soap_instantiate_ns1__markTaskOpenedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__markTaskOpenedResponse ** p = (ns1__markTaskOpenedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpenedResponse, sizeof(ns1__markTaskOpenedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__markTaskOpenedResponse);
	if (soap_out_PointerTons1__markTaskOpenedResponse(soap, tag?tag:"ns1:markTaskOpenedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse ** SOAP_FMAC4 soap_get_PointerTons1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__markTaskOpenedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__markTaskOpened(struct soap *soap, ns1__markTaskOpened *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__markTaskOpened))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__markTaskOpened(struct soap *soap, const char *tag, int id, ns1__markTaskOpened *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__markTaskOpened);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__markTaskOpened ** SOAP_FMAC4 soap_in_PointerTons1__markTaskOpened(struct soap *soap, const char *tag, ns1__markTaskOpened **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__markTaskOpened **)soap_malloc(soap, sizeof(ns1__markTaskOpened *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__markTaskOpened *)soap_instantiate_ns1__markTaskOpened(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__markTaskOpened ** p = (ns1__markTaskOpened **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpened, sizeof(ns1__markTaskOpened), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__markTaskOpened(struct soap *soap, ns1__markTaskOpened *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__markTaskOpened);
	if (soap_out_PointerTons1__markTaskOpened(soap, tag?tag:"ns1:markTaskOpened", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__markTaskOpened ** SOAP_FMAC4 soap_get_PointerTons1__markTaskOpened(struct soap *soap, ns1__markTaskOpened **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__markTaskOpened(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getVariablesWSResponse(struct soap *soap, ns1__getVariablesWSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getVariablesWSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getVariablesWSResponse(struct soap *soap, const char *tag, int id, ns1__getVariablesWSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getVariablesWSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getVariablesWSResponse ** SOAP_FMAC4 soap_in_PointerTons1__getVariablesWSResponse(struct soap *soap, const char *tag, ns1__getVariablesWSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getVariablesWSResponse **)soap_malloc(soap, sizeof(ns1__getVariablesWSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getVariablesWSResponse *)soap_instantiate_ns1__getVariablesWSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getVariablesWSResponse ** p = (ns1__getVariablesWSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariablesWSResponse, sizeof(ns1__getVariablesWSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getVariablesWSResponse(struct soap *soap, ns1__getVariablesWSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getVariablesWSResponse);
	if (soap_out_PointerTons1__getVariablesWSResponse(soap, tag?tag:"ns1:getVariablesWSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getVariablesWSResponse ** SOAP_FMAC4 soap_get_PointerTons1__getVariablesWSResponse(struct soap *soap, ns1__getVariablesWSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getVariablesWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getVariablesWS(struct soap *soap, ns1__getVariablesWS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getVariablesWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getVariablesWS(struct soap *soap, const char *tag, int id, ns1__getVariablesWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getVariablesWS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getVariablesWS ** SOAP_FMAC4 soap_in_PointerTons1__getVariablesWS(struct soap *soap, const char *tag, ns1__getVariablesWS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getVariablesWS **)soap_malloc(soap, sizeof(ns1__getVariablesWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getVariablesWS *)soap_instantiate_ns1__getVariablesWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getVariablesWS ** p = (ns1__getVariablesWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariablesWS, sizeof(ns1__getVariablesWS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getVariablesWS(struct soap *soap, ns1__getVariablesWS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getVariablesWS);
	if (soap_out_PointerTons1__getVariablesWS(soap, tag?tag:"ns1:getVariablesWS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getVariablesWS ** SOAP_FMAC4 soap_get_PointerTons1__getVariablesWS(struct soap *soap, ns1__getVariablesWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getVariablesWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getVariableResponse(struct soap *soap, ns1__getVariableResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getVariableResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getVariableResponse(struct soap *soap, const char *tag, int id, ns1__getVariableResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getVariableResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getVariableResponse ** SOAP_FMAC4 soap_in_PointerTons1__getVariableResponse(struct soap *soap, const char *tag, ns1__getVariableResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getVariableResponse **)soap_malloc(soap, sizeof(ns1__getVariableResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getVariableResponse *)soap_instantiate_ns1__getVariableResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getVariableResponse ** p = (ns1__getVariableResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariableResponse, sizeof(ns1__getVariableResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getVariableResponse(struct soap *soap, ns1__getVariableResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getVariableResponse);
	if (soap_out_PointerTons1__getVariableResponse(soap, tag?tag:"ns1:getVariableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getVariableResponse ** SOAP_FMAC4 soap_get_PointerTons1__getVariableResponse(struct soap *soap, ns1__getVariableResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getVariableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getVariable(struct soap *soap, ns1__getVariable *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getVariable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getVariable(struct soap *soap, const char *tag, int id, ns1__getVariable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getVariable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getVariable ** SOAP_FMAC4 soap_in_PointerTons1__getVariable(struct soap *soap, const char *tag, ns1__getVariable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getVariable **)soap_malloc(soap, sizeof(ns1__getVariable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getVariable *)soap_instantiate_ns1__getVariable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getVariable ** p = (ns1__getVariable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariable, sizeof(ns1__getVariable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getVariable(struct soap *soap, ns1__getVariable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getVariable);
	if (soap_out_PointerTons1__getVariable(soap, tag?tag:"ns1:getVariable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getVariable ** SOAP_FMAC4 soap_get_PointerTons1__getVariable(struct soap *soap, ns1__getVariable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTasksResponse(struct soap *soap, ns1__getTasksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTasksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTasksResponse(struct soap *soap, const char *tag, int id, ns1__getTasksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTasksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTasksResponse ** SOAP_FMAC4 soap_in_PointerTons1__getTasksResponse(struct soap *soap, const char *tag, ns1__getTasksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTasksResponse **)soap_malloc(soap, sizeof(ns1__getTasksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTasksResponse *)soap_instantiate_ns1__getTasksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTasksResponse ** p = (ns1__getTasksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasksResponse, sizeof(ns1__getTasksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTasksResponse(struct soap *soap, ns1__getTasksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTasksResponse);
	if (soap_out_PointerTons1__getTasksResponse(soap, tag?tag:"ns1:getTasksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTasksResponse ** SOAP_FMAC4 soap_get_PointerTons1__getTasksResponse(struct soap *soap, ns1__getTasksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTasks(struct soap *soap, ns1__getTasks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTasks(struct soap *soap, const char *tag, int id, ns1__getTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTasks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTasks ** SOAP_FMAC4 soap_in_PointerTons1__getTasks(struct soap *soap, const char *tag, ns1__getTasks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTasks **)soap_malloc(soap, sizeof(ns1__getTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTasks *)soap_instantiate_ns1__getTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTasks ** p = (ns1__getTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasks, sizeof(ns1__getTasks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTasks(struct soap *soap, ns1__getTasks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTasks);
	if (soap_out_PointerTons1__getTasks(soap, tag?tag:"ns1:getTasks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTasks ** SOAP_FMAC4 soap_get_PointerTons1__getTasks(struct soap *soap, ns1__getTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTaskResponse(struct soap *soap, ns1__getTaskResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTaskResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTaskResponse(struct soap *soap, const char *tag, int id, ns1__getTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTaskResponse ** SOAP_FMAC4 soap_in_PointerTons1__getTaskResponse(struct soap *soap, const char *tag, ns1__getTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTaskResponse **)soap_malloc(soap, sizeof(ns1__getTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTaskResponse *)soap_instantiate_ns1__getTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTaskResponse ** p = (ns1__getTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTaskResponse, sizeof(ns1__getTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTaskResponse(struct soap *soap, ns1__getTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTaskResponse);
	if (soap_out_PointerTons1__getTaskResponse(soap, tag?tag:"ns1:getTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTaskResponse ** SOAP_FMAC4 soap_get_PointerTons1__getTaskResponse(struct soap *soap, ns1__getTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTask(struct soap *soap, ns1__getTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTask(struct soap *soap, const char *tag, int id, ns1__getTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTask ** SOAP_FMAC4 soap_in_PointerTons1__getTask(struct soap *soap, const char *tag, ns1__getTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTask **)soap_malloc(soap, sizeof(ns1__getTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTask *)soap_instantiate_ns1__getTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTask ** p = (ns1__getTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTask, sizeof(ns1__getTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTask(struct soap *soap, ns1__getTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTask);
	if (soap_out_PointerTons1__getTask(soap, tag?tag:"ns1:getTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTask ** SOAP_FMAC4 soap_get_PointerTons1__getTask(struct soap *soap, ns1__getTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSystemLogsCountResponse(struct soap *soap, ns1__getSystemLogsCountResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSystemLogsCountResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSystemLogsCountResponse(struct soap *soap, const char *tag, int id, ns1__getSystemLogsCountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSystemLogsCountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSystemLogsCountResponse ** SOAP_FMAC4 soap_in_PointerTons1__getSystemLogsCountResponse(struct soap *soap, const char *tag, ns1__getSystemLogsCountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSystemLogsCountResponse **)soap_malloc(soap, sizeof(ns1__getSystemLogsCountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSystemLogsCountResponse *)soap_instantiate_ns1__getSystemLogsCountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSystemLogsCountResponse ** p = (ns1__getSystemLogsCountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogsCountResponse, sizeof(ns1__getSystemLogsCountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSystemLogsCountResponse(struct soap *soap, ns1__getSystemLogsCountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSystemLogsCountResponse);
	if (soap_out_PointerTons1__getSystemLogsCountResponse(soap, tag?tag:"ns1:getSystemLogsCountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSystemLogsCountResponse ** SOAP_FMAC4 soap_get_PointerTons1__getSystemLogsCountResponse(struct soap *soap, ns1__getSystemLogsCountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSystemLogsCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSystemLogsCount(struct soap *soap, ns1__getSystemLogsCount *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSystemLogsCount))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSystemLogsCount(struct soap *soap, const char *tag, int id, ns1__getSystemLogsCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSystemLogsCount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSystemLogsCount ** SOAP_FMAC4 soap_in_PointerTons1__getSystemLogsCount(struct soap *soap, const char *tag, ns1__getSystemLogsCount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSystemLogsCount **)soap_malloc(soap, sizeof(ns1__getSystemLogsCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSystemLogsCount *)soap_instantiate_ns1__getSystemLogsCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSystemLogsCount ** p = (ns1__getSystemLogsCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogsCount, sizeof(ns1__getSystemLogsCount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSystemLogsCount(struct soap *soap, ns1__getSystemLogsCount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSystemLogsCount);
	if (soap_out_PointerTons1__getSystemLogsCount(soap, tag?tag:"ns1:getSystemLogsCount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSystemLogsCount ** SOAP_FMAC4 soap_get_PointerTons1__getSystemLogsCount(struct soap *soap, ns1__getSystemLogsCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSystemLogsCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSystemLogsResponse(struct soap *soap, ns1__getSystemLogsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSystemLogsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSystemLogsResponse(struct soap *soap, const char *tag, int id, ns1__getSystemLogsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSystemLogsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSystemLogsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getSystemLogsResponse(struct soap *soap, const char *tag, ns1__getSystemLogsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSystemLogsResponse **)soap_malloc(soap, sizeof(ns1__getSystemLogsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSystemLogsResponse *)soap_instantiate_ns1__getSystemLogsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSystemLogsResponse ** p = (ns1__getSystemLogsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogsResponse, sizeof(ns1__getSystemLogsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSystemLogsResponse(struct soap *soap, ns1__getSystemLogsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSystemLogsResponse);
	if (soap_out_PointerTons1__getSystemLogsResponse(soap, tag?tag:"ns1:getSystemLogsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSystemLogsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getSystemLogsResponse(struct soap *soap, ns1__getSystemLogsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSystemLogsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSystemLogs(struct soap *soap, ns1__getSystemLogs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSystemLogs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSystemLogs(struct soap *soap, const char *tag, int id, ns1__getSystemLogs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSystemLogs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSystemLogs ** SOAP_FMAC4 soap_in_PointerTons1__getSystemLogs(struct soap *soap, const char *tag, ns1__getSystemLogs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSystemLogs **)soap_malloc(soap, sizeof(ns1__getSystemLogs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSystemLogs *)soap_instantiate_ns1__getSystemLogs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSystemLogs ** p = (ns1__getSystemLogs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogs, sizeof(ns1__getSystemLogs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSystemLogs(struct soap *soap, ns1__getSystemLogs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSystemLogs);
	if (soap_out_PointerTons1__getSystemLogs(soap, tag?tag:"ns1:getSystemLogs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSystemLogs ** SOAP_FMAC4 soap_get_PointerTons1__getSystemLogs(struct soap *soap, ns1__getSystemLogs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSystemLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSwimlanesResponse(struct soap *soap, ns1__getSwimlanesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSwimlanesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSwimlanesResponse(struct soap *soap, const char *tag, int id, ns1__getSwimlanesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSwimlanesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSwimlanesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getSwimlanesResponse(struct soap *soap, const char *tag, ns1__getSwimlanesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSwimlanesResponse **)soap_malloc(soap, sizeof(ns1__getSwimlanesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSwimlanesResponse *)soap_instantiate_ns1__getSwimlanesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSwimlanesResponse ** p = (ns1__getSwimlanesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSwimlanesResponse, sizeof(ns1__getSwimlanesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSwimlanesResponse(struct soap *soap, ns1__getSwimlanesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSwimlanesResponse);
	if (soap_out_PointerTons1__getSwimlanesResponse(soap, tag?tag:"ns1:getSwimlanesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSwimlanesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getSwimlanesResponse(struct soap *soap, ns1__getSwimlanesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSwimlanesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSwimlanes(struct soap *soap, ns1__getSwimlanes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSwimlanes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSwimlanes(struct soap *soap, const char *tag, int id, ns1__getSwimlanes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSwimlanes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSwimlanes ** SOAP_FMAC4 soap_in_PointerTons1__getSwimlanes(struct soap *soap, const char *tag, ns1__getSwimlanes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSwimlanes **)soap_malloc(soap, sizeof(ns1__getSwimlanes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSwimlanes *)soap_instantiate_ns1__getSwimlanes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSwimlanes ** p = (ns1__getSwimlanes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSwimlanes, sizeof(ns1__getSwimlanes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSwimlanes(struct soap *soap, ns1__getSwimlanes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSwimlanes);
	if (soap_out_PointerTons1__getSwimlanes(soap, tag?tag:"ns1:getSwimlanes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSwimlanes ** SOAP_FMAC4 soap_get_PointerTons1__getSwimlanes(struct soap *soap, ns1__getSwimlanes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSwimlanes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSubprocessesResponse(struct soap *soap, ns1__getSubprocessesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSubprocessesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSubprocessesResponse(struct soap *soap, const char *tag, int id, ns1__getSubprocessesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSubprocessesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSubprocessesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getSubprocessesResponse(struct soap *soap, const char *tag, ns1__getSubprocessesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSubprocessesResponse **)soap_malloc(soap, sizeof(ns1__getSubprocessesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSubprocessesResponse *)soap_instantiate_ns1__getSubprocessesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSubprocessesResponse ** p = (ns1__getSubprocessesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSubprocessesResponse, sizeof(ns1__getSubprocessesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSubprocessesResponse(struct soap *soap, ns1__getSubprocessesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSubprocessesResponse);
	if (soap_out_PointerTons1__getSubprocessesResponse(soap, tag?tag:"ns1:getSubprocessesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSubprocessesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getSubprocessesResponse(struct soap *soap, ns1__getSubprocessesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSubprocessesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getSubprocesses(struct soap *soap, ns1__getSubprocesses *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getSubprocesses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getSubprocesses(struct soap *soap, const char *tag, int id, ns1__getSubprocesses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getSubprocesses);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getSubprocesses ** SOAP_FMAC4 soap_in_PointerTons1__getSubprocesses(struct soap *soap, const char *tag, ns1__getSubprocesses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getSubprocesses **)soap_malloc(soap, sizeof(ns1__getSubprocesses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getSubprocesses *)soap_instantiate_ns1__getSubprocesses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getSubprocesses ** p = (ns1__getSubprocesses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSubprocesses, sizeof(ns1__getSubprocesses), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getSubprocesses(struct soap *soap, ns1__getSubprocesses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getSubprocesses);
	if (soap_out_PointerTons1__getSubprocesses(soap, tag?tag:"ns1:getSubprocesses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getSubprocesses ** SOAP_FMAC4 soap_get_PointerTons1__getSubprocesses(struct soap *soap, ns1__getSubprocesses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getSubprocesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessesCountResponse(struct soap *soap, ns1__getProcessesCountResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessesCountResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessesCountResponse(struct soap *soap, const char *tag, int id, ns1__getProcessesCountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessesCountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessesCountResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessesCountResponse(struct soap *soap, const char *tag, ns1__getProcessesCountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessesCountResponse **)soap_malloc(soap, sizeof(ns1__getProcessesCountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessesCountResponse *)soap_instantiate_ns1__getProcessesCountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessesCountResponse ** p = (ns1__getProcessesCountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesCountResponse, sizeof(ns1__getProcessesCountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessesCountResponse(struct soap *soap, ns1__getProcessesCountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessesCountResponse);
	if (soap_out_PointerTons1__getProcessesCountResponse(soap, tag?tag:"ns1:getProcessesCountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessesCountResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessesCountResponse(struct soap *soap, ns1__getProcessesCountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessesCountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessesCount(struct soap *soap, ns1__getProcessesCount *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessesCount))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessesCount(struct soap *soap, const char *tag, int id, ns1__getProcessesCount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessesCount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessesCount ** SOAP_FMAC4 soap_in_PointerTons1__getProcessesCount(struct soap *soap, const char *tag, ns1__getProcessesCount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessesCount **)soap_malloc(soap, sizeof(ns1__getProcessesCount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessesCount *)soap_instantiate_ns1__getProcessesCount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessesCount ** p = (ns1__getProcessesCount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesCount, sizeof(ns1__getProcessesCount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessesCount(struct soap *soap, ns1__getProcessesCount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessesCount);
	if (soap_out_PointerTons1__getProcessesCount(soap, tag?tag:"ns1:getProcessesCount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessesCount ** SOAP_FMAC4 soap_get_PointerTons1__getProcessesCount(struct soap *soap, ns1__getProcessesCount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessesCount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessesByFilterResponse(struct soap *soap, ns1__getProcessesByFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessesByFilterResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessesByFilterResponse(struct soap *soap, const char *tag, int id, ns1__getProcessesByFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessesByFilterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessesByFilterResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessesByFilterResponse(struct soap *soap, const char *tag, ns1__getProcessesByFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessesByFilterResponse **)soap_malloc(soap, sizeof(ns1__getProcessesByFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessesByFilterResponse *)soap_instantiate_ns1__getProcessesByFilterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessesByFilterResponse ** p = (ns1__getProcessesByFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesByFilterResponse, sizeof(ns1__getProcessesByFilterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessesByFilterResponse(struct soap *soap, ns1__getProcessesByFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessesByFilterResponse);
	if (soap_out_PointerTons1__getProcessesByFilterResponse(soap, tag?tag:"ns1:getProcessesByFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessesByFilterResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessesByFilterResponse(struct soap *soap, ns1__getProcessesByFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessesByFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessesByFilter(struct soap *soap, ns1__getProcessesByFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessesByFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessesByFilter(struct soap *soap, const char *tag, int id, ns1__getProcessesByFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessesByFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessesByFilter ** SOAP_FMAC4 soap_in_PointerTons1__getProcessesByFilter(struct soap *soap, const char *tag, ns1__getProcessesByFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessesByFilter **)soap_malloc(soap, sizeof(ns1__getProcessesByFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessesByFilter *)soap_instantiate_ns1__getProcessesByFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessesByFilter ** p = (ns1__getProcessesByFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesByFilter, sizeof(ns1__getProcessesByFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessesByFilter(struct soap *soap, ns1__getProcessesByFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessesByFilter);
	if (soap_out_PointerTons1__getProcessesByFilter(soap, tag?tag:"ns1:getProcessesByFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessesByFilter ** SOAP_FMAC4 soap_get_PointerTons1__getProcessesByFilter(struct soap *soap, ns1__getProcessesByFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessesByFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessesResponse(struct soap *soap, ns1__getProcessesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessesResponse(struct soap *soap, const char *tag, int id, ns1__getProcessesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessesResponse(struct soap *soap, const char *tag, ns1__getProcessesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessesResponse **)soap_malloc(soap, sizeof(ns1__getProcessesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessesResponse *)soap_instantiate_ns1__getProcessesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessesResponse ** p = (ns1__getProcessesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesResponse, sizeof(ns1__getProcessesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessesResponse(struct soap *soap, ns1__getProcessesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessesResponse);
	if (soap_out_PointerTons1__getProcessesResponse(soap, tag?tag:"ns1:getProcessesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessesResponse(struct soap *soap, ns1__getProcessesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcesses(struct soap *soap, ns1__getProcesses *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcesses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcesses(struct soap *soap, const char *tag, int id, ns1__getProcesses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcesses);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcesses ** SOAP_FMAC4 soap_in_PointerTons1__getProcesses(struct soap *soap, const char *tag, ns1__getProcesses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcesses **)soap_malloc(soap, sizeof(ns1__getProcesses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcesses *)soap_instantiate_ns1__getProcesses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcesses ** p = (ns1__getProcesses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcesses, sizeof(ns1__getProcesses), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcesses(struct soap *soap, ns1__getProcesses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcesses);
	if (soap_out_PointerTons1__getProcesses(soap, tag?tag:"ns1:getProcesses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcesses ** SOAP_FMAC4 soap_get_PointerTons1__getProcesses(struct soap *soap, ns1__getProcesses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcesses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessTasksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessTasksResponse(struct soap *soap, const char *tag, int id, ns1__getProcessTasksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessTasksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessTasksResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessTasksResponse(struct soap *soap, const char *tag, ns1__getProcessTasksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessTasksResponse **)soap_malloc(soap, sizeof(ns1__getProcessTasksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessTasksResponse *)soap_instantiate_ns1__getProcessTasksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessTasksResponse ** p = (ns1__getProcessTasksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasksResponse, sizeof(ns1__getProcessTasksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessTasksResponse);
	if (soap_out_PointerTons1__getProcessTasksResponse(soap, tag?tag:"ns1:getProcessTasksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessTasksResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessTasks(struct soap *soap, ns1__getProcessTasks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessTasks(struct soap *soap, const char *tag, int id, ns1__getProcessTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessTasks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessTasks ** SOAP_FMAC4 soap_in_PointerTons1__getProcessTasks(struct soap *soap, const char *tag, ns1__getProcessTasks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessTasks **)soap_malloc(soap, sizeof(ns1__getProcessTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessTasks *)soap_instantiate_ns1__getProcessTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessTasks ** p = (ns1__getProcessTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasks, sizeof(ns1__getProcessTasks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessTasks(struct soap *soap, ns1__getProcessTasks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessTasks);
	if (soap_out_PointerTons1__getProcessTasks(soap, tag?tag:"ns1:getProcessTasks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessTasks ** SOAP_FMAC4 soap_get_PointerTons1__getProcessTasks(struct soap *soap, ns1__getProcessTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessLogsResponse(struct soap *soap, ns1__getProcessLogsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessLogsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessLogsResponse(struct soap *soap, const char *tag, int id, ns1__getProcessLogsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessLogsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessLogsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessLogsResponse(struct soap *soap, const char *tag, ns1__getProcessLogsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessLogsResponse **)soap_malloc(soap, sizeof(ns1__getProcessLogsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessLogsResponse *)soap_instantiate_ns1__getProcessLogsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessLogsResponse ** p = (ns1__getProcessLogsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogsResponse, sizeof(ns1__getProcessLogsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessLogsResponse(struct soap *soap, ns1__getProcessLogsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessLogsResponse);
	if (soap_out_PointerTons1__getProcessLogsResponse(soap, tag?tag:"ns1:getProcessLogsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessLogsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessLogsResponse(struct soap *soap, ns1__getProcessLogsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessLogsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessLogs(struct soap *soap, ns1__getProcessLogs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessLogs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessLogs(struct soap *soap, const char *tag, int id, ns1__getProcessLogs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessLogs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessLogs ** SOAP_FMAC4 soap_in_PointerTons1__getProcessLogs(struct soap *soap, const char *tag, ns1__getProcessLogs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessLogs **)soap_malloc(soap, sizeof(ns1__getProcessLogs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessLogs *)soap_instantiate_ns1__getProcessLogs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessLogs ** p = (ns1__getProcessLogs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogs, sizeof(ns1__getProcessLogs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessLogs(struct soap *soap, ns1__getProcessLogs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessLogs);
	if (soap_out_PointerTons1__getProcessLogs(soap, tag?tag:"ns1:getProcessLogs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessLogs ** SOAP_FMAC4 soap_get_PointerTons1__getProcessLogs(struct soap *soap, ns1__getProcessLogs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessLogValueResponse(struct soap *soap, ns1__getProcessLogValueResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessLogValueResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessLogValueResponse(struct soap *soap, const char *tag, int id, ns1__getProcessLogValueResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessLogValueResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessLogValueResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessLogValueResponse(struct soap *soap, const char *tag, ns1__getProcessLogValueResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessLogValueResponse **)soap_malloc(soap, sizeof(ns1__getProcessLogValueResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessLogValueResponse *)soap_instantiate_ns1__getProcessLogValueResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessLogValueResponse ** p = (ns1__getProcessLogValueResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogValueResponse, sizeof(ns1__getProcessLogValueResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessLogValueResponse(struct soap *soap, ns1__getProcessLogValueResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessLogValueResponse);
	if (soap_out_PointerTons1__getProcessLogValueResponse(soap, tag?tag:"ns1:getProcessLogValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessLogValueResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessLogValueResponse(struct soap *soap, ns1__getProcessLogValueResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessLogValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessLogValue(struct soap *soap, ns1__getProcessLogValue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessLogValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessLogValue(struct soap *soap, const char *tag, int id, ns1__getProcessLogValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessLogValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessLogValue ** SOAP_FMAC4 soap_in_PointerTons1__getProcessLogValue(struct soap *soap, const char *tag, ns1__getProcessLogValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessLogValue **)soap_malloc(soap, sizeof(ns1__getProcessLogValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessLogValue *)soap_instantiate_ns1__getProcessLogValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessLogValue ** p = (ns1__getProcessLogValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogValue, sizeof(ns1__getProcessLogValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessLogValue(struct soap *soap, ns1__getProcessLogValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessLogValue);
	if (soap_out_PointerTons1__getProcessLogValue(soap, tag?tag:"ns1:getProcessLogValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessLogValue ** SOAP_FMAC4 soap_get_PointerTons1__getProcessLogValue(struct soap *soap, ns1__getProcessLogValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessLogValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessHistoryDiagramElementsResponse(struct soap *soap, ns1__getProcessHistoryDiagramElementsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessHistoryDiagramElementsResponse(struct soap *soap, const char *tag, int id, ns1__getProcessHistoryDiagramElementsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElementsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessHistoryDiagramElementsResponse(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagramElementsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessHistoryDiagramElementsResponse **)soap_malloc(soap, sizeof(ns1__getProcessHistoryDiagramElementsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessHistoryDiagramElementsResponse *)soap_instantiate_ns1__getProcessHistoryDiagramElementsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessHistoryDiagramElementsResponse ** p = (ns1__getProcessHistoryDiagramElementsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse, sizeof(ns1__getProcessHistoryDiagramElementsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessHistoryDiagramElementsResponse(struct soap *soap, ns1__getProcessHistoryDiagramElementsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElementsResponse);
	if (soap_out_PointerTons1__getProcessHistoryDiagramElementsResponse(soap, tag?tag:"ns1:getProcessHistoryDiagramElementsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElementsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessHistoryDiagramElementsResponse(struct soap *soap, ns1__getProcessHistoryDiagramElementsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessHistoryDiagramElementsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessHistoryDiagramElements(struct soap *soap, ns1__getProcessHistoryDiagramElements *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessHistoryDiagramElements))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessHistoryDiagramElements(struct soap *soap, const char *tag, int id, ns1__getProcessHistoryDiagramElements *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessHistoryDiagramElements);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElements ** SOAP_FMAC4 soap_in_PointerTons1__getProcessHistoryDiagramElements(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagramElements **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessHistoryDiagramElements **)soap_malloc(soap, sizeof(ns1__getProcessHistoryDiagramElements *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessHistoryDiagramElements *)soap_instantiate_ns1__getProcessHistoryDiagramElements(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessHistoryDiagramElements ** p = (ns1__getProcessHistoryDiagramElements **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagramElements, sizeof(ns1__getProcessHistoryDiagramElements), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessHistoryDiagramElements(struct soap *soap, ns1__getProcessHistoryDiagramElements *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessHistoryDiagramElements);
	if (soap_out_PointerTons1__getProcessHistoryDiagramElements(soap, tag?tag:"ns1:getProcessHistoryDiagramElements", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramElements ** SOAP_FMAC4 soap_get_PointerTons1__getProcessHistoryDiagramElements(struct soap *soap, ns1__getProcessHistoryDiagramElements **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessHistoryDiagramElements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessHistoryDiagramResponse(struct soap *soap, ns1__getProcessHistoryDiagramResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessHistoryDiagramResponse(struct soap *soap, const char *tag, int id, ns1__getProcessHistoryDiagramResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessHistoryDiagramResponse(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagramResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessHistoryDiagramResponse **)soap_malloc(soap, sizeof(ns1__getProcessHistoryDiagramResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessHistoryDiagramResponse *)soap_instantiate_ns1__getProcessHistoryDiagramResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessHistoryDiagramResponse ** p = (ns1__getProcessHistoryDiagramResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse, sizeof(ns1__getProcessHistoryDiagramResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessHistoryDiagramResponse(struct soap *soap, ns1__getProcessHistoryDiagramResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessHistoryDiagramResponse);
	if (soap_out_PointerTons1__getProcessHistoryDiagramResponse(soap, tag?tag:"ns1:getProcessHistoryDiagramResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagramResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessHistoryDiagramResponse(struct soap *soap, ns1__getProcessHistoryDiagramResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessHistoryDiagramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessHistoryDiagram(struct soap *soap, ns1__getProcessHistoryDiagram *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessHistoryDiagram))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessHistoryDiagram(struct soap *soap, const char *tag, int id, ns1__getProcessHistoryDiagram *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessHistoryDiagram);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagram ** SOAP_FMAC4 soap_in_PointerTons1__getProcessHistoryDiagram(struct soap *soap, const char *tag, ns1__getProcessHistoryDiagram **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessHistoryDiagram **)soap_malloc(soap, sizeof(ns1__getProcessHistoryDiagram *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessHistoryDiagram *)soap_instantiate_ns1__getProcessHistoryDiagram(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessHistoryDiagram ** p = (ns1__getProcessHistoryDiagram **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagram, sizeof(ns1__getProcessHistoryDiagram), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessHistoryDiagram(struct soap *soap, ns1__getProcessHistoryDiagram *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessHistoryDiagram);
	if (soap_out_PointerTons1__getProcessHistoryDiagram(soap, tag?tag:"ns1:getProcessHistoryDiagram", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessHistoryDiagram ** SOAP_FMAC4 soap_get_PointerTons1__getProcessHistoryDiagram(struct soap *soap, ns1__getProcessHistoryDiagram **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessHistoryDiagram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessDiagramElementsResponse(struct soap *soap, ns1__getProcessDiagramElementsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessDiagramElementsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessDiagramElementsResponse(struct soap *soap, const char *tag, int id, ns1__getProcessDiagramElementsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessDiagramElementsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessDiagramElementsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessDiagramElementsResponse(struct soap *soap, const char *tag, ns1__getProcessDiagramElementsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessDiagramElementsResponse **)soap_malloc(soap, sizeof(ns1__getProcessDiagramElementsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessDiagramElementsResponse *)soap_instantiate_ns1__getProcessDiagramElementsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessDiagramElementsResponse ** p = (ns1__getProcessDiagramElementsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagramElementsResponse, sizeof(ns1__getProcessDiagramElementsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessDiagramElementsResponse(struct soap *soap, ns1__getProcessDiagramElementsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessDiagramElementsResponse);
	if (soap_out_PointerTons1__getProcessDiagramElementsResponse(soap, tag?tag:"ns1:getProcessDiagramElementsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessDiagramElementsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessDiagramElementsResponse(struct soap *soap, ns1__getProcessDiagramElementsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessDiagramElementsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessDiagramElements(struct soap *soap, ns1__getProcessDiagramElements *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessDiagramElements))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessDiagramElements(struct soap *soap, const char *tag, int id, ns1__getProcessDiagramElements *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessDiagramElements);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessDiagramElements ** SOAP_FMAC4 soap_in_PointerTons1__getProcessDiagramElements(struct soap *soap, const char *tag, ns1__getProcessDiagramElements **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessDiagramElements **)soap_malloc(soap, sizeof(ns1__getProcessDiagramElements *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessDiagramElements *)soap_instantiate_ns1__getProcessDiagramElements(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessDiagramElements ** p = (ns1__getProcessDiagramElements **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagramElements, sizeof(ns1__getProcessDiagramElements), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessDiagramElements(struct soap *soap, ns1__getProcessDiagramElements *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessDiagramElements);
	if (soap_out_PointerTons1__getProcessDiagramElements(soap, tag?tag:"ns1:getProcessDiagramElements", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessDiagramElements ** SOAP_FMAC4 soap_get_PointerTons1__getProcessDiagramElements(struct soap *soap, ns1__getProcessDiagramElements **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessDiagramElements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessDiagramResponse(struct soap *soap, ns1__getProcessDiagramResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessDiagramResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessDiagramResponse(struct soap *soap, const char *tag, int id, ns1__getProcessDiagramResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessDiagramResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessDiagramResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessDiagramResponse(struct soap *soap, const char *tag, ns1__getProcessDiagramResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessDiagramResponse **)soap_malloc(soap, sizeof(ns1__getProcessDiagramResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessDiagramResponse *)soap_instantiate_ns1__getProcessDiagramResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessDiagramResponse ** p = (ns1__getProcessDiagramResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagramResponse, sizeof(ns1__getProcessDiagramResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessDiagramResponse(struct soap *soap, ns1__getProcessDiagramResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessDiagramResponse);
	if (soap_out_PointerTons1__getProcessDiagramResponse(soap, tag?tag:"ns1:getProcessDiagramResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessDiagramResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessDiagramResponse(struct soap *soap, ns1__getProcessDiagramResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessDiagramResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessDiagram(struct soap *soap, ns1__getProcessDiagram *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessDiagram))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessDiagram(struct soap *soap, const char *tag, int id, ns1__getProcessDiagram *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessDiagram);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessDiagram ** SOAP_FMAC4 soap_in_PointerTons1__getProcessDiagram(struct soap *soap, const char *tag, ns1__getProcessDiagram **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessDiagram **)soap_malloc(soap, sizeof(ns1__getProcessDiagram *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessDiagram *)soap_instantiate_ns1__getProcessDiagram(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessDiagram ** p = (ns1__getProcessDiagram **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagram, sizeof(ns1__getProcessDiagram), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessDiagram(struct soap *soap, ns1__getProcessDiagram *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessDiagram);
	if (soap_out_PointerTons1__getProcessDiagram(soap, tag?tag:"ns1:getProcessDiagram", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessDiagram ** SOAP_FMAC4 soap_get_PointerTons1__getProcessDiagram(struct soap *soap, ns1__getProcessDiagram **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessDiagram(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessResponse(struct soap *soap, ns1__getProcessResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessResponse(struct soap *soap, const char *tag, int id, ns1__getProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessResponse(struct soap *soap, const char *tag, ns1__getProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessResponse **)soap_malloc(soap, sizeof(ns1__getProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessResponse *)soap_instantiate_ns1__getProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessResponse ** p = (ns1__getProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessResponse, sizeof(ns1__getProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessResponse(struct soap *soap, ns1__getProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessResponse);
	if (soap_out_PointerTons1__getProcessResponse(soap, tag?tag:"ns1:getProcessResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessResponse(struct soap *soap, ns1__getProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcess(struct soap *soap, ns1__getProcess *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcess(struct soap *soap, const char *tag, int id, ns1__getProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcess ** SOAP_FMAC4 soap_in_PointerTons1__getProcess(struct soap *soap, const char *tag, ns1__getProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcess **)soap_malloc(soap, sizeof(ns1__getProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcess *)soap_instantiate_ns1__getProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcess ** p = (ns1__getProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcess, sizeof(ns1__getProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcess(struct soap *soap, ns1__getProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcess);
	if (soap_out_PointerTons1__getProcess(soap, tag?tag:"ns1:getProcess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcess ** SOAP_FMAC4 soap_get_PointerTons1__getProcess(struct soap *soap, ns1__getProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getParentProcessResponse(struct soap *soap, ns1__getParentProcessResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getParentProcessResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getParentProcessResponse(struct soap *soap, const char *tag, int id, ns1__getParentProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getParentProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getParentProcessResponse ** SOAP_FMAC4 soap_in_PointerTons1__getParentProcessResponse(struct soap *soap, const char *tag, ns1__getParentProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getParentProcessResponse **)soap_malloc(soap, sizeof(ns1__getParentProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getParentProcessResponse *)soap_instantiate_ns1__getParentProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getParentProcessResponse ** p = (ns1__getParentProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getParentProcessResponse, sizeof(ns1__getParentProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getParentProcessResponse(struct soap *soap, ns1__getParentProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getParentProcessResponse);
	if (soap_out_PointerTons1__getParentProcessResponse(soap, tag?tag:"ns1:getParentProcessResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getParentProcessResponse ** SOAP_FMAC4 soap_get_PointerTons1__getParentProcessResponse(struct soap *soap, ns1__getParentProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getParentProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getParentProcess(struct soap *soap, ns1__getParentProcess *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getParentProcess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getParentProcess(struct soap *soap, const char *tag, int id, ns1__getParentProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getParentProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getParentProcess ** SOAP_FMAC4 soap_in_PointerTons1__getParentProcess(struct soap *soap, const char *tag, ns1__getParentProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getParentProcess **)soap_malloc(soap, sizeof(ns1__getParentProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getParentProcess *)soap_instantiate_ns1__getParentProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getParentProcess ** p = (ns1__getParentProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getParentProcess, sizeof(ns1__getParentProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getParentProcess(struct soap *soap, ns1__getParentProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getParentProcess);
	if (soap_out_PointerTons1__getParentProcess(soap, tag?tag:"ns1:getParentProcess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getParentProcess ** SOAP_FMAC4 soap_get_PointerTons1__getParentProcess(struct soap *soap, ns1__getParentProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getParentProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__completeTaskWSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__completeTaskWSResponse(struct soap *soap, const char *tag, int id, ns1__completeTaskWSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__completeTaskWSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__completeTaskWSResponse ** SOAP_FMAC4 soap_in_PointerTons1__completeTaskWSResponse(struct soap *soap, const char *tag, ns1__completeTaskWSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__completeTaskWSResponse **)soap_malloc(soap, sizeof(ns1__completeTaskWSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__completeTaskWSResponse *)soap_instantiate_ns1__completeTaskWSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__completeTaskWSResponse ** p = (ns1__completeTaskWSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWSResponse, sizeof(ns1__completeTaskWSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__completeTaskWSResponse);
	if (soap_out_PointerTons1__completeTaskWSResponse(soap, tag?tag:"ns1:completeTaskWSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__completeTaskWSResponse ** SOAP_FMAC4 soap_get_PointerTons1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__completeTaskWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__completeTaskWS(struct soap *soap, ns1__completeTaskWS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__completeTaskWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__completeTaskWS(struct soap *soap, const char *tag, int id, ns1__completeTaskWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__completeTaskWS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__completeTaskWS ** SOAP_FMAC4 soap_in_PointerTons1__completeTaskWS(struct soap *soap, const char *tag, ns1__completeTaskWS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__completeTaskWS **)soap_malloc(soap, sizeof(ns1__completeTaskWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__completeTaskWS *)soap_instantiate_ns1__completeTaskWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__completeTaskWS ** p = (ns1__completeTaskWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWS, sizeof(ns1__completeTaskWS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__completeTaskWS(struct soap *soap, ns1__completeTaskWS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__completeTaskWS);
	if (soap_out_PointerTons1__completeTaskWS(soap, tag?tag:"ns1:completeTaskWS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__completeTaskWS ** SOAP_FMAC4 soap_get_PointerTons1__completeTaskWS(struct soap *soap, ns1__completeTaskWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__completeTaskWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cancelProcessResponse(struct soap *soap, ns1__cancelProcessResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cancelProcessResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cancelProcessResponse(struct soap *soap, const char *tag, int id, ns1__cancelProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cancelProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cancelProcessResponse ** SOAP_FMAC4 soap_in_PointerTons1__cancelProcessResponse(struct soap *soap, const char *tag, ns1__cancelProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cancelProcessResponse **)soap_malloc(soap, sizeof(ns1__cancelProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cancelProcessResponse *)soap_instantiate_ns1__cancelProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cancelProcessResponse ** p = (ns1__cancelProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cancelProcessResponse, sizeof(ns1__cancelProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cancelProcessResponse(struct soap *soap, ns1__cancelProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__cancelProcessResponse);
	if (soap_out_PointerTons1__cancelProcessResponse(soap, tag?tag:"ns1:cancelProcessResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cancelProcessResponse ** SOAP_FMAC4 soap_get_PointerTons1__cancelProcessResponse(struct soap *soap, ns1__cancelProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cancelProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cancelProcess(struct soap *soap, ns1__cancelProcess *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cancelProcess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cancelProcess(struct soap *soap, const char *tag, int id, ns1__cancelProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cancelProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cancelProcess ** SOAP_FMAC4 soap_in_PointerTons1__cancelProcess(struct soap *soap, const char *tag, ns1__cancelProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cancelProcess **)soap_malloc(soap, sizeof(ns1__cancelProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cancelProcess *)soap_instantiate_ns1__cancelProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cancelProcess ** p = (ns1__cancelProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cancelProcess, sizeof(ns1__cancelProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cancelProcess(struct soap *soap, ns1__cancelProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__cancelProcess);
	if (soap_out_PointerTons1__cancelProcess(soap, tag?tag:"ns1:cancelProcess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cancelProcess ** SOAP_FMAC4 soap_get_PointerTons1__cancelProcess(struct soap *soap, ns1__cancelProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cancelProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignTaskResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignTaskResponse(struct soap *soap, const char *tag, int id, ns1__assignTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignTaskResponse ** SOAP_FMAC4 soap_in_PointerTons1__assignTaskResponse(struct soap *soap, const char *tag, ns1__assignTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignTaskResponse **)soap_malloc(soap, sizeof(ns1__assignTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignTaskResponse *)soap_instantiate_ns1__assignTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignTaskResponse ** p = (ns1__assignTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTaskResponse, sizeof(ns1__assignTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignTaskResponse);
	if (soap_out_PointerTons1__assignTaskResponse(soap, tag?tag:"ns1:assignTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__assignTaskResponse ** SOAP_FMAC4 soap_get_PointerTons1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignTask(struct soap *soap, ns1__assignTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignTask(struct soap *soap, const char *tag, int id, ns1__assignTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignTask ** SOAP_FMAC4 soap_in_PointerTons1__assignTask(struct soap *soap, const char *tag, ns1__assignTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignTask **)soap_malloc(soap, sizeof(ns1__assignTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignTask *)soap_instantiate_ns1__assignTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignTask ** p = (ns1__assignTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTask, sizeof(ns1__assignTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignTask(struct soap *soap, ns1__assignTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignTask);
	if (soap_out_PointerTons1__assignTask(soap, tag?tag:"ns1:assignTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__assignTask ** SOAP_FMAC4 soap_get_PointerTons1__assignTask(struct soap *soap, ns1__assignTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignSwimlaneResponse(struct soap *soap, ns1__assignSwimlaneResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignSwimlaneResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignSwimlaneResponse(struct soap *soap, const char *tag, int id, ns1__assignSwimlaneResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignSwimlaneResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignSwimlaneResponse ** SOAP_FMAC4 soap_in_PointerTons1__assignSwimlaneResponse(struct soap *soap, const char *tag, ns1__assignSwimlaneResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignSwimlaneResponse **)soap_malloc(soap, sizeof(ns1__assignSwimlaneResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignSwimlaneResponse *)soap_instantiate_ns1__assignSwimlaneResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignSwimlaneResponse ** p = (ns1__assignSwimlaneResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignSwimlaneResponse, sizeof(ns1__assignSwimlaneResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignSwimlaneResponse(struct soap *soap, ns1__assignSwimlaneResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignSwimlaneResponse);
	if (soap_out_PointerTons1__assignSwimlaneResponse(soap, tag?tag:"ns1:assignSwimlaneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__assignSwimlaneResponse ** SOAP_FMAC4 soap_get_PointerTons1__assignSwimlaneResponse(struct soap *soap, ns1__assignSwimlaneResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignSwimlaneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignSwimlane(struct soap *soap, ns1__assignSwimlane *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignSwimlane))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignSwimlane(struct soap *soap, const char *tag, int id, ns1__assignSwimlane *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignSwimlane);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignSwimlane ** SOAP_FMAC4 soap_in_PointerTons1__assignSwimlane(struct soap *soap, const char *tag, ns1__assignSwimlane **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignSwimlane **)soap_malloc(soap, sizeof(ns1__assignSwimlane *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignSwimlane *)soap_instantiate_ns1__assignSwimlane(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignSwimlane ** p = (ns1__assignSwimlane **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignSwimlane, sizeof(ns1__assignSwimlane), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignSwimlane(struct soap *soap, ns1__assignSwimlane *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignSwimlane);
	if (soap_out_PointerTons1__assignSwimlane(soap, tag?tag:"ns1:assignSwimlane", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__assignSwimlane ** SOAP_FMAC4 soap_get_PointerTons1__assignSwimlane(struct soap *soap, ns1__assignSwimlane **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignSwimlane(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, int id, ns1__authenticateByLoginPasswordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, ns1__authenticateByLoginPasswordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByLoginPasswordResponse **)soap_malloc(soap, sizeof(ns1__authenticateByLoginPasswordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByLoginPasswordResponse *)soap_instantiate_ns1__authenticateByLoginPasswordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByLoginPasswordResponse ** p = (ns1__authenticateByLoginPasswordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, sizeof(ns1__authenticateByLoginPasswordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse);
	if (soap_out_PointerTons1__authenticateByLoginPasswordResponse(soap, tag?tag:"ns1:authenticateByLoginPasswordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByLoginPasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByLoginPassword))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByLoginPassword(struct soap *soap, const char *tag, int id, ns1__authenticateByLoginPassword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByLoginPassword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByLoginPassword(struct soap *soap, const char *tag, ns1__authenticateByLoginPassword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByLoginPassword **)soap_malloc(soap, sizeof(ns1__authenticateByLoginPassword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByLoginPassword *)soap_instantiate_ns1__authenticateByLoginPassword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByLoginPassword ** p = (ns1__authenticateByLoginPassword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPassword, sizeof(ns1__authenticateByLoginPassword), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByLoginPassword);
	if (soap_out_PointerTons1__authenticateByLoginPassword(soap, tag?tag:"ns1:authenticateByLoginPassword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByLoginPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByKerberosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByKerberosResponse(struct soap *soap, const char *tag, int id, ns1__authenticateByKerberosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByKerberosResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByKerberosResponse(struct soap *soap, const char *tag, ns1__authenticateByKerberosResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByKerberosResponse **)soap_malloc(soap, sizeof(ns1__authenticateByKerberosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByKerberosResponse *)soap_instantiate_ns1__authenticateByKerberosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByKerberosResponse ** p = (ns1__authenticateByKerberosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberosResponse, sizeof(ns1__authenticateByKerberosResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByKerberosResponse);
	if (soap_out_PointerTons1__authenticateByKerberosResponse(soap, tag?tag:"ns1:authenticateByKerberosResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByKerberosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByKerberos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByKerberos(struct soap *soap, const char *tag, int id, ns1__authenticateByKerberos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByKerberos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByKerberos ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByKerberos(struct soap *soap, const char *tag, ns1__authenticateByKerberos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByKerberos **)soap_malloc(soap, sizeof(ns1__authenticateByKerberos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByKerberos *)soap_instantiate_ns1__authenticateByKerberos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByKerberos ** p = (ns1__authenticateByKerberos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberos, sizeof(ns1__authenticateByKerberos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByKerberos);
	if (soap_out_PointerTons1__authenticateByKerberos(soap, tag?tag:"ns1:authenticateByKerberos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByKerberos ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByKerberos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, int id, ns1__authenticateByCallerPrincipalResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipalResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByCallerPrincipalResponse **)soap_malloc(soap, sizeof(ns1__authenticateByCallerPrincipalResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByCallerPrincipalResponse *)soap_instantiate_ns1__authenticateByCallerPrincipalResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByCallerPrincipalResponse ** p = (ns1__authenticateByCallerPrincipalResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, sizeof(ns1__authenticateByCallerPrincipalResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse);
	if (soap_out_PointerTons1__authenticateByCallerPrincipalResponse(soap, tag?tag:"ns1:authenticateByCallerPrincipalResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByCallerPrincipalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByCallerPrincipal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, int id, ns1__authenticateByCallerPrincipal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByCallerPrincipal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByCallerPrincipal **)soap_malloc(soap, sizeof(ns1__authenticateByCallerPrincipal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByCallerPrincipal *)soap_instantiate_ns1__authenticateByCallerPrincipal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByCallerPrincipal ** p = (ns1__authenticateByCallerPrincipal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipal, sizeof(ns1__authenticateByCallerPrincipal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal);
	if (soap_out_PointerTons1__authenticateByCallerPrincipal(soap, tag?tag:"ns1:authenticateByCallerPrincipal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByCallerPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstring(struct soap *soap, wchar_t **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstring))
		soap_serialize_wstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstring(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstring);
	if (id < 0)
		return soap->error;
	return soap_out_wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerTowstring(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstring, sizeof(wchar_t *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstring(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstring);
	if (soap_out_PointerTowstring(soap, tag?tag:"wchar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerTowstring(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__delegation(struct soap *soap, ns1__delegation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__delegation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__delegation(struct soap *soap, const char *tag, int id, ns1__delegation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__delegation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__delegation ** SOAP_FMAC4 soap_in_PointerTons1__delegation(struct soap *soap, const char *tag, ns1__delegation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__delegation **)soap_malloc(soap, sizeof(ns1__delegation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__delegation *)soap_instantiate_ns1__delegation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__delegation ** p = (ns1__delegation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__delegation, sizeof(ns1__delegation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__delegation(struct soap *soap, ns1__delegation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__delegation);
	if (soap_out_PointerTons1__delegation(soap, tag?tag:"ns1:delegation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__delegation ** SOAP_FMAC4 soap_get_PointerTons1__delegation(struct soap *soap, ns1__delegation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__delegation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__swimlaneDefinition(struct soap *soap, ns1__swimlaneDefinition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__swimlaneDefinition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__swimlaneDefinition(struct soap *soap, const char *tag, int id, ns1__swimlaneDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__swimlaneDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__swimlaneDefinition ** SOAP_FMAC4 soap_in_PointerTons1__swimlaneDefinition(struct soap *soap, const char *tag, ns1__swimlaneDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__swimlaneDefinition **)soap_malloc(soap, sizeof(ns1__swimlaneDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__swimlaneDefinition *)soap_instantiate_ns1__swimlaneDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__swimlaneDefinition ** p = (ns1__swimlaneDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__swimlaneDefinition, sizeof(ns1__swimlaneDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__swimlaneDefinition(struct soap *soap, ns1__swimlaneDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__swimlaneDefinition);
	if (soap_out_PointerTons1__swimlaneDefinition(soap, tag?tag:"ns1:swimlaneDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__swimlaneDefinition ** SOAP_FMAC4 soap_get_PointerTons1__swimlaneDefinition(struct soap *soap, ns1__swimlaneDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__swimlaneDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__wfSwimlane(struct soap *soap, ns1__wfSwimlane **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__wfSwimlane))
		soap_serialize_PointerTons1__wfSwimlane(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__wfSwimlane(struct soap *soap, const char *tag, int id, ns1__wfSwimlane **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__wfSwimlane);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__wfSwimlane(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__wfSwimlane *** SOAP_FMAC4 soap_in_PointerToPointerTons1__wfSwimlane(struct soap *soap, const char *tag, ns1__wfSwimlane ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfSwimlane ***)soap_malloc(soap, sizeof(ns1__wfSwimlane **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__wfSwimlane(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__wfSwimlane ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__wfSwimlane, sizeof(ns1__wfSwimlane *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__wfSwimlane(struct soap *soap, ns1__wfSwimlane **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__wfSwimlane);
	if (soap_out_PointerToPointerTons1__wfSwimlane(soap, tag?tag:"ns1:wfSwimlane", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfSwimlane *** SOAP_FMAC4 soap_get_PointerToPointerTons1__wfSwimlane(struct soap *soap, ns1__wfSwimlane ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__wfSwimlane(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wfSwimlane(struct soap *soap, ns1__wfSwimlane *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wfSwimlane))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wfSwimlane(struct soap *soap, const char *tag, int id, ns1__wfSwimlane *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wfSwimlane);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wfSwimlane ** SOAP_FMAC4 soap_in_PointerTons1__wfSwimlane(struct soap *soap, const char *tag, ns1__wfSwimlane **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfSwimlane **)soap_malloc(soap, sizeof(ns1__wfSwimlane *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wfSwimlane *)soap_instantiate_ns1__wfSwimlane(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wfSwimlane ** p = (ns1__wfSwimlane **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfSwimlane, sizeof(ns1__wfSwimlane), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wfSwimlane(struct soap *soap, ns1__wfSwimlane *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__wfSwimlane);
	if (soap_out_PointerTons1__wfSwimlane(soap, tag?tag:"ns1:wfSwimlane", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfSwimlane ** SOAP_FMAC4 soap_get_PointerTons1__wfSwimlane(struct soap *soap, ns1__wfSwimlane **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wfSwimlane(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__variable(struct soap *soap, ns1__variable **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__variable))
		soap_serialize_PointerTons1__variable(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__variable(struct soap *soap, const char *tag, int id, ns1__variable **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__variable);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__variable(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__variable *** SOAP_FMAC4 soap_in_PointerToPointerTons1__variable(struct soap *soap, const char *tag, ns1__variable ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variable ***)soap_malloc(soap, sizeof(ns1__variable **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__variable(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__variable ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__variable, sizeof(ns1__variable *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__variable(struct soap *soap, ns1__variable **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__variable);
	if (soap_out_PointerToPointerTons1__variable(soap, tag?tag:"ns1:variable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variable *** SOAP_FMAC4 soap_get_PointerToPointerTons1__variable(struct soap *soap, ns1__variable ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__variable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__variable(struct soap *soap, ns1__variable *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__variable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__variable(struct soap *soap, const char *tag, int id, ns1__variable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__variable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__variable ** SOAP_FMAC4 soap_in_PointerTons1__variable(struct soap *soap, const char *tag, ns1__variable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variable **)soap_malloc(soap, sizeof(ns1__variable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__variable *)soap_instantiate_ns1__variable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__variable ** p = (ns1__variable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variable, sizeof(ns1__variable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__variable(struct soap *soap, ns1__variable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__variable);
	if (soap_out_PointerTons1__variable(soap, tag?tag:"ns1:variable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variable ** SOAP_FMAC4 soap_get_PointerTons1__variable(struct soap *soap, ns1__variable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__variable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__systemLog(struct soap *soap, ns1__systemLog **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__systemLog))
		soap_serialize_PointerTons1__systemLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__systemLog(struct soap *soap, const char *tag, int id, ns1__systemLog **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__systemLog);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__systemLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__systemLog *** SOAP_FMAC4 soap_in_PointerToPointerTons1__systemLog(struct soap *soap, const char *tag, ns1__systemLog ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__systemLog ***)soap_malloc(soap, sizeof(ns1__systemLog **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__systemLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__systemLog ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__systemLog, sizeof(ns1__systemLog *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__systemLog(struct soap *soap, ns1__systemLog **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__systemLog);
	if (soap_out_PointerToPointerTons1__systemLog(soap, tag?tag:"ns1:systemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__systemLog *** SOAP_FMAC4 soap_get_PointerToPointerTons1__systemLog(struct soap *soap, ns1__systemLog ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__systemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__systemLog(struct soap *soap, ns1__systemLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__systemLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__systemLog(struct soap *soap, const char *tag, int id, ns1__systemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__systemLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__systemLog ** SOAP_FMAC4 soap_in_PointerTons1__systemLog(struct soap *soap, const char *tag, ns1__systemLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__systemLog **)soap_malloc(soap, sizeof(ns1__systemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__systemLog *)soap_instantiate_ns1__systemLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__systemLog ** p = (ns1__systemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__systemLog, sizeof(ns1__systemLog), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__systemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processDefinitionDeleteLog, sizeof(ns1__processDefinitionDeleteLog), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__systemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processDeleteLog, sizeof(ns1__processDeleteLog), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__systemLog(struct soap *soap, ns1__systemLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__systemLog);
	if (soap_out_PointerTons1__systemLog(soap, tag?tag:"ns1:systemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__systemLog ** SOAP_FMAC4 soap_get_PointerTons1__systemLog(struct soap *soap, ns1__systemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__systemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__severity(struct soap *soap, enum ns1__severity *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__severity);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__severity(struct soap *soap, const char *tag, int id, enum ns1__severity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__severity);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__severity(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__severity ** SOAP_FMAC4 soap_in_PointerTons1__severity(struct soap *soap, const char *tag, enum ns1__severity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__severity **)soap_malloc(soap, sizeof(enum ns1__severity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__severity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__severity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__severity, sizeof(enum ns1__severity), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__severity(struct soap *soap, enum ns1__severity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__severity);
	if (soap_out_PointerTons1__severity(soap, tag?tag:"ns1:severity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__severity ** SOAP_FMAC4 soap_get_PointerTons1__severity(struct soap *soap, enum ns1__severity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__severity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__processLog(struct soap *soap, ns1__processLog **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__processLog))
		soap_serialize_PointerTons1__processLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__processLog(struct soap *soap, const char *tag, int id, ns1__processLog **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__processLog);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__processLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__processLog *** SOAP_FMAC4 soap_in_PointerToPointerTons1__processLog(struct soap *soap, const char *tag, ns1__processLog ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__processLog ***)soap_malloc(soap, sizeof(ns1__processLog **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__processLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__processLog ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__processLog, sizeof(ns1__processLog *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__processLog(struct soap *soap, ns1__processLog **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__processLog);
	if (soap_out_PointerToPointerTons1__processLog(soap, tag?tag:"ns1:processLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__processLog *** SOAP_FMAC4 soap_get_PointerToPointerTons1__processLog(struct soap *soap, ns1__processLog ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__processLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__processLog(struct soap *soap, ns1__processLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__processLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__processLog(struct soap *soap, const char *tag, int id, ns1__processLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__processLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__processLog ** SOAP_FMAC4 soap_in_PointerTons1__processLog(struct soap *soap, const char *tag, ns1__processLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__processLog **)soap_malloc(soap, sizeof(ns1__processLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__processLog *)soap_instantiate_ns1__processLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__processLog ** p = (ns1__processLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processLog, sizeof(ns1__processLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__processLog(struct soap *soap, ns1__processLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__processLog);
	if (soap_out_PointerTons1__processLog(soap, tag?tag:"ns1:processLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__processLog ** SOAP_FMAC4 soap_get_PointerTons1__processLog(struct soap *soap, ns1__processLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__processLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__processLogs(struct soap *soap, ns1__processLogs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__processLogs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__processLogs(struct soap *soap, const char *tag, int id, ns1__processLogs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__processLogs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__processLogs ** SOAP_FMAC4 soap_in_PointerTons1__processLogs(struct soap *soap, const char *tag, ns1__processLogs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__processLogs **)soap_malloc(soap, sizeof(ns1__processLogs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__processLogs *)soap_instantiate_ns1__processLogs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__processLogs ** p = (ns1__processLogs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processLogs, sizeof(ns1__processLogs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__processLogs(struct soap *soap, ns1__processLogs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__processLogs);
	if (soap_out_PointerTons1__processLogs(soap, tag?tag:"ns1:processLogs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__processLogs ** SOAP_FMAC4 soap_get_PointerTons1__processLogs(struct soap *soap, ns1__processLogs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__processLogs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__processLogFilter(struct soap *soap, ns1__processLogFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__processLogFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__processLogFilter(struct soap *soap, const char *tag, int id, ns1__processLogFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__processLogFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__processLogFilter ** SOAP_FMAC4 soap_in_PointerTons1__processLogFilter(struct soap *soap, const char *tag, ns1__processLogFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__processLogFilter **)soap_malloc(soap, sizeof(ns1__processLogFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__processLogFilter *)soap_instantiate_ns1__processLogFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__processLogFilter ** p = (ns1__processLogFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processLogFilter, sizeof(ns1__processLogFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__processLogFilter(struct soap *soap, ns1__processLogFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__processLogFilter);
	if (soap_out_PointerTons1__processLogFilter(soap, tag?tag:"ns1:processLogFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__processLogFilter ** SOAP_FMAC4 soap_get_PointerTons1__processLogFilter(struct soap *soap, ns1__processLogFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__processLogFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__wfTask(struct soap *soap, ns1__wfTask **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__wfTask))
		soap_serialize_PointerTons1__wfTask(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__wfTask(struct soap *soap, const char *tag, int id, ns1__wfTask **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__wfTask);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__wfTask(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__wfTask *** SOAP_FMAC4 soap_in_PointerToPointerTons1__wfTask(struct soap *soap, const char *tag, ns1__wfTask ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfTask ***)soap_malloc(soap, sizeof(ns1__wfTask **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__wfTask(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__wfTask ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__wfTask, sizeof(ns1__wfTask *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__wfTask(struct soap *soap, ns1__wfTask **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__wfTask);
	if (soap_out_PointerToPointerTons1__wfTask(soap, tag?tag:"ns1:wfTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfTask *** SOAP_FMAC4 soap_get_PointerToPointerTons1__wfTask(struct soap *soap, ns1__wfTask ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__wfTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__wfProcess(struct soap *soap, ns1__wfProcess **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__wfProcess))
		soap_serialize_PointerTons1__wfProcess(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__wfProcess(struct soap *soap, const char *tag, int id, ns1__wfProcess **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__wfProcess);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__wfProcess(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__wfProcess *** SOAP_FMAC4 soap_in_PointerToPointerTons1__wfProcess(struct soap *soap, const char *tag, ns1__wfProcess ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfProcess ***)soap_malloc(soap, sizeof(ns1__wfProcess **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__wfProcess(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__wfProcess ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__wfProcess, sizeof(ns1__wfProcess *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__wfProcess(struct soap *soap, ns1__wfProcess **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__wfProcess);
	if (soap_out_PointerToPointerTons1__wfProcess(soap, tag?tag:"ns1:wfProcess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfProcess *** SOAP_FMAC4 soap_get_PointerToPointerTons1__wfProcess(struct soap *soap, ns1__wfProcess ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__wfProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__processFilter(struct soap *soap, ns1__processFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__processFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__processFilter(struct soap *soap, const char *tag, int id, ns1__processFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__processFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__processFilter ** SOAP_FMAC4 soap_in_PointerTons1__processFilter(struct soap *soap, const char *tag, ns1__processFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__processFilter **)soap_malloc(soap, sizeof(ns1__processFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__processFilter *)soap_instantiate_ns1__processFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__processFilter ** p = (ns1__processFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processFilter, sizeof(ns1__processFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__processFilter(struct soap *soap, ns1__processFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__processFilter);
	if (soap_out_PointerTons1__processFilter(soap, tag?tag:"ns1:processFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__processFilter ** SOAP_FMAC4 soap_get_PointerTons1__processFilter(struct soap *soap, ns1__processFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__processFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__classPresentationType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__classPresentationType(struct soap *soap, const char *tag, int id, enum ns1__classPresentationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__classPresentationType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__classPresentationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__classPresentationType ** SOAP_FMAC4 soap_in_PointerTons1__classPresentationType(struct soap *soap, const char *tag, enum ns1__classPresentationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__classPresentationType **)soap_malloc(soap, sizeof(enum ns1__classPresentationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__classPresentationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__classPresentationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__classPresentationType, sizeof(enum ns1__classPresentationType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__classPresentationType);
	if (soap_out_PointerTons1__classPresentationType(soap, tag?tag:"ns1:classPresentationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__classPresentationType ** SOAP_FMAC4 soap_get_PointerTons1__classPresentationType(struct soap *soap, enum ns1__classPresentationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__classPresentationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__batchPresentation(struct soap *soap, ns1__batchPresentation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__batchPresentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__batchPresentation(struct soap *soap, const char *tag, int id, ns1__batchPresentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__batchPresentation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__batchPresentation ** SOAP_FMAC4 soap_in_PointerTons1__batchPresentation(struct soap *soap, const char *tag, ns1__batchPresentation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__batchPresentation **)soap_malloc(soap, sizeof(ns1__batchPresentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__batchPresentation *)soap_instantiate_ns1__batchPresentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__batchPresentation ** p = (ns1__batchPresentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__batchPresentation, sizeof(ns1__batchPresentation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__batchPresentation(struct soap *soap, ns1__batchPresentation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__batchPresentation);
	if (soap_out_PointerTons1__batchPresentation(soap, tag?tag:"ns1:batchPresentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__batchPresentation ** SOAP_FMAC4 soap_get_PointerTons1__batchPresentation(struct soap *soap, ns1__batchPresentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__batchPresentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__variableDefinition))
		soap_serialize_PointerTons1__variableDefinition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__variableDefinition(struct soap *soap, const char *tag, int id, ns1__variableDefinition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__variableDefinition);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__variableDefinition(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__variableDefinition *** SOAP_FMAC4 soap_in_PointerToPointerTons1__variableDefinition(struct soap *soap, const char *tag, ns1__variableDefinition ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variableDefinition ***)soap_malloc(soap, sizeof(ns1__variableDefinition **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__variableDefinition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__variableDefinition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__variableDefinition, sizeof(ns1__variableDefinition *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__variableDefinition);
	if (soap_out_PointerToPointerTons1__variableDefinition(soap, tag?tag:"ns1:variableDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variableDefinition *** SOAP_FMAC4 soap_get_PointerToPointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__variableDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__variableDefinition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__variableDefinition(struct soap *soap, const char *tag, int id, ns1__variableDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__variableDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__variableDefinition ** SOAP_FMAC4 soap_in_PointerTons1__variableDefinition(struct soap *soap, const char *tag, ns1__variableDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variableDefinition **)soap_malloc(soap, sizeof(ns1__variableDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__variableDefinition *)soap_instantiate_ns1__variableDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__variableDefinition ** p = (ns1__variableDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variableDefinition, sizeof(ns1__variableDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__variableDefinition);
	if (soap_out_PointerTons1__variableDefinition(soap, tag?tag:"ns1:variableDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variableDefinition ** SOAP_FMAC4 soap_get_PointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__variableDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__variableDefinition_userTypes_entry(struct soap *soap, _ns1__variableDefinition_userTypes_entry *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__variableDefinition_userTypes_entry))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__variableDefinition_userTypes_entry(struct soap *soap, const char *tag, int id, _ns1__variableDefinition_userTypes_entry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__variableDefinition_userTypes_entry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__variableDefinition_userTypes_entry ** SOAP_FMAC4 soap_in_PointerTo_ns1__variableDefinition_userTypes_entry(struct soap *soap, const char *tag, _ns1__variableDefinition_userTypes_entry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__variableDefinition_userTypes_entry **)soap_malloc(soap, sizeof(_ns1__variableDefinition_userTypes_entry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__variableDefinition_userTypes_entry *)soap_instantiate__ns1__variableDefinition_userTypes_entry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__variableDefinition_userTypes_entry ** p = (_ns1__variableDefinition_userTypes_entry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__variableDefinition_userTypes_entry, sizeof(_ns1__variableDefinition_userTypes_entry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__variableDefinition_userTypes_entry(struct soap *soap, _ns1__variableDefinition_userTypes_entry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__variableDefinition_userTypes_entry);
	if (soap_out_PointerTo_ns1__variableDefinition_userTypes_entry(soap, tag?tag:"ns1:variableDefinition-userTypes-entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__variableDefinition_userTypes_entry ** SOAP_FMAC4 soap_get_PointerTo_ns1__variableDefinition_userTypes_entry(struct soap *soap, _ns1__variableDefinition_userTypes_entry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__variableDefinition_userTypes_entry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__variableUserType(struct soap *soap, ns1__variableUserType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__variableUserType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__variableUserType(struct soap *soap, const char *tag, int id, ns1__variableUserType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__variableUserType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__variableUserType ** SOAP_FMAC4 soap_in_PointerTons1__variableUserType(struct soap *soap, const char *tag, ns1__variableUserType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variableUserType **)soap_malloc(soap, sizeof(ns1__variableUserType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__variableUserType *)soap_instantiate_ns1__variableUserType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__variableUserType ** p = (ns1__variableUserType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variableUserType, sizeof(ns1__variableUserType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__variableUserType(struct soap *soap, ns1__variableUserType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__variableUserType);
	if (soap_out_PointerTons1__variableUserType(soap, tag?tag:"ns1:variableUserType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variableUserType ** SOAP_FMAC4 soap_get_PointerTons1__variableUserType(struct soap *soap, ns1__variableUserType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__variableUserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__wfVariableStub))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__wfVariableStub(struct soap *soap, const char *tag, int id, ns2__wfVariableStub *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__wfVariableStub);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__wfVariableStub ** SOAP_FMAC4 soap_in_PointerTons2__wfVariableStub(struct soap *soap, const char *tag, ns2__wfVariableStub **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__wfVariableStub **)soap_malloc(soap, sizeof(ns2__wfVariableStub *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__wfVariableStub *)soap_instantiate_ns2__wfVariableStub(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__wfVariableStub ** p = (ns2__wfVariableStub **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__wfVariableStub, sizeof(ns2__wfVariableStub), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__wfVariableStub);
	if (soap_out_PointerTons2__wfVariableStub(soap, tag?tag:"ns2:wfVariableStub", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__wfVariableStub ** SOAP_FMAC4 soap_get_PointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__wfVariableStub(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wfProcess(struct soap *soap, ns1__wfProcess *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wfProcess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wfProcess(struct soap *soap, const char *tag, int id, ns1__wfProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wfProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wfProcess ** SOAP_FMAC4 soap_in_PointerTons1__wfProcess(struct soap *soap, const char *tag, ns1__wfProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfProcess **)soap_malloc(soap, sizeof(ns1__wfProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wfProcess *)soap_instantiate_ns1__wfProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wfProcess ** p = (ns1__wfProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfProcess, sizeof(ns1__wfProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wfProcess(struct soap *soap, ns1__wfProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__wfProcess);
	if (soap_out_PointerTons1__wfProcess(soap, tag?tag:"ns1:wfProcess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfProcess ** SOAP_FMAC4 soap_get_PointerTons1__wfProcess(struct soap *soap, ns1__wfProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wfProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wfExecutor(struct soap *soap, ns1__wfExecutor *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wfExecutor))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wfExecutor(struct soap *soap, const char *tag, int id, ns1__wfExecutor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wfExecutor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wfExecutor ** SOAP_FMAC4 soap_in_PointerTons1__wfExecutor(struct soap *soap, const char *tag, ns1__wfExecutor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfExecutor **)soap_malloc(soap, sizeof(ns1__wfExecutor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wfExecutor *)soap_instantiate_ns1__wfExecutor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wfExecutor ** p = (ns1__wfExecutor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfExecutor, sizeof(ns1__wfExecutor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wfExecutor(struct soap *soap, ns1__wfExecutor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__wfExecutor);
	if (soap_out_PointerTons1__wfExecutor(soap, tag?tag:"ns1:wfExecutor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfExecutor ** SOAP_FMAC4 soap_get_PointerTons1__wfExecutor(struct soap *soap, ns1__wfExecutor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wfExecutor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wfTask(struct soap *soap, ns1__wfTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wfTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wfTask(struct soap *soap, const char *tag, int id, ns1__wfTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wfTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wfTask ** SOAP_FMAC4 soap_in_PointerTons1__wfTask(struct soap *soap, const char *tag, ns1__wfTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfTask **)soap_malloc(soap, sizeof(ns1__wfTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wfTask *)soap_instantiate_ns1__wfTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wfTask ** p = (ns1__wfTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfTask, sizeof(ns1__wfTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wfTask(struct soap *soap, ns1__wfTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__wfTask);
	if (soap_out_PointerTons1__wfTask(soap, tag?tag:"ns1:wfTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfTask ** SOAP_FMAC4 soap_get_PointerTons1__wfTask(struct soap *soap, ns1__wfTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wfTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__int, sizeof(xsd__int), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__long, sizeof(xsd__long), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__nodeType_, sizeof(ns1__nodeType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__classPresentationType_, sizeof(ns1__classPresentationType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__severity_, sizeof(ns1__severity_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPassword, sizeof(ns1__authenticateByLoginPassword), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, sizeof(ns1__authenticateByLoginPasswordResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user, sizeof(ns1__user), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__identifiable, sizeof(ns1__identifiable), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipal, sizeof(ns1__authenticateByCallerPrincipal), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, sizeof(ns1__authenticateByCallerPrincipalResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberos, sizeof(ns1__authenticateByKerberos), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberosResponse, sizeof(ns1__authenticateByKerberosResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagramElements, sizeof(ns1__getProcessHistoryDiagramElements), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagramElementsResponse, sizeof(ns1__getProcessHistoryDiagramElementsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__graphElementPresentation, sizeof(ns1__graphElementPresentation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTask, sizeof(ns1__getTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTaskResponse, sizeof(ns1__getTaskResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfTask, sizeof(ns1__wfTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcess, sizeof(ns1__getProcess), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessResponse, sizeof(ns1__getProcessResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariable, sizeof(ns1__getVariable), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariableResponse, sizeof(ns1__getVariableResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variableDefinition, sizeof(ns1__variableDefinition), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variableUserType, sizeof(ns1__variableUserType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesCount, sizeof(ns1__getProcessesCount), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__batchPresentation, sizeof(ns1__batchPresentation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesCountResponse, sizeof(ns1__getProcessesCountResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesByFilter, sizeof(ns1__getProcessesByFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processFilter, sizeof(ns1__processFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesByFilterResponse, sizeof(ns1__getProcessesByFilterResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getParentProcess, sizeof(ns1__getParentProcess), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getParentProcessResponse, sizeof(ns1__getParentProcessResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSubprocesses, sizeof(ns1__getSubprocesses), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSubprocessesResponse, sizeof(ns1__getSubprocessesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cancelProcess, sizeof(ns1__cancelProcess), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cancelProcessResponse, sizeof(ns1__cancelProcessResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasks, sizeof(ns1__getProcessTasks), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasksResponse, sizeof(ns1__getProcessTasksResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagram, sizeof(ns1__getProcessDiagram), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagramResponse, sizeof(ns1__getProcessDiagramResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagram, sizeof(ns1__getProcessHistoryDiagram), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessHistoryDiagramResponse, sizeof(ns1__getProcessHistoryDiagramResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagramElements, sizeof(ns1__getProcessDiagramElements), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessDiagramElementsResponse, sizeof(ns1__getProcessDiagramElementsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignSwimlane, sizeof(ns1__assignSwimlane), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignSwimlaneResponse, sizeof(ns1__assignSwimlaneResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogs, sizeof(ns1__getProcessLogs), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processLogFilter, sizeof(ns1__processLogFilter), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogsResponse, sizeof(ns1__getProcessLogsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processLogs, sizeof(ns1__processLogs), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processLog, sizeof(ns1__processLog), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogValue, sizeof(ns1__getProcessLogValue), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessLogValueResponse, sizeof(ns1__getProcessLogValueResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpened, sizeof(ns1__markTaskOpened), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpenedResponse, sizeof(ns1__markTaskOpenedResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeProcesses, sizeof(ns1__removeProcesses), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeProcessesResponse, sizeof(ns1__removeProcessesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogs, sizeof(ns1__getSystemLogs), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogsResponse, sizeof(ns1__getSystemLogsResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__systemLog, sizeof(ns1__systemLog), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogsCount, sizeof(ns1__getSystemLogsCount), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSystemLogsCountResponse, sizeof(ns1__getSystemLogsCountResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariablesWS, sizeof(ns1__getVariablesWS), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVariablesWSResponse, sizeof(ns1__getVariablesWSResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variable, sizeof(ns1__variable), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__startProcessWS, sizeof(ns1__startProcessWS), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__startProcessWSResponse, sizeof(ns1__startProcessWSResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWS, sizeof(ns1__completeTaskWS), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWSResponse, sizeof(ns1__completeTaskWSResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateVariablesWS, sizeof(ns1__updateVariablesWS), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateVariablesWSResponse, sizeof(ns1__updateVariablesWSResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSwimlanes, sizeof(ns1__getSwimlanes), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getSwimlanesResponse, sizeof(ns1__getSwimlanesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfSwimlane, sizeof(ns1__wfSwimlane), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__graphElement, sizeof(ns1__graphElement), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__delegation, sizeof(ns1__delegation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcesses, sizeof(ns1__getProcesses), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessesResponse, sizeof(ns1__getProcessesResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasks, sizeof(ns1__getTasks), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasksResponse, sizeof(ns1__getTasksResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTask, sizeof(ns1__assignTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTaskResponse, sizeof(ns1__assignTaskResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__wfVariableStub, sizeof(ns2__wfVariableStub), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__identifiableBase, sizeof(ns1__identifiableBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processDefinitionDeleteLog, sizeof(ns1__processDefinitionDeleteLog), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__processDeleteLog, sizeof(ns1__processDeleteLog), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__swimlaneDefinition, sizeof(ns1__swimlaneDefinition), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__executor, sizeof(ns1__executor), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfProcess, sizeof(ns1__wfProcess), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__actor, sizeof(ns1__actor), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfExecutor, sizeof(ns1__wfExecutor), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__nodeType(struct soap *soap, enum ns1__nodeType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__nodeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__nodeType(struct soap *soap, const char *tag, int id, enum ns1__nodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__nodeType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__nodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__nodeType ** SOAP_FMAC4 soap_in_PointerTons1__nodeType(struct soap *soap, const char *tag, enum ns1__nodeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__nodeType **)soap_malloc(soap, sizeof(enum ns1__nodeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__nodeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__nodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__nodeType, sizeof(enum ns1__nodeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__nodeType(struct soap *soap, enum ns1__nodeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__nodeType);
	if (soap_out_PointerTons1__nodeType(soap, tag?tag:"ns1:nodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__nodeType ** SOAP_FMAC4 soap_get_PointerTons1__nodeType(struct soap *soap, enum ns1__nodeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__nodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__graphElementPresentation(struct soap *soap, ns1__graphElementPresentation **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__graphElementPresentation))
		soap_serialize_PointerTons1__graphElementPresentation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__graphElementPresentation(struct soap *soap, const char *tag, int id, ns1__graphElementPresentation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__graphElementPresentation);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__graphElementPresentation(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__graphElementPresentation *** SOAP_FMAC4 soap_in_PointerToPointerTons1__graphElementPresentation(struct soap *soap, const char *tag, ns1__graphElementPresentation ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__graphElementPresentation ***)soap_malloc(soap, sizeof(ns1__graphElementPresentation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__graphElementPresentation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__graphElementPresentation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__graphElementPresentation, sizeof(ns1__graphElementPresentation *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__graphElementPresentation(struct soap *soap, ns1__graphElementPresentation **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__graphElementPresentation);
	if (soap_out_PointerToPointerTons1__graphElementPresentation(soap, tag?tag:"ns1:graphElementPresentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__graphElementPresentation *** SOAP_FMAC4 soap_get_PointerToPointerTons1__graphElementPresentation(struct soap *soap, ns1__graphElementPresentation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__graphElementPresentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__graphElementPresentation(struct soap *soap, ns1__graphElementPresentation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__graphElementPresentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__graphElementPresentation(struct soap *soap, const char *tag, int id, ns1__graphElementPresentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__graphElementPresentation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__graphElementPresentation ** SOAP_FMAC4 soap_in_PointerTons1__graphElementPresentation(struct soap *soap, const char *tag, ns1__graphElementPresentation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__graphElementPresentation **)soap_malloc(soap, sizeof(ns1__graphElementPresentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__graphElementPresentation *)soap_instantiate_ns1__graphElementPresentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__graphElementPresentation ** p = (ns1__graphElementPresentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__graphElementPresentation, sizeof(ns1__graphElementPresentation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__graphElementPresentation(struct soap *soap, ns1__graphElementPresentation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__graphElementPresentation);
	if (soap_out_PointerTons1__graphElementPresentation(soap, tag?tag:"ns1:graphElementPresentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__graphElementPresentation ** SOAP_FMAC4 soap_get_PointerTons1__graphElementPresentation(struct soap *soap, ns1__graphElementPresentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__graphElementPresentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__actor(struct soap *soap, ns1__actor *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__actor))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__actor(struct soap *soap, const char *tag, int id, ns1__actor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__actor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__actor ** SOAP_FMAC4 soap_in_PointerTons1__actor(struct soap *soap, const char *tag, ns1__actor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__actor **)soap_malloc(soap, sizeof(ns1__actor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__actor *)soap_instantiate_ns1__actor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__actor ** p = (ns1__actor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__actor, sizeof(ns1__actor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__actor(struct soap *soap, ns1__actor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__actor);
	if (soap_out_PointerTons1__actor(soap, tag?tag:"ns1:actor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__actor ** SOAP_FMAC4 soap_get_PointerTons1__actor(struct soap *soap, ns1__actor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__actor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__user(struct soap *soap, ns1__user *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__user))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__user(struct soap *soap, const char *tag, int id, ns1__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__user);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__user ** SOAP_FMAC4 soap_in_PointerTons1__user(struct soap *soap, const char *tag, ns1__user **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__user **)soap_malloc(soap, sizeof(ns1__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__user *)soap_instantiate_ns1__user(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__user ** p = (ns1__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user, sizeof(ns1__user), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__user(struct soap *soap, ns1__user *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__user);
	if (soap_out_PointerTons1__user(soap, tag?tag:"ns1:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__user ** SOAP_FMAC4 soap_get_PointerTons1__user(struct soap *soap, ns1__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wstring);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{	wchar_t **p;
	p = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstring);
	if (soap_out_wstring(soap, tag?tag:"wchar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
